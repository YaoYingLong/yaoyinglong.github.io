<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YingLong</title>
  
  <subtitle>虽奔放不羁，但也自我束缚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoyinglong.github.io/"/>
  <updated>2020-10-09T07:43:15.836Z</updated>
  <id>https://yaoyinglong.github.io/</id>
  
  <author>
    <name>YaoYingLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAS原理及使用场景</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/CAS%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/CAS原理及使用场景/</id>
    <published>2020-10-14T16:00:00.000Z</published>
    <updated>2020-10-09T07:43:15.836Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="CAS" scheme="https://yaoyinglong.github.io/tags/CAS/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/单例模式/</id>
    <published>2020-10-08T16:00:00.000Z</published>
    <updated>2020-10-09T07:37:51.635Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式的核心代码就是将<strong>构造方法私有化</strong>，只有一个实例，自己负责创建自己的对象，提供一种访问其唯一对象的方式，可直接访问，不需要实例化该类的对象。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>实例在使用时才去创建，用的时候才去检查有没有实例。有线程安全和线程不安全两种写法，区别就是<code>synchronized</code>关键字。下面这种写法存在线程安全问题，在并发获取实例时，可能会存在创建多个实例的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>在类加载时实例被创建。实现简单且没有线程安全的问题，可能在还不需要此实例的时候就已经把实例创建出来了，浪费内存空间，没起到<code>lazy loading</code>的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双检锁"><a href="#双检锁" class="headerlink" title="双检锁"></a>双检锁</h3><p><strong>双重校验锁</strong>，综合了<strong>懒汉式</strong>和<strong>饿汉式</strong>两者的优缺点。特点在<code>synchronized</code>关键字内外都加了一层 <code>if</code> 条件判断，既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。这里还用到了<code>volatile</code>关键字来修饰<code>instance</code>，其最关键的作用是<strong>防止指令重排</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类的方式效果类似双检锁，但实现更简单且线程安全。同时静态内部类不会在<code>Singleton</code>类加载时就加载，而是在调用<code>getInstance()</code>方法时才进行加载，<strong>达到了懒加载的效果</strong>。但这种方式只适用于<strong>静态域</strong>的情况，双检锁方式可在<strong>实例域</strong>需要<strong>延迟初始化</strong>时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举的方式是比较少见的一种实现方式，却更简洁清晰。还<strong>自动支持序列化机制</strong>，绝对防止多次实例化。<strong>单元素</strong>的<strong>枚举类型</strong>已经成为实现<code>Singleton</code>的最佳方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring中典型应用"><a href="#Spring中典型应用" class="headerlink" title="Spring中典型应用"></a>Spring中典型应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">   Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">         singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">         <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式的核心代码就是将&lt;strong&gt;构造方法私有化&lt;/strong&gt;，只有一个实例，自己负责创建自己的对象，提供一种访问其唯一对象的方式，可直接访问，不需要实例化该类的对象。&lt;/p&gt;
&lt;h3 id=&quot;懒汉式&quot;&gt;&lt;a href=&quot;#懒汉式&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Volatile原理</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Volatile%E5%8E%9F%E7%90%86/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Volatile原理/</id>
    <published>2020-10-05T16:00:00.000Z</published>
    <updated>2020-10-09T07:42:56.485Z</updated>
    
    <content type="html"><![CDATA[<p>在说<code>Volatile</code>原理前先熟悉一下相关的基本概念<strong><a href="../原子性、可见性、有序性">原子性、可见性、有序性</a></strong></p><h3 id="Volatile原理"><a href="#Volatile原理" class="headerlink" title="Volatile原理"></a>Volatile原理</h3><p><code>Volatile</code>是<code>Java</code>提供的一种<strong>稍弱</strong>的<strong>同步机制</strong>，用来确保将变量的更新操作通知到其他线程，编译器与运行时都会注意到该变量是<strong>共享</strong>的，不会将该变量上的操作与其他内存操作一起<strong>重排序</strong>。<code>volatile</code>变量<strong>不会被缓存在寄存器</strong>或<strong>对其他处理器不可见的地方</strong>，读取<code>volatile</code>变量时总返回最新写入的值。</p><p>访问<code>volatile</code>变量时<strong>不会执行加锁操作</strong>，<code>volatile</code>变量是一种比<code>sychronized</code>关键字<strong>更轻量级的同步机制</strong>。对非<code>volatile</code>变量进行读写时，每个线程先<strong>从内存拷贝变量到<code>CPU</code>缓存中</strong>。若计算机有多个<code>CPU</code>，每个线程可能在不同的<code>CPU</code>上被处理，每个线程可以<strong>拷贝到不同的<code>CPU cache</code>中</strong>。声明<code>volatile</code>变量时，<code>JVM</code>保证每次读变量都从主内存中读取，<strong>跳过<code>CPU cache</code>这一步</strong>。</p><p><img src="../../../../../images/Java/多线程数据读写模型.png" alt></p><p><strong><code>Volatile</code>保证当前<code>CPU</code>缓存、其他<code>CPU</code>缓存、主内存、工作内存间的数据一致及读写逻辑代码的有序执行</strong>。</p><p><code>volatile</code> 保证变量对所有线程的<strong>可见性</strong>，当一个线程修改了这个变量的值，<code>volatile</code> 保证了<strong>新值能立即同步到主内存</strong>，以及<strong>每次使用前立即从主内存刷新</strong>。<strong>可见性</strong>只能保证每次读取的是最新的值，但<code>volatile</code>没办法保证对变量操作的<strong>原子性</strong>。</p><p><code>volatile</code> 禁止指令重排序，<code>volatile</code>修饰的变量，赋值后多执行了一个<code>load addl $0x0, (%esp)</code>操作，该操作相当于一个<strong>内存屏障</strong>，指令重排序时<strong>不能把后面的指令重排序到内存屏障之前的位置</strong>，只有一个CPU访问内存时，不需要内存屏障。</p><p><code>volatile</code> 的<strong>读性能消耗</strong>与普通变量几乎相同，但<strong>写操作稍慢</strong>，因为它需要在本地代码中插入许多<strong>内存屏障指令</strong>来保证处理器不发生乱序执行。</p><h3 id="C和C"><a href="#C和C" class="headerlink" title="C和C++"></a>C和C++</h3><p>在<code>C</code>和<code>C++</code>中的<code>volatile</code>作用：<strong>优化无效代码、禁止指令重排序、直接完成简单运算、读写都走内存不走寄存器</strong>。<code>volatile</code>是通过<code>lock</code>指令触发了<strong>读写屏障</strong>，通过<strong><code>MESI</code>缓存一致性协议</strong>从而实现了<strong>当前<code>CPU</code>、其他<code>CPU</code>和主存之间的一致性</strong>。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p><strong>编译器屏障</strong>：在解决<strong>编译乱序</strong>问题时，需要使用<strong><code>barrier()</code>编译屏障</strong>，在<code>code</code>中使用<code>barrier()</code>可以<strong>阻止编译器对该<code>code</code>的编译优化</strong>，可以<strong>防止编译屏障之前的<code>code</code>和编译屏障之后的<code>code</code>出现编译乱序</strong>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#definebarrier() _asm_ _volatile_("": : :"memory")</span><br></pre></td></tr></table></figure><p><strong><code>CPU</code>屏障</strong>：是为了解决缓存一致性问题，分为<strong>锁总线（<code>ifence</code>、<code>sfence</code>、<code>mfence</code>）</strong>和<strong>锁缓存（<code>lock</code>）</strong>，锁总线的方式已被淘汰。锁缓存其实是通过<strong><code>MESI</code>缓存一致性协议</strong>来完成的。</p><p><strong><code>JVM</code>中的四种内存屏障</strong>：<code>storeload</code>、<code>storestore</code>、<code>loadload</code>、<code>loadstore</code></p><p><strong>注</strong>：<code>32</code>位机<code>32</code>根总线、<code>64</code>位机<code>64</code>根总线，<code>ifence</code>写、<code>sfence</code>写、<code>mfence</code>读写</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>使用volatile必须具备2个条件：对变量的写操作不依赖于当前值，该变量没有包含在具有其他变量的不变式中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在说&lt;code&gt;Volatile&lt;/code&gt;原理前先熟悉一下相关的基本概念&lt;strong&gt;&lt;a href=&quot;../原子性、可见性、有序性&quot;&gt;原子性、可见性、有序性&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Volatile原理&quot;&gt;&lt;a href=&quot;#Volatil
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Volatile" scheme="https://yaoyinglong.github.io/tags/Volatile/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>动态代理</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/动态代理/</id>
    <published>2020-09-09T16:00:00.000Z</published>
    <updated>2020-10-09T07:41:12.170Z</updated>
    
    <content type="html"><![CDATA[<p>代理的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealSubject do something "</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectProxy</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Do something before"</span>);</span><br><span class="line">        subject.doSomething(param);</span><br><span class="line">        System.out.println(<span class="string">"Do something after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是jre提供的类库，可直接使用<strong>不依赖第三方</strong>，但<code>JDK</code>的<strong>动态代理</strong>只能代理接口。首先创建一个<strong>代理类<code>EnhaceInvocationHandler</code></strong>实现<code>java.lang.reflect.InvocationHandler</code>接口，<strong>重写<code>invoke</code>方法</strong>。在<code>method.invoke</code>方法调用前后添加我们需要增强的代码逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhaceInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnhaceInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object obj : args) &#123;</span><br><span class="line">                System.out.println(<span class="string">"args=="</span> + obj.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"args==null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Do something before"</span>);</span><br><span class="line">            Object result = method.invoke(target, args);</span><br><span class="line">            System.out.println(<span class="string">"Do something after"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getCause().printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">creatProxyObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">Subject subject = (Subject) Proxy.newProxyInstance(Subject.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;Subject.class&#125;,</span><br><span class="line">        <span class="keyword">new</span> EnhaceInvocationHandler(realSubject));</span><br><span class="line">subject.doSomething(<span class="string">"AAAA"</span>);</span><br><span class="line"></span><br><span class="line">EnhaceInvocationHandler handler = <span class="keyword">new</span> EnhaceInvocationHandler(realSubject);</span><br><span class="line">Subject subject = (Subject)  handler.creatProxyObj();</span><br><span class="line">subject.doSomething(<span class="string">"AAAA"</span>);</span><br></pre></td></tr></table></figure><h3 id="CGLib代理"><a href="#CGLib代理" class="headerlink" title="CGLib代理"></a>CGLib代理</h3><p><strong>代理的目的是构造一个和被代理的对象同样行为的对象</strong>，一个对象的行为是在类中定义的，对象只是类的实例，故构造代理不一定非得通过持有、包装对象这一种方式。<strong><code>CGLib</code>是通过继承父类所有的公有方法</strong>，然后重写这些方法，在<strong>重写时对这些方法增强</strong>。首先也是创建一个代理类<code>CGLibProxy</code>实现<code>net.sf.cglib.proxy.MethodInterceptor</code>接口重写<code>intercept</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Do something before"</span>);</span><br><span class="line">        Object object = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">        System.out.println(<span class="string">"Do something after"</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">creatProxyObj</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置代理的地方与<strong><code>JDK</code>动态代理</strong>略有区别。并不要求委托类必须实现接口，底层采用<strong><code>asm</code>字节码</strong>生成框架生成代理类的字节码，<code>Enhancer</code>是<code>CGLib</code>的<strong>字节码增强器</strong>，可以方便的对类进行扩展，内部调用<code>GeneratorStrategy.generate</code>方法生成代理类的字节码，<strong><code>CGLib</code>动态代理</strong>不仅仅<strong>可以代理接口</strong>，还可以代理<strong>非接口类</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(realSubject.getClass());</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> CGLibProxy());</span><br><span class="line">Subject subject = (Subject) enhancer.create();</span><br><span class="line">subject.doSomething(<span class="string">"AAAA"</span>);</span><br><span class="line"></span><br><span class="line">CGLibProxy proxy = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line">Subject subject = (Subject) proxy.creatProxyObj(realSubject.getClass());</span><br><span class="line">subject.doSomething(<span class="string">"AAAA"</span>);</span><br></pre></td></tr></table></figure><p><code>CGLib</code>动态代理中生成的<strong>字节码更加复杂</strong>，生成的代理类是委托类的子类，且<strong>不能处理被<code>final</code>关键字修饰的方法</strong>；<code>JDK</code>采用<strong>反射机制</strong>调用委托类的方法，<code>CGLib</code>采用<strong>类似索引</strong>的方式<strong>直接调用委托类方法</strong>；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理的基础类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="动态代理" scheme="https://yaoyinglong.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>反射基础</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/反射基础/</id>
    <published>2020-09-07T16:00:00.000Z</published>
    <updated>2020-10-09T07:41:21.920Z</updated>
    
    <content type="html"><![CDATA[<p>反射主要指程序可以访问、检测和修改他本身状态和行为的一种能力，程序在运行时能获取自身的信息；对于任意一个类，都能够获取到这个类的<strong>所有属性和方法</strong>，对于任意一个对象，都能够调用它的<strong>任意一个方法和属性</strong>，包括<strong>私有</strong>的方法和属性，这种<strong>动态获取的信息以及动态调用对象的方法的功能</strong>就称为<code>Java</code>语言的反射机制。</p><p><strong>反射的优点</strong>：能使代码更灵活，更加容易实现面向对象，能够使我们很方便的创建灵活的代码，这些代码可以在运行时再装配，无需组件之间进行源代码的链接，体现了多态的应用，降低类之间的耦合性，可以动态的创建对象和编译；</p><p><strong>反射的缺点</strong>：打破了<code>Java</code>的封装性，导致了<code>Java</code>对像的不安全，使软件的性能降低，复杂度增加，维护成本变高。</p><p>反射相关的主要<code>API</code>:</p><ul><li><strong><code>java.lang.Class</code></strong>：代表一个类</li><li><strong><code>java.lang.reflect.Method</code></strong>：代表类的方法</li><li><strong><code>java.lang.reflect.Field</code></strong>：代表类的成员变量</li><li><strong><code>java.lang.reflect.Constructor</code></strong>：代表类的构造方法</li></ul><p>用于测试的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectIssue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String publicParam = <span class="string">"this is a reflect public parameter"</span>;</span><br><span class="line">    <span class="keyword">private</span> String privateParam = <span class="string">"this is a reflect private parameter"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectIssue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectIssue</span><span class="params">(String publicParam, String privateParam)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publicParam = publicParam;</span><br><span class="line">        <span class="keyword">this</span>.privateParam = privateParam;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reflectPrivate</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private : "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflectPublic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public : "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moreParam</span><span class="params">(String paramA, String paramB)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"paramA : "</span> + paramA + <span class="string">", paramB："</span> + paramB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reflection方式"><a href="#Reflection方式" class="headerlink" title="Reflection方式"></a>Reflection方式</h3><p>获取类的<code>Class</code>对象有以下<strong>四种</strong>方式，实际应用中最常用的是通过<code>Class.forName</code>和<code>classLoader</code>的方式来获取<code>Class</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReflectIssue reflectIssue = <span class="keyword">new</span> ReflectIssue();</span><br><span class="line">Class clazz = reflectIssue.getClass();</span><br><span class="line"></span><br><span class="line">Class clazz = ReflectIssue.class;</span><br><span class="line"></span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.example.ReflectIssue"</span>);</span><br><span class="line"></span><br><span class="line">ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">Class clazz = classLoader.loadClass(<span class="string">"com.example.ReflectIssue"</span>);</span><br></pre></td></tr></table></figure><p><strong><code>getField</code>不能</strong>获取<strong>私有属性</strong>，要获取私有属性使用<code>getDeclaredField</code>方法，该方法<strong>也可以</strong>用于获取<code>public</code>属性。如果要访问私有属性必须通过<code>setAccessible</code>将<strong>访问权限</strong>打开。如果在<strong>当前类</strong>中进行<strong>反射调用自己</strong>可以不用通过<code>setAccessible</code>打开权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.example.ReflectIssue"</span>);</span><br><span class="line">ReflectIssue reflectIssue = (ReflectIssue) clazz.newInstance();</span><br><span class="line">Field publicParam = clazz.getField(<span class="string">"publicParam"</span>);</span><br><span class="line">System.out.println(publicParam.getName());</span><br><span class="line">System.out.println(publicParam.get(reflectIssue));</span><br><span class="line"></span><br><span class="line">Field privateParam = clazz.getDeclaredField(<span class="string">"privateParam"</span>);</span><br><span class="line">privateParam.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(privateParam.getName());</span><br><span class="line">System.out.println(privateParam.get(reflectIssue));</span><br><span class="line">privateParam.set(reflectIssue, <span class="string">"new private param value"</span>);</span><br></pre></td></tr></table></figure><p>同样针对于方法的获取，私有方法获取必须使用<code>getDeclaredMethod</code>方法，该方法也可以用于获取<code>public</code>方法，关于参数的列表可以<strong>直接传入一个数组</strong>，也可以<strong>按照顺序传入多个参数</strong>。私有方法的调用需要通过<code>setAccessible</code>方法打开权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Method method = clazz.getMethod(<span class="string">"reflectPublic"</span>, String.class);</span><br><span class="line">method.invoke(clazz.newInstance(), <span class="string">"this is a public function"</span>);</span><br><span class="line"></span><br><span class="line">Method method = clazz.getMethod(<span class="string">"reflectPublic"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">method.invoke(clazz.newInstance(), <span class="keyword">new</span> Object[]&#123;<span class="string">"this is a public function"</span>&#125;);</span><br><span class="line"></span><br><span class="line">Method reflectPrivate = clazz.getDeclaredMethod(<span class="string">"reflectPrivate"</span>, String.class);</span><br><span class="line">reflectPrivate.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">reflectPrivate.invoke(clazz.newInstance(), <span class="string">"this is a private function"</span>);</span><br><span class="line"></span><br><span class="line">((ReflectIssue) clazz.newInstance()).reflectPrivate(<span class="string">"this is a private function"</span>);</span><br></pre></td></tr></table></figure><p>在实际使用中可能需要用到<strong>多参数构造方法</strong>进行对象的实例化，多参数构造方法实例化类，使用<code>getConstructor</code>和<code>getDeclaredConstructor</code>都可以。<code>getDeclaredConstructor</code>可以获取私有构造方法。和私有属性私有方法访问一样私有构造方法访问需要通过<code>Constructor</code>的<code>setAccessible</code>打开访问权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.example.ReflectIssue"</span>);</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(String.class, String.class);</span><br><span class="line">ReflectIssue reflectIssue2 = (ReflectIssue) constructor.newInstance(<span class="string">"paramA"</span>, <span class="string">"paramB"</span>);</span><br><span class="line"></span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ReflectIssue reflectIssue2 = (ReflectIssue) constructor.newInstance(<span class="string">"paramA"</span>);</span><br></pre></td></tr></table></figure><h3 id="MethodHandle方式"><a href="#MethodHandle方式" class="headerlink" title="MethodHandle方式"></a>MethodHandle方式</h3><p>也可以使用虚拟机提供的<code>MethodHandle</code>通过模拟<strong>字节码层次</strong>的调用来实现反射，需要主意得是，默认所有得方法得第一个参数一定是一个<code>void</code>参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.example.ReflectIssue"</span>);</span><br><span class="line"></span><br><span class="line">MethodType methodType = MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">MethodHandle methodHandle = MethodHandles.lookup().findVirtual(clazz, <span class="string">"reflectPublic"</span>, methodType).bindTo(clazz.newInstance());</span><br><span class="line">methodHandle.invokeExact(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">MethodType methodType = MethodType.methodType(<span class="keyword">void</span>.class, String.class, String.class);</span><br><span class="line">MethodHandle methodHandle = MethodHandles.lookup().findVirtual(clazz, <span class="string">"moreParam"</span>, methodType).bindTo(clazz.newInstance());</span><br><span class="line">methodHandle.invokeExact(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">Method pm = clazz.getDeclaredMethod(<span class="string">"reflectPrivate"</span>, String.class);</span><br><span class="line">pm.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">MethodHandle methodHandle = lookup.unreflect(pm);</span><br><span class="line">methodHandle.invoke(clazz.newInstance(), <span class="string">"a"</span>);</span><br><span class="line">methodHandle.invokeExact((ReflectIssue) clazz.newInstance(), <span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><p><code>MethodHandle</code>服务于<strong>所有<code>java</code>虚拟机上的语言</strong>，<code>Reflection</code>仅仅<strong>服务于<code>java</code>语言</strong>，<code>Reflection</code>在<strong>模拟<code>Java</code>代码层次</strong>的调用，而<code>MethodHandle</code>在<strong>模拟字节码层次</strong>的方法调用。<code>Reflection</code>是<strong>重量级</strong>，而<code>MethodHandle</code>是<strong>轻量级</strong>。<code>MethodHandle</code>可以进行<strong>内联优化</strong>，<code>Reflection</code>完全没有。但<code>JDK8</code>环境下<strong><code>MethodHandles.lookup</code>方法是调用者敏感的</strong>。不同调用者访问权限不同，其结果也不同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反射主要指程序可以访问、检测和修改他本身状态和行为的一种能力，程序在运行时能获取自身的信息；对于任意一个类，都能够获取到这个类的&lt;strong&gt;所有属性和方法&lt;/strong&gt;，对于任意一个对象，都能够调用它的&lt;strong&gt;任意一个方法和属性&lt;/strong&gt;，包括&lt;st
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="反射" scheme="https://yaoyinglong.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析JDK8</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90JDK8/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/HashMap源码分析JDK8/</id>
    <published>2020-09-06T16:00:00.000Z</published>
    <updated>2020-10-09T07:40:44.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><p><code>JDK7</code>中数据结构的存储由<strong>数组</strong>+<strong>链表</strong>的方式，因为数组是一组连续的内存空间，易查询，不易增删，而链表是不连续的内存空间，通过节点相互连接，易删除，不易查询。</p><p><code>JDK8</code>中为了解决<code>hash</code>碰撞过于频繁和链表过长查询效率过低，采用<strong>数组</strong>+<strong>链表</strong>+<strong>红黑树</strong>的存储方式，<strong>当链表长度超过阈值<code>8</code>时，将链表转换为红黑树</strong>。极大的提高了查询效率。</p><p><img src="../../../../../images/Java/JDK8中HashMap存储结构.png" alt="JDK8中HashMap存储结构"></p><p>在<code>JDK8</code>中默认容量，最大容量以及装载因子等默认值未发生变化。但是多了一些树相关的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><code>JDK8</code>中<code>hash</code>方法有略微的简化了，可能是因为引用了<strong>红黑树</strong>，没有必要再对<code>hashCode</code>过于离散化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法略微变化，最大的变化是将获取<code>table</code>的容量的方法<code>tableSizeFor</code>进行了优化，且移位方式由带符号右移变成了无符号又移，在构造方法中就计算好<code>threshold</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><p>在<code>JDK8</code>中<code>table</code>的扩容是在<strong>添加元素后再进行</strong>的。当<code>table</code>为空时通过<code>resize()</code>方法对<code>table</code>进行初始化，以及<code>++size &gt; threshold</code>时通过<code>resize()</code>方法对<code>table</code>的扩容。</p><p>如果新插入的元素的<code>key</code>不存在与链表中，则将新元素插入到对应链表的<strong>尾部</strong>，相对于<code>JDK7</code>的头插法，解决了并发情况下的死循环问题。当插入新元素后链表的长度大于等于8时，会通过<code>treeifyBin</code>方法将链表转换成红黑树。</p><p>如果新插入的元素的key存在于链表中，退出<code>for (int binCount = 0; ; ++binCount)</code>循环，将旧值替换为新的值。其中<code>13、14</code>行干的是同样的事。</p><p>如果<code>table</code>中存的已经是<strong>红黑树</strong>了，就直接进行红黑树的插入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>threshold</code>的值在构造方法中被赋值为<code>table</code>的<code>capacity</code>，但是在<code>resize()</code>方法中被重新设置为<code>capacity * loadFactor</code>。这里对<code>table</code>的扩容以及<code>threshold</code>调整都是通过<strong>向左移位</strong>来完成的。</p><p><code>43</code>行的<code>if</code>判断，主要是为了将老的<code>table</code>中的一个链表按照<strong>高位</strong>和<strong>低位</strong>拆分成两个链表。这个跟JDK是类是的，只不过<code>JDK7</code>是使用的头插法，这里是使用的尾插法，实现方式不一样。高位链表的数据下标按照<code>JDK7</code>的实现方式就为<code>hiHead.hash &amp; (newCap - 1)</code>其实就等于这里的<code>j + oldCap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resize()</code>方法中当table存储的元素是红黑树时，将通过<code>split</code>方法按照<code>hash</code>值得<strong>高低位</strong>将一颗树拆分成两棵树。如果拆分后树得节点个数小于等于<code>UNTREEIFY_THRESHOLD = 6</code>时，将树转换回链表。否正将<code>loHead</code>和<code>hiHead</code>转换成红黑树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据存储结构&quot;&gt;&lt;a href=&quot;#数据存储结构&quot; class=&quot;headerlink&quot; title=&quot;数据存储结构&quot;&gt;&lt;/a&gt;数据存储结构&lt;/h3&gt;&lt;p&gt;&lt;code&gt;JDK7&lt;/code&gt;中数据结构的存储由&lt;strong&gt;数组&lt;/strong&gt;+&lt;strong&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="HashMap" scheme="https://yaoyinglong.github.io/tags/HashMap/"/>
    
      <category term="JDK8" scheme="https://yaoyinglong.github.io/tags/JDK8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析JDK7</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90JDK7/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/HashMap源码分析JDK7/</id>
    <published>2020-09-06T16:00:00.000Z</published>
    <updated>2020-10-09T07:40:59.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ul><li><p><strong>直接定址法</strong>：直接以<strong>关键字<code>k</code></strong>或者<code>k</code>加上某个常数（<code>k+c</code>）作为哈希地址。</p></li><li><p><strong>数字分析法</strong>：提取关键字中<strong>取值比较均匀</strong>的数字作为哈希地址。</p></li><li><p><strong>除留余数法</strong>：用关键字<code>k</code>除以某个<strong>不大于哈希表长度</strong><code>m</code>的数<code>p</code>，将所得<strong>余数</strong>作为哈希表地址。</p></li><li><p><strong>分段叠加法</strong>：按照哈希表<strong>地址位数</strong>将关键字分成<strong>位数相等</strong>的几部分，其中最后一部分可以比较短。然后将这几部分<strong>相加</strong>，<strong>舍弃最高进位后</strong>的结果就是该关键字的哈希地址。</p></li><li><p><strong>平方取中法</strong>：如果关键字各个部分分布都不均匀的话，可以先求出它的<strong>平方值</strong>，然后按照需求<strong>取中间的几位</strong>作为哈希地址。</p></li><li><p><strong>伪随机数法</strong>：采用一个<strong>伪随机数</strong>当作哈希函数</p></li></ul><h3 id="解决碰撞算法"><a href="#解决碰撞算法" class="headerlink" title="解决碰撞算法"></a>解决碰撞算法</h3><p>衡量一个哈希函数的好坏的重要指标就是<strong>发生碰撞的概率</strong>以及<strong>发生碰撞的解决方案</strong>。任何哈希函数<strong>基本都无法彻底避免碰撞</strong>，常见的解决碰撞的方法有以下几种：</p><ul><li><p><strong>开放定址法</strong>：开放定址法就是<strong>一旦发生了冲突，就去寻找下一个空的散列地址</strong>，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p></li><li><p><strong>链地址法</strong>：将哈希表的每个单元作为链表的头结点，所有哈希地址为<code>i</code>的元素构成一个同义词链表。即<strong>发生冲突时就把该关键字链在以该单元为头结点的链表的尾部</strong>。</p></li><li><p><strong>再哈希法</strong>：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</p></li><li><p><strong>建立公共溢出区</strong>：将哈希表分为<strong>基本表</strong>和<strong>溢出表</strong>两部分，发生冲突的元素都放入溢出表中。</p></li></ul><h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><p><code>HashMap</code>是由<strong>数组</strong>和<strong>链表</strong>来实现的对数据的存储，采用<code>Entry</code>数组来存储<code>key-value</code>对，每一个键值对组成了一个<code>Entry</code>实体，<code>Entry</code>类实际上是一个单向的链表结构，它具有<code>Next</code>指针，可以连接下一个<code>Entry</code>实体，<strong>以此来解决<code>Hash</code>冲突</strong>的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashSeed问题"><a href="#hashSeed问题" class="headerlink" title="hashSeed问题"></a><code>hashSeed</code>问题</h3><p>对<code>key</code>的<code>hashCode</code>进行了<strong>二次<code>hash</code></strong>，即hash扰动，<strong>以获得更好的散列值</strong>。这里做二次hash的目的是避免，自定义对象的<code>hashCode</code>方法，算出来的<code>hashCode</code>离散性比较差，从而导致某些链表特别长，而有些特别短，从而导致性能差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到的<code>hashSeed</code>值在<code>HashMap</code>初始化时默认为0，根据源码来看<code>hashSeed</code>可能会在初始化<code>table</code>时通过<code>inflateTable</code>中调用的<code>initHashSeedAsNeeded</code>方法被重新设置。<code>currentAltHashing</code>显然为<code>false</code>，<code>useAltHashing</code>通过下面分析可知其值为也为<code>false</code>，故<code>initHashSeedAsNeeded</code>始终返回<code>false</code>，而<code>hashSeed</code>值始终得不到重新设置，所以其始终为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sun.misc.VM.isBooted()</code>的源码如下，但是实际通过调用发现其返回值为<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> booted = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBooted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> booted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而关于<code>Holder.ALTERNATIVE_HASHING_THRESHOLD</code>，如下所示该值取决于<code>altThreshold</code>的值，实际条用发现该值其实为<code>null</code>，故<code>Holder.ALTERNATIVE_HASHING_THRESHOLD</code>为<code>Integer.MAX_VALUE</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        String altThreshold = java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"jdk.map.althashing.threshold"</span>));</span><br><span class="line">        <span class="keyword">int</span> threshold;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threshold = (<span class="keyword">null</span> != altThreshold) ? Integer.parseInt(altThreshold)</span><br><span class="line">                    : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;</span><br><span class="line">            <span class="keyword">if</span> (threshold == -<span class="number">1</span>) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (threshold &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"value must be positive integer."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException failed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Illegal value for 'jdk.map.althashing.threshold'"</span>, failed);</span><br><span class="line">        &#125;</span><br><span class="line">        ALTERNATIVE_HASHING_THRESHOLD = threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>HashMap</code>的前三个构造方法仅仅是给负载系数<code>loadFactor</code>和数组容量阈值<code>threshold</code>赋值，并不会对数组<code>table</code>进行填充初始化等。<code>HashMap</code>的填充是在真正使用时才会通过<code>inflateTable</code>方法进行填充。如<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>、<code>put(K key, V value)</code>、<code>putAll(Map&lt;? extends K, ? extends V&gt; m)</code>等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="comment">// 用于存储链表数据</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="comment">// 存储KV的数量, 所有链表元素总和</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// threshold=capacity*loadFactor，size大于threshold时会执行resize操作</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 装载因子，用来衡量HashMap满的程度</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 记录当前集合被修改的次数: 添加，删除，为了实现快速失败的机制</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表的初始化"><a href="#表的初始化" class="headerlink" title="表的初始化"></a>表的初始化</h3><p><code>inflateTable</code>方法是为了初始化数组<code>table</code>，当通过构造方法创建<code>HashMap</code>时设置了<code>initialCapacity</code>，但是实际上创建数组时，使用的并不是我们设置<code>initialCapacity</code>来创建的数组的长度，而是通过<code>roundUpToPowerOf2</code>方法对数组容量进行了优化，不管怎么设置<code>initialCapacity</code>大小，数组容量始终是<code>2</code>的幂，且是大于等于<code>threshold</code>的最近的<code>2</code>的幂。也为后续通过<code>indexFor</code>方法为<code>hash</code>值取模起到帮助。</p><p><code>highestOneBit</code>方法是为了获取二进制数据的最高位，低位全部置0，在调用<code>highestOneBit</code>方法之所以传入的是<code>(number - 1) &lt;&lt; 1</code>而不是直接传入<code>number &lt;&lt; 1</code>，因为若<code>number</code>本身就是<code>2</code>的幂，就会造成将数组容量扩大一倍，若<code>number = 16</code>期望返回的是<code>16</code>，若传入<code>number &lt;&lt; 1</code>将放回<code>32</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取大于等于number的最接近的2的幂的数作为数组的容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据二进制的最高位，低位全部置0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><p>当存在相同的<code>key</code>且<code>hash</code>相同时，是替换已有的值，并将旧值返回，而不知直接插入到链表中。之所以即要判断散列值也要判断key，是因为<strong>不同的输入可能会散列成相同的输出</strong>。<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。同一散列函数计算出的散列值相同的现象叫做碰撞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅当 <code>b = 2^n</code> 时位运算才可以转换成取模运算，<code>a % b = a &amp; (b - 1)</code> 。故<code>HashMap</code>才将初始长度设置为 <code>16</code>，且扩容只能是以 <code>2</code> 的倍数扩容。由上面可知数组容量始终是2的幂，故可通过<code>h &amp; (length-1)</code>对<code>hash</code>值取余，从而获取对应的<code>table</code>数组的下标。使用位运算代替取模运算，除了性能之外，还有一个好处就是可以很好的<strong>解决负数</strong>的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>put</code>方法中<code>key</code>为空的情况调用的<code>putForNullKey()</code>方法可知，<code>HashMap</code>中<code>key</code>为空的数据始终是存储到数组<code>table</code>下标为<code>0</code>的链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>table数组的长度并不是初始化后就固定不变了，将链表变得非常长后效率将变得低下，故当元素个数大于等于<code>threshold = capacity * loadFactor</code>时且<strong>该数组下标对应的链表不为空</strong>，就对数组进行扩容。且是按<strong>两倍</strong>进行扩容。并将数据从旧的<code>table</code>中拷贝到新的<code>table</code>中。在<code>createEntry</code>仅仅只有两行代码，实现了数据在链表中的头插法插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>newCapacity</code>容量变化了，故<code>indexFor</code>返回的数据下标将可能变化或变成另一个固定的值，故旧的<code>table</code>中同一个链表的数据拷贝到新的<code>table</code>中<strong>可能会拆分成两个链表</strong>，且将旧表中的数据使用的<strong>头插法</strong>进行拷贝到新的<code>table</code>中的链表中，<strong>链表中的数据将被反序</strong>。而不是直接将数组的前N个元素对拷贝到新的数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>1.8</code>之前，新插入的元素都是放在了<strong>链表的头部</strong>位置，但是这种操作在<strong>高并发</strong>的环境下<strong>容易导致死锁</strong>，所以<code>1.8</code>之后，新插入的元素都放在了<strong>链表的尾部</strong>。</p><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>首先计算<code>hash</code>值通过<code>indexFor()</code>方法得到该<code>key</code>在<code>table</code>中的存储位置，遍历链表，在获取数据时不仅判断了hash值是否相等，还判断了key是否相等，故有时候重写<code>hashCode</code>和<code>equals</code>方法尤为重要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;直接定址法&lt;/strong&gt;：直接以&lt;strong&gt;关键字&lt;code&gt;k&lt;/code&gt;&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="HashMap" scheme="https://yaoyinglong.github.io/tags/HashMap/"/>
    
      <category term="JDK7" scheme="https://yaoyinglong.github.io/tags/JDK7/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/位运算/</id>
    <published>2020-09-02T16:00:00.000Z</published>
    <updated>2020-10-09T07:41:44.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字节、字、位、比特"><a href="#字节、字、位、比特" class="headerlink" title="字节、字、位、比特"></a>字节、字、位、比特</h3><p>1位 = 1比特， 1字节 = 8位，1字=2字节， <code>1Byte=8bit 1B = 8bit</code>， <code>1KB = 1024B</code></p><p><strong>位</strong>：计算机最小存储单位，简记为<strong><code>b</code></strong>，也成为<strong>比特<code>bit</code></strong>，计算机中用<code>0</code>和<code>1</code>来表示数据，一个<code>0</code>或<code>1</code>就代表<code>1</code>位。</p><p><strong>比特（<code>bit</code>）</strong>：也是二进制数字中的位，信息量的最小单位。</p><p><strong>字节（<code>Byte</code>）</strong>：计算存储容量的计量单位，<strong>一个字节等于八位</strong>。习惯上用<strong><code>B</code></strong>表示。</p><p><strong>字</strong>：计算机进行数据处理时，一次存取、加工和传送的数据长度称为字（<code>word</code>），一个字通常由一个或多个（一般是字节的整数位）字节构成。如286微机的字由2个字节组成；486微机的字由4个字节组成。</p><h3 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h3><p>Java中有三个位移运算：</p><ul><li><code>&lt;&lt;：左移</code>：正数高位丢弃，低位补0，负数符号位保持不变</li><li><code>&gt;&gt;：右移</code>：正数低位丢弃，高位补0；负数高位补1</li><li><code>&gt;&gt;&gt;：无符号右移</code>：低位丢弃，高位补0，符号位也会跟着一起移动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">2</span> &lt;&lt; <span class="number">1</span>);     <span class="comment">// 4</span></span><br><span class="line">System.out.println(<span class="number">2</span> &gt;&gt; <span class="number">1</span>);     <span class="comment">// 1</span></span><br><span class="line">System.out.println(<span class="number">2</span> &gt;&gt;&gt; <span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line">System.out.println(-<span class="number">2</span> &lt;&lt; <span class="number">1</span>);    <span class="comment">// -4</span></span><br><span class="line">System.out.println(-<span class="number">2</span> &gt;&gt; <span class="number">1</span>);    <span class="comment">// -1</span></span><br><span class="line">System.out.println(-<span class="number">2</span> &gt;&gt;&gt; <span class="number">1</span>);   <span class="comment">// 2147483647</span></span><br></pre></td></tr></table></figure><h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><p><strong>原码</strong>，利用二进制中的第一位来表示符号位，<code>0</code>表示正数，<code>1</code>表示负数。</p><p><strong>反码</strong>，正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。</p><p><strong>补码</strong>，补码是为了解决反码的问题，<strong>正数的补码和原码、反码一样</strong>，<strong>负数的补码就是反码<code>+1</code></strong>。</p><table><thead><tr><th>十进制</th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td>2</td><td>0000 0010</td><td>0000 0010</td><td>0000 0010</td></tr><tr><td>-2</td><td>1000 0010</td><td>1111 1101</td><td>1111 1110</td></tr></tbody></table><p>计算机在进行运算时是不会去管符号位的，计算时用到的时补码，让符号位也参与运算，最后将运算得到的结果再转换成源码即可。</p><h3 id="负数位移运算"><a href="#负数位移运算" class="headerlink" title="负数位移运算"></a>负数位移运算</h3><p>-2用原码表示为<code>10000000 00000000 00000000 00000010</code></p><p>-2用反码表示为<code>11111111 11111111 11111111 11111101</code></p><p>-2用补码表示为<code>11111111 11111111 11111111 11111110</code></p><p><code>-2 &lt;&lt; 1</code>，表示<code>-2</code>的补码左移一位后为<code>11111111 11111111 11111111 11111100</code>，该补码对应的反码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111111 11111100</span><br><span class="line">- 1</span><br><span class="line">= 11111111 11111111 11111111 11111011</span><br></pre></td></tr></table></figure><p>该反码对应的原码为：符号位不变，其他位取反，为<code>10000000 00000000 00000000 00000100</code>，表示-4。所以<code>-2 &lt;&lt; 1 = -4</code>。</p><p><code>-2 &gt;&gt; 1</code>，表示<code>-2</code>的补码右移一位后（高位补1）为<code>11111111 11111111 11111111 11111111</code>，该补码对应的反码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111111 11111111</span><br><span class="line">- 1</span><br><span class="line">= 11111111 11111111 11111111 11111110</span><br></pre></td></tr></table></figure><p>该反码对应的原码为：符号位不变，其他位取反，为<code>10000000 00000000 00000000 00000001</code>，表示-1。所以<code>-2 &gt;&gt; 1 = -1</code>。</p><h3 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h3><p>在<strong>对补码进行移动时，符号位是固定不动的</strong>，而无符号右移是指在进行移动时，<strong>符号位也会跟着一起移动</strong>。比如<code>-2 &gt;&gt;&gt; 1</code>。</p><p>-2用原码表示为<code>10000000 00000000 00000000 00000010</code></p><p>-2用反码表示为<code>11111111 11111111 11111111 11111101</code></p><p>-2用补码表示为<code>11111111 11111111 11111111 11111110</code></p><p>-2的补码右移1位为：<code>01111111 11111111 11111111 11111111</code></p><p>右移后的补码对应的反码、原码为：<code>01111111 11111111 11111111 11111111</code> ，因为现在的符号位为0表示正数，正数的原、反、补码都相同，所以<code>-2 &gt;&gt;&gt; 1 = 2147483647</code></p><h4 id="（取反运算）"><a href="#（取反运算）" class="headerlink" title="~（取反运算）"></a>~（取反运算）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>：    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span></span><br><span class="line">~<span class="number">5</span>：   <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span> <span class="comment">// 补码形式</span></span><br><span class="line">       <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111001</span> <span class="comment">// 反码</span></span><br><span class="line">       <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000110</span> <span class="comment">// 原码</span></span><br></pre></td></tr></table></figure><h3 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h3><h5 id="交换内容"><a href="#交换内容" class="headerlink" title="交换内容"></a>交换内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &amp; <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="求平均数"><a href="#求平均数" class="headerlink" title="求平均数"></a>求平均数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; y) + ((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取大于等于i的最接近的2的幂"><a href="#获取大于等于i的最接近的2的幂" class="headerlink" title="获取大于等于i的最接近的2的幂"></a>获取大于等于<code>i</code>的最接近的<code>2</code>的幂</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数据二进制的最高位，低位全部置0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字节、字、位、比特&quot;&gt;&lt;a href=&quot;#字节、字、位、比特&quot; class=&quot;headerlink&quot; title=&quot;字节、字、位、比特&quot;&gt;&lt;/a&gt;字节、字、位、比特&lt;/h3&gt;&lt;p&gt;1位 = 1比特， 1字节 = 8位，1字=2字节， &lt;code&gt;1Byte=8bi
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="位运算" scheme="https://yaoyinglong.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized总结</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Synchronized%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Synchronized总结/</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2020-10-09T07:42:28.007Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="Synchronized" scheme="https://yaoyinglong.github.io/tags/Synchronized/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal原理</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/ThreadLocal%E5%8E%9F%E7%90%86/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/ThreadLocal原理/</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2020-10-09T07:42:04.521Z</updated>
    
    <content type="html"><![CDATA[<p><code>ThreadLocal</code>是一个<strong>线程内部的存储类</strong>，可以在<strong>指定线程内存储数据</strong>，数据存储以后，只有指定线程可以得到存储数据。提供了线程内存储变量的能力，这些变量不同之处在于<strong>每一个线程读取的变量是对应的互相独立的</strong>。</p><p>单看<code>ThreadLocal</code>类的源码其实很简单，对外提供的方法也很少。复杂的点在于内部静态类<code>ThreadLocalMap</code>。<strong>每个线程</strong>持有一个<code>ThreadLocalMap</code>对象，每一个新的线程<code>Thread</code>都会实例化一个<code>ThreadLocalMap</code>并赋值给成员变量<code>threadLocals</code>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>HASH_INCREMENT</code>魔数的选取与<strong>斐波那契散列</strong>有关，用<code>0x61c88647</code>作为魔数累加为每个<code>ThreadLocal</code>分配各自的ID也就是<code>threadLocalHashCode</code>再与<code>2</code>的幂取模，得到的结果分布很均匀。<code>ThreadLocalMap</code>使用的是<strong>线性探测法</strong>，均匀分布的好处在于很快就能探测到下一个临近的可用<code>slot</code>，从而保证效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initialValue</code>和<code>withInitial</code>两个方法是使用的时候用于重写赋初始值。<code>withInitial</code>通过<code>lambda</code>表达式的方式来重写<code>initialValue</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>ThreadLocal</code>的<code>get</code>源码可以看到，数据是存储在<code>ThreadLocalMap</code>中，而具体的<code>ThreadLocalMap</code>实例并不是<code>ThreadLocal</code>保持，而是保持在每个<code>Thread</code>持有的成员变量<code>threadLocals</code>中。不同的<code>Thread</code>持有不同的<code>ThreadLocalMap</code>实例，因此它们是不存在线程竞争。每次线程死亡，所有<code>map</code>中引用到的对象都会随着这个<code>Thread</code>的死亡而被垃圾收集器一起收集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set</code>方法跟上面的<code>setInitialValue</code>差不多。如果当前线程的<code>ThreadLocalMap</code>为空就创建一个新的<code>ThreadLocalMap</code>并赋值给当前线程的成员变量<code>threadLocals</code>，否则<code>set</code>当前值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类为每个<code>Thread</code>都维护了一个<strong>数组<code>table</code></strong>，<code>ThreadLocal</code>确定了一个数组下标，而这个下标就是<code>value</code>存储的对应位置。</p><p>实例化<code>ThreadLocalMap</code>时创建了一个<strong>初始长度</strong>为<code>16</code>的<code>Entry</code>数组，且数组长度始终为<strong><code>2</code>的幂</strong>。与<code>HashMap</code>类似通过<code>hashCode</code>与<code>length</code>位运算确定数组下标。结合此处的构造方法可以理解成每个线程<code>Thread</code>都持有一个<code>Entry</code>型的数组<code>table</code>，而一切的读取过程都是通过操作这个数组<code>table</code>完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p>为了解决内存回收，这里的<code>Entry</code>继承了<code>WeakReference</code>弱引用。<code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<strong><code>ThreadLocal</code>没有外部强引用引用他</strong>，系统<code>gc</code>的时候，该<code>ThreadLocal</code>势必会被回收。</p><p><strong><code>Entry</code>的<code>key</code>是对<code>ThreadLocal</code>的弱引用</strong>，当抛弃掉<code>ThreadLocal</code>对象时，垃圾收集器会忽略这个<code>key</code>的引用而清理掉<code>ThreadLocal</code>对象， 防止了内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i</code>是通过对<code>threadLocalHashCode</code>的取模得到数组的下标，将构建的<code>Entry</code>放到<code>table</code>数组中。并设置<code>threshold</code>。<code>ThreadLocalMap</code>有两个方法用于得到<strong>上一个<code>/</code>下一个</strong>索引，从<code>nextIndex</code>和<code>prevIndex</code>两个方法的实现上来看，<code>Entry</code>数组在程序逻辑上是作为一个<strong>环形</strong>存在的，这也是由于<strong><code>ThreadLocalMap</code>是使用线性探测法来解决散列冲突</strong>。</p><p><strong>线性探测法</strong>：往哈希表中插入数据时，通过哈希函数计算该值的哈希地址，若发现该位置已有数据，则找紧跟着的下一个位置，若无数据则插入，若有数据则继续探测下一个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getEntry</code>方法在<code>ThreadLocal</code>中的<code>get</code>方法中被调用，首先从<code>ThreadLocal</code>的<strong>直接索引位置</strong>获取<code>Entry e</code>，若<strong><code>e</code>不为<code>null</code>并且<code>key</code>相同</strong>则返回<code>e</code>，若<code>e</code>为<code>null</code>直接返回<code>null</code>，若<strong><code>e</code>不为<code>null</code>且<code>key</code>不一致</strong>则向<strong>下一个位置查询</strong>，如果下一个位置的<code>key</code>和当前需要查询的<code>key</code>相等，则返回对应的<code>Entry</code>，否则若<code>key</code>值为<code>null</code>，则<strong>擦除该位置的<code>Entry</code></strong>，返回<code>null</code>，否则继续向下一个位置查询，直到<code>e</code>为<code>null</code>还没有找到对应的<code>Entry</code>则返回<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于使用的是线性探索，往后还可能找到目标Entry</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>Entry</code>的<code>key</code>为空时通过<code>expungeStaleEntry</code>方法<strong>擦除该位置的<code>Entry</code></strong>。防止该<code>Entry</code>的<code>value</code>被一直强引用从而导致内存泄露。<code>ThreadLocal</code>引用示意图如下，实线表示强引用，虚线表示弱引用</p><p><img src="../../../../../images/Java/ThreadLocal引用示意图.png" alt="ThreadLocal引用示意图"></p><p>从图中可看到，虽然<code>Entry</code>的<code>key</code>是<code>ThreadLocal</code>的弱引用，<code>key</code>在其他地方没有强引用时即会被回收，但是<code>Entry</code>的<code>value</code>会一直被引用，不能得到释放。当然若线程执行结束<code>threadLocal</code>和<code>threadRef</code>会断掉，因此<code>threadLocal</code>、<code>threadLocalMap</code>、<code>entry</code>都会被回收，但实际中为了<strong>线程复用</strong>我们会使用线程池，<code>threadRef</code>可能永远不会断掉，可能导致<code>value</code>永远无法回收。所以这里是直接将<code>table</code>的<code>Entry</code>和<code>Entry</code>的<code>value</code>的引用置空。</p><p><code>for</code>循环是往后环形查找，直到遇到<code>table[i] == null</code>时结束，<code>k == null</code>表示再次遇到脏<code>Entry</code>同样将其清理掉。<code>k != null</code>且<code>h != i</code>表示处理<code>rehash</code>的情况，将起挪到<strong><code>hash</code>表</strong>下标为<code>h</code>开始的第一个为空的位置。</p><p>注：脏<code>Entry</code>仅仅是<code>key</code>为<code>null</code>，而不是通过<strong><code>table[i]</code></strong>获取的<code>Entry</code>为空。这也是为什么遇到<code>tab[i] == null</code>就退出搜索了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 对于还没有被回收的情况，需要做一次rehash。</span></span><br><span class="line"><span class="comment">             * 如果对应的ThreadLocal的ID对len取模出来的索引h不为当前位置i，</span></span><br><span class="line"><span class="comment">             * 则从h向后线性探测到第一个空的slot，把当前的entry给挪过去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * ThreadLocalMap因为使用了弱引用，所以其实每个slot的状态有三种也即</span></span><br><span class="line"><span class="comment">                 * 有效（value未回收），无效（value已回收），空（entry==null）。</span></span><br><span class="line"><span class="comment">                 * 正是因为ThreadLocalMap的entry有三种状态，所以不能完全套高德纳原书的R算法。</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 因为expungeStaleEntry函数在扫描过程中还会对无效slot清理将之转为空slot，</span></span><br><span class="line"><span class="comment">                 * 如果直接套用R算法，可能会出现具有相同哈希值的entry之间断开（中间有空entry）。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若当前<code>table[i] != null</code>说明<code>hash</code>冲突就<strong>需要向后环形查找</strong>，若查找过程中遇到脏<code>entry</code>就通过<code>replaceStaleEntry</code>进行处理；若当前<code>table[i] == null</code>说明新的<code>entry</code>可以直接插入，但是插入后会调用<code>cleanSomeSlots</code>方法<strong>检测并清除脏<code>entry</code></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换失效的entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>replaceStaleEntry</code>并不仅仅局限于处理当前已知的<strong>脏<code>Entry</code></strong>，首先通过<code>for</code>循环<strong>向前</strong>找到<strong>第一个</strong>脏<code>Entry</code>，这里的第一个是指向前查找遇到的最靠近<code>table[i] == null</code>的<code>Entry</code>，它认为在出现脏<code>Entry</code>的<strong>相邻位置</strong>也有很<strong>大概率</strong>出现脏<code>Entry</code>，为了一次处理到位，就需要向前环形搜索，找到前面的脏<code>Entry</code>。</p><p>根据向前搜索中是否有脏Entry以及在for循环向后环形查找中是否找到可覆盖的Entry，，最后使用<code>cleanSomeSlots</code>方法从<code>slotToExpunge</code>为起点开始进行清理脏<code>Entry</code>，可分四种情况：</p><ul><li>前向<code>有</code>脏<code>Entry</code>，向后环形查找<strong>找到</strong>可覆盖的<code>Entry</code></li></ul><p><img src="../../../../../images/Java/环形查找情况1.png" alt></p><ul><li>前向<strong>有</strong>脏<code>Entry</code>，向后环形查找<strong>未找到</strong>可覆盖的<code>Entry</code></li></ul><p><img src="../../../../../images/Java/环形查找情况2.png" alt></p><ul><li>前向<strong>无</strong>脏<code>Entry</code>，向后环形查找<strong>找到</strong>可覆盖的<code>Entry</code></li></ul><p><img src="../../../../../images/Java/环形查找情况3.png" alt></p><ul><li>前向<strong>无</strong>脏<code>Entry</code>，向后环形查找<strong>未找到</strong>可覆盖的<code>Entry</code></li></ul><p><img src="../../../../../images/Java/环形查找情况4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前扫描，查找最前的一个无效slot</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向后遍历table</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果在整个扫描过程中（包括函数一开始的向前扫描与i之前的向后扫描）</span></span><br><span class="line"><span class="comment">             * 找到了之前的无效slot则以那个位置作为清理的起点，否则以当前的i作为清理起点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 从slotToExpunge开始做一次连续段的清理，再做一次启发式清理</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key在table中不存在，则在原地放一个即可</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在探测过程中如果发现任何无效slot，则做一次清理（连续段清理+启发式清理）</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>n</code>主要用于<strong>扫描次数控制</strong>，若没有遇到脏<code>Entry</code>，整个扫描过程持续<code>log2(n)</code>次，若遇到脏<code>Entry</code>将<code>n</code>重置为当前hash表的长度，再扫描<code>log2(n)</code>次，注意这里的<code>nextIndex</code>获取的数组下标是一个环。遇到脏<code>Entry</code>时通过<code>expungeStaleEntry</code>清理脏<code>Entry</code>。</p><p><img src="../../../../../images/Java/cleanSomeSlots执行情景图.png" alt="cleanSomeSlots执行情景图"></p><p>若当前<code>n</code>等于<code>hash</code>表的<code>size</code>即<code>n=10</code>，<code>i=1</code>,在第一趟搜索过程中通过<code>nextIndex</code>，<code>i</code>指向索引为<code>2</code>的位置，此时<code>table[2]</code>为<code>null</code>，则第一趟未发现脏<code>Entry</code>，进行第二趟搜索。</p><p>第二趟搜索先通过<code>nextIndex</code>方法，<code>table[3] != null</code>找到脏Entry，<strong>先将<code>n</code>置为哈希表的长度<code>len</code>，然后继续调用<code>expungeStaleEntry</code>方法</strong>，将当前索引为<code>3</code>的脏<code>Entry</code>给清除掉，令<code>value</code>为<code>null</code>且<code>table[3]</code>为<code>null</code>，但<strong>该方法会继续往后环形搜索</strong>，往后发现索引<code>4、5</code>的位置的<code>Entry</code>同样为脏<code>Entry</code>，索引<code>6</code>的<code>Entry</code>不是脏<code>Entry</code>保持不变，直至<code>i=7</code>时此处<code>table[7]</code>为<code>null</code>，返回索引<code>7</code>。</p><p>继续向后环形搜索，直到在整个搜索范围里都未发现脏<code>Entry</code>，<code>cleanSomeSlot</code>方法执行结束退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启发式地清理slot</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 扩大扫描控制因子</span></span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 清理一个连续段</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用set方法时发现需要扩容时，会调用<code>rehash</code>方法对<code>table</code>进行扩容。扩容前回先清理掉hash表中所有的脏<code>Entry</code>，然后在进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做一次全量清理</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 因为做了一次清理，所以size很可能会变小。</span></span><br><span class="line"><span class="comment">     * ThreadLocalMap这里的实现是调低阈值来判断是否需要扩容，</span></span><br><span class="line"><span class="comment">     * threshold默认为len*2/3，所以这里的threshold - threshold / 4相当于len/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 线性探测来存放Entry</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>threadLocal.remove</code>方法时候，实际上会调用<code>threadLocalMap</code>的<code>remove</code>方法，当遇到了<code>key</code>为<code>null</code>的脏<code>entry</code>的时候，也会调用<code>expungeStaleEntry</code>清理掉脏<code>entry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>threadLocal</code>的<strong>生命周期</strong>里，针对<code>threadLocal</code>存在的<strong>内存泄漏</strong>的问题，都会通过<code>expungeStaleEntry</code>，<code>cleanSomeSlots</code>,<code>replaceStaleEntry</code>这三个方法清理掉<code>key</code>为<code>null</code>的脏<code>entry</code>。</p><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InheritableThreadLocal</code>提供了一种<strong>父子</strong>线程之间的<strong>数据共享机制</strong>，在线程初始化<code>init</code>时，会调用<code>ThreadLocal</code>的<code>createInheritedMap</code>从父线程的<code>inheritableThreadLocals</code>中把<strong>有效的<code>entry</code></strong>都拷过来。<code>InheritableThreadLocal</code>只是在<strong>子线程创建时</strong>会去拷一份父线程的<code>inheritableThreadLocals</code>。若父线程是在子线程创建后再<code>set</code>某个<code>InheritableThreadLocal</code>对象的值，对子线程是<strong>不可见</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在使用<code>ThreadLocal</code>时很可能出现<strong>数据错乱</strong>，这是由于通过线程池时，<strong>线程池对线程进行了复用</strong>，从而导致<code>ThreadLocal</code>中的数据串了。<strong>用完及时清理数据</strong>。在<code>Web</code>环境中可以自定义<code>HandlerInterceptorAdapter</code>，在<code>preHandler</code>中去设置<code>ThreadLocal</code>，在<code>afterCompletion</code>时区<code>remove</code>。</p><h4 id="重写initialValue方法"><a href="#重写initialValue方法" class="headerlink" title="重写initialValue方法"></a>重写initialValue方法</h4><p>重写<code>initialValue</code>赋初值方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = ThreadLocal.withInitial(() -&gt; Thread.currentThread().getId());</span><br></pre></td></tr></table></figure><h4 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h4><p><code>MDC</code>主要是用于将某个或某些所有日志中都需要打印的字符串设置于<code>MDC</code>中，这样就不需要每次打印日志时专门写出来，这里也是通过<code>ThreadLocal</code>来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MDCAdapter mdcAdapter;</span><br><span class="line">mdcAdapter.put(key, val);</span><br><span class="line">mdcAdapter.get(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jMDCAdapter</span> <span class="keyword">implements</span> <span class="title">MDCAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Log4jMDCAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String val)</span> </span>&#123;</span><br><span class="line">        ThreadContext.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>DefaultThreadContextMap</code>可以看到<code>localMap</code>其实就是一个<code>ThreadLocal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadContextMap contextMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        contextMap.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadContextMap</span> <span class="keyword">implements</span> <span class="title">ThreadContextMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INHERITABLE_MAP = <span class="string">"isThreadContextMapInheritable"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; localMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadContextMap</span><span class="params">(<span class="keyword">boolean</span> useMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.useMap = useMap;</span><br><span class="line">        <span class="keyword">this</span>.localMap = createThreadLocalMap(useMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; createThreadLocalMap(<span class="keyword">final</span> <span class="keyword">boolean</span> isMapEnabled) &#123;</span><br><span class="line">        PropertiesUtil managerProps = PropertiesUtil.getProperties();</span><br><span class="line">        <span class="keyword">boolean</span> inheritable = managerProps.getBooleanProperty(<span class="string">"isThreadContextMapInheritable"</span>);</span><br><span class="line">        <span class="keyword">return</span> (ThreadLocal)(inheritable ? <span class="keyword">new</span> InheritableThreadLocal&lt;Map&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Map&lt;String, String&gt; <span class="title">childValue</span><span class="params">(Map&lt;String, String&gt; parentValue)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> parentValue != <span class="keyword">null</span> &amp;&amp; isMapEnabled ? Collections.unmodifiableMap(<span class="keyword">new</span> HashMap(parentValue)) : <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; : <span class="keyword">new</span> ThreadLocal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.useMap) &#123;</span><br><span class="line">            Map&lt;String, String&gt; map = (Map)<span class="keyword">this</span>.localMap.get();</span><br><span class="line">            Map&lt;String, String&gt; map = map == <span class="keyword">null</span> ? <span class="keyword">new</span> HashMap() : <span class="keyword">new</span> HashMap(map);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">this</span>.localMap.set(Collections.unmodifiableMap(map));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据库连接、-Session-管理"><a href="#数据库连接、-Session-管理" class="headerlink" title="数据库连接、 Session 管理"></a>数据库连接、 Session 管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用ThreadLocal代替锁"><a href="#使用ThreadLocal代替锁" class="headerlink" title="使用ThreadLocal代替锁"></a>使用ThreadLocal代替锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HashSet&lt;Val&lt;Integer&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addSet</span><span class="params">(Val&lt;Integer&gt; val)</span> </span>&#123;</span><br><span class="line">    set.add(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Val&lt;Integer&gt;&gt; c = <span class="keyword">new</span> ThreadLocal&lt;Val&lt;Integer&gt;&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Val&lt;Integer&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Val&lt;Integer&gt; v = <span class="keyword">new</span> Val&lt;Integer&gt;();</span><br><span class="line">        v.set(<span class="number">0</span>);</span><br><span class="line">        addSet(v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 统计结果</span></span><br><span class="line">set.stream().map(Val::get).reduce((a, sum) -&gt; a + sum).get()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Val</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自实现"><a href="#自实现" class="headerlink" title="自实现"></a>自实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger atomic = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadLocalHash = atomic.addAndGet(<span class="number">0x61c88647</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;Thread, HashMap&lt;Integer, Object&gt;&gt; threadLocalHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> HashMap&lt;Integer, Object&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (!threadLocalHashMap.containsKey(thread)) &#123;</span><br><span class="line">            threadLocalHashMap.put(thread, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocalHashMap.get(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Object&gt; map = getMap ();</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(<span class="keyword">this</span>.threadLocalHash)) &#123;</span><br><span class="line">            map.put(<span class="keyword">this</span>.threadLocalHash, initialValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) map.get(<span class="keyword">this</span>.threadLocalHash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Object&gt; map = getMap ();</span><br><span class="line">        map.put(<span class="keyword">this</span>.threadLocalHash, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与Synchronized的区别"><a href="#与Synchronized的区别" class="headerlink" title="与Synchronized的区别"></a>与Synchronized的区别</h3><p>相同：都是为了解决多线程中相同变量的访问冲突问题，</p><p>不同：<code>Synchronized</code>同步机制是通过以<strong>时间换空间</strong>的方式控制线程访问共享对象的顺序，而<code>threadLocal</code>是以<strong>空间换时间</strong>为每一个线程分配一个该对象各用各的互不影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;是一个&lt;strong&gt;线程内部的存储类&lt;/strong&gt;，可以在&lt;strong&gt;指定线程内存储数据&lt;/strong&gt;，数据存储以后，只有指定线程可以得到存储数据。提供了线程内存储变量的能力，这些变量不同之处在于&lt;strong&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ThreadLocal" scheme="https://yaoyinglong.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概览</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/设计模式概览/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-08-25T08:44:58.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p><code>23</code>种设计模式大体上可以分为三类：</p><ul><li><strong>创建型模式</strong>（<code>5</code>个）：对象实例化的模式，用于<strong>解耦对象的实例化过程</strong>；</li><li><strong>结构型模式</strong>（<code>7</code>个）：把类或对象结合在一起<strong>形成一个更大的结构</strong>；</li><li><strong>行为型模式</strong>（<code>11</code>个）：类和对象<strong>如何交互</strong>，及<strong>划分职责和算法</strong>；</li></ul><p><img src="../../../../images/设计模式/设计模式分类.png" alt="设计模式分类"></p><h3 id="各种模式的关键点"><a href="#各种模式的关键点" class="headerlink" title="各种模式的关键点"></a>各种模式的关键点</h3><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><p><strong>单例模式</strong>：某个类只能有一个实例，提供一个全局的访问点。</p><p><strong>简单工厂</strong>：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</p><p><strong>工厂方法</strong>：定义一个创建对象的接口，让子类决定实例化那个类。</p><p><strong>抽象工厂</strong>：创建相关或依赖对象的家族，而无需明确指定具体类。</p><p><strong>建造者模式</strong>：封装一个复杂对象的构建过程，并可以按步骤构造。</p><p><strong>原型模式</strong>：通过复制现有的实例来创建新的实例。</p><h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><p><strong>适配器模式</strong>：将一个类的方法接口转换成客户希望的另外一个接口。</p><p><strong>组合模式</strong>：将对象组合成树形结构以表示“”部分-整体“”的层次结构。</p><p><strong>装饰模式</strong>：动态的给对象添加新的功能。</p><p><strong>代理模式</strong>：为其他对象提供一个代理以便控制这个对象的访问。</p><p><strong>亨元模式</strong>：通过共享技术来有效的支持大量细粒度的对象。</p><p><strong>外观模式</strong>：对外提供一个统一的方法，来访问子系统中的一群接口。</p><p><strong>桥接模式</strong>：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</p><h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><p><strong>模板模式</strong>：定义一个算法结构，而将一些步骤延迟到子类实现。</p><p><strong>解释器模式</strong>：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</p><p><strong>策略模式</strong>：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</p><p><strong>状态模式</strong>：允许一个对象在其对象内部状态改变时改变它的行为。</p><p><strong>观察者模式</strong>：对象间的一对多的依赖关系。</p><p><strong>备忘录模式</strong>：在不破坏封装的前提下，保持对象的内部状态。</p><p><strong>中介者模式</strong>：用一个中介对象来封装一系列的对象交互。</p><p><strong>命令模式</strong>：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</p><p><strong>访问者模式</strong>：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</p><p><strong>责任链模式</strong>：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</p><p><strong>迭代器模式</strong>：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</p><h3 id="23种设计模式间的关系"><a href="#23种设计模式间的关系" class="headerlink" title="23种设计模式间的关系"></a>23种设计模式间的关系</h3><p><img src="../../../../images/设计模式/23种设计模式关系图.png" alt="23种设计模式关系图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设计模式分类&quot;&gt;&lt;a href=&quot;#设计模式分类&quot; class=&quot;headerlink&quot; title=&quot;设计模式分类&quot;&gt;&lt;/a&gt;设计模式分类&lt;/h3&gt;&lt;p&gt;&lt;code&gt;23&lt;/code&gt;种设计模式大体上可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/MySQL基础/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-08-25T09:25:46.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务基本特征ACID"><a href="#事务基本特征ACID" class="headerlink" title="事务基本特征ACID"></a>事务基本特征ACID</h3><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事务基本特征ACID&quot;&gt;&lt;a href=&quot;#事务基本特征ACID&quot; class=&quot;headerlink&quot; title=&quot;事务基本特征ACID&quot;&gt;&lt;/a&gt;事务基本特征ACID&lt;/h3&gt;&lt;h3 id=&quot;四种隔离级别&quot;&gt;&lt;a href=&quot;#四种隔离级别&quot; class=&quot;
      
    
    </summary>
    
      <category term="DB" scheme="https://yaoyinglong.github.io/categories/DB/"/>
    
    
      <category term="MySQL" scheme="https://yaoyinglong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JVM整体概览</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/JVM%E6%95%B4%E4%BD%93%E6%A6%82%E8%A7%88/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/JVM整体概览/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-08-25T10:18:18.327Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../images/JVM/JVM整体概览.png" alt="JVM整体概览"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../../../images/JVM/JVM整体概览.png&quot; alt=&quot;JVM整体概览&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://yaoyinglong.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring知识点</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/Spring/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/Spring/Spring知识点/</id>
    <published>2020-08-23T16:00:00.000Z</published>
    <updated>2020-08-24T12:54:23.929Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../images/Spring/Spring知识点概览.png" alt="Spring知识点概览"></p><p><img src="../../../../images/Spring/Spring知识点详情.png" alt="Spring知识点详情"></p><p><img src="../../../../images/Spring/Spring生命周期.png" alt="Spring生命周期"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../../../images/Spring/Spring知识点概览.png&quot; alt=&quot;Spring知识点概览&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../images/Spring/Spring知识点详情.png&quot; alt=&quot;
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>IoC容器</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/Spring/IoC%E5%AE%B9%E5%99%A8/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/Spring/IoC容器/</id>
    <published>2020-08-15T16:00:00.000Z</published>
    <updated>2020-08-18T14:02:41.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IoC容器概述"><a href="#IoC容器概述" class="headerlink" title="IoC容器概述"></a>IoC容器概述</h3><p><strong>依赖反转</strong>的概念：<strong>依赖对象的获得被反转了</strong>，基于该结论为控制反转创造了一个更好听的名字：<strong>依赖注入</strong>。依赖控制反转的实现方式有很多种，<code>Spring</code>中<code>IoC</code>容器是实现该模式的载体，它可以在<strong>对象生成</strong>或<strong>初始化</strong>时<strong>直接将数据注入到对象中</strong>，也可以通过将<strong>对象引用注入到对象数据域中</strong>的方式来注入对方法调用的依赖。这种<strong>依赖注入是可以递归的，对象被逐层注入</strong>。</p><p>应用控制反转后，当对象被创建时，由<strong>一个调用系统内的所有对象的外界实体将其所依赖的对象的引用传递给它</strong>，控制反转是关于<strong>一个对象如何获取它所依赖的对象的引用</strong>，<strong>反转指的是责任的反转</strong>。</p><p>通过使用<code>IoC</code>容器，对象的<strong>依赖关系的管理被反转了</strong>或者说是把<strong>资源的获取方式反转了</strong>，对象之间的相互依赖关系由<code>IoC</code>容器进行管理，并由<code>IoC</code>容器完成对象的注入。注入的主要实现方式有：<strong>接口注入</strong>、<strong><code>setter</code>注入</strong>、<strong>构造器注入</strong>。<code>Spring</code>中<code>setter</code>注入和构造器注入是主要的注入方式，使用<code>Spring</code>时<code>setter</code>注入是常见的注入方式。且<code>Spring</code>还提<strong>供了对特定依赖的检查</strong>。</p><p><code>Spring IoC</code>提供了一个基本的<code>JavaBean</code>容器，通过<code>IoC</code>容器管理依赖关系，并通过依赖注入和<code>AOP</code>切面增强了为<code>JavaBean</code>这样的<code>POJO</code>对象赋予事务管理、生命周期管理等基本功能。</p><h3 id="IoC容器的设计与实现"><a href="#IoC容器的设计与实现" class="headerlink" title="IoC容器的设计与实现"></a>IoC容器的设计与实现</h3><p><code>Spring IoC</code>容器的设计中，实现了<code>BeanFactory</code>接口的<strong>简单容器系列</strong>，该系列容器只实现了容器的<strong>最基本的功能</strong>；和<strong>容器的高级形态<code>ApplicationContext</code>应用上下文</strong>，两个主要的容器系列。<code>BeanFactory</code>是<code>IoC</code>容器具体实现的<strong>基本功能规范的设计表现</strong>。</p><p>对于使用者来说，可将<code>BeanFactory</code>和<code>ApplicationContext</code>看成容器的具体表现形式。通常所说的IoC容器实际上代表的是一系列功能各异的容器产品。Spring中有各种各样的<code>IoC</code>容器的实现。</p><p>在Spring提供的基本的<code>IoC</code>容器的接口定义和实现的基础上，Spring通过定义<code>BeanDefinition</code>来管理基本的Spring的应用中的<strong>各种对象以及它们之间的相互依赖关系</strong>。<strong><code>BeanDefinition</code>抽象了对Bean的定义</strong>，<strong>是让容器起作用的主要数据类型</strong>。对于<code>IoC</code>容器来说，<code>BeanDefinition</code>就是对<strong>依赖反转模式</strong>中管理的<strong>对象依赖关系的数据抽象</strong>，也是容器<strong>实现依赖反转功能的核心数据结构</strong>，<strong>依赖反转功能都是围绕对<code>BeanDefinition</code>的处理来完成</strong>的。</p><p><img src="../../../../../images/Spring/IoC容器接口设计图.png" alt="IoC容器接口设计图"></p><p><code>BeanFactory</code>接口定义了基本的<code>IoC</code>容器规范，从接口<code>BeanFactory</code>到<code>HierarchicalBeanFactory</code>再到<code>ConfigurableBeanFactory</code>是一条<strong>主要</strong>的<code>BeanFactory</code>设计路径。<code>HierarchicalBeanFactory</code>接口增加了<code>getParentBeanFactory()</code>的接口功能，使<code>BeanFactory</code>具备了<strong>双亲<code>IoC</code>容器的管理功能</strong>。<code>ConfigurableBeanFactory</code>接口主要定义了一些对<code>BeanFactory</code>的<strong>配置功能</strong>。可<strong>设置双亲<code>IoC</code>容器</strong>，<strong>配置<code>Bean</code>后置处理器</strong>等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;IoC容器概述&quot;&gt;&lt;a href=&quot;#IoC容器概述&quot; class=&quot;headerlink&quot; title=&quot;IoC容器概述&quot;&gt;&lt;/a&gt;IoC容器概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;依赖反转&lt;/strong&gt;的概念：&lt;strong&gt;依赖对象的获得被反转了&lt;/stro
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
      <category term="IoC" scheme="https://yaoyinglong.github.io/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>Spring整体架构</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/Spring/Spring整体架构/</id>
    <published>2020-08-11T16:00:00.000Z</published>
    <updated>2020-08-13T14:12:06.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring子项目"><a href="#Spring子项目" class="headerlink" title="Spring子项目"></a>Spring子项目</h3><h4 id="Spring-Framework（core）"><a href="#Spring-Framework（core）" class="headerlink" title="Spring Framework（core）"></a>Spring Framework（core）</h4><p>包含一系列<code>Ioc</code>容器的设计，提供了<strong>依赖反转</strong>的实现，集成了<code>AOP</code>，还包含了<code>MVC</code>、<code>JDBC</code>、<strong>事务处理</strong>模块的实现。</p><h4 id="Spring-Web-Flow"><a href="#Spring-Web-Flow" class="headerlink" title="Spring Web Flow"></a>Spring Web Flow</h4><p><strong>定义了一种特定的语言来描述工作流</strong>，同时高级的工作流控制引擎可以管理会话状态，支持<code>AJAX</code>来构建丰富的客户端体验，并提供<code>JSF</code>支持。其实际上是构建在<code>Spring MVC</code>的基础上的，相对于<code>Spring Framework（core）</code>独立发展的。</p><h4 id="Spring-BlazeDS-Integration"><a href="#Spring-BlazeDS-Integration" class="headerlink" title="Spring BlazeDS Integration"></a>Spring BlazeDS Integration</h4><p>提供<code>Spring</code>于<code>Adobe Flex</code>技术集成的模块。</p><h4 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h4><p>基于<code>Spring</code>的<strong>认证</strong>和<strong>安全工具</strong>。</p><h4 id="Spring-Security-OAuth"><a href="#Spring-Security-OAuth" class="headerlink" title="Spring Security OAuth"></a>Spring Security OAuth</h4><p>为OAuth在Spring上集成提供支持，OAuth是一个第三方模块，提供一个开放协议的实现，通过改协议，前端桌面应用可以对Web应用进行简单而标准的安全调用。</p><h4 id="Spring-Dynamic-Modules"><a href="#Spring-Dynamic-Modules" class="headerlink" title="Spring Dynamic Modules"></a>Spring Dynamic Modules</h4><p>可以让Spring运行在OSGi平台上。</p><h4 id="Spring-Batch"><a href="#Spring-Batch" class="headerlink" title="Spring Batch"></a>Spring Batch</h4><p>提供构建<strong>批处理应用</strong>和<strong>自动化操作</strong>的框架。</p><h4 id="Spring-Integration"><a href="#Spring-Integration" class="headerlink" title="Spring Integration"></a>Spring Integration</h4><p>为企业数据集成提供了各种适配器，通过这些适配器来转换各种消息格式，并帮助Spring应用完成与企业应用系统的集成。</p><h4 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h4><p>为Spring应用更好地使用基于AMQP（高级消息队列协议）的消息服务而开发。</p><h4 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h4><p>为Spring应用提供使用费关系型数据的能力。</p><h3 id="Spring设计目标"><a href="#Spring设计目标" class="headerlink" title="Spring设计目标"></a>Spring设计目标</h3><p>​    为开发者提供的是一个<strong>一站式的轻量级应用开发框架</strong>。其抽象了许多应用开发中遇到的共性问题。支持<code>POJO</code>和使用<code>JavaBean</code>的开发方式，使应用<strong>面向接口开发</strong>，充分支持<code>OO</code>（面向对象）的设计方法，使<strong>开发的入门</strong>、<strong>测试</strong>、<strong>应用部署都得到简化</strong>。</p><p>​    通过使用<code>Spring</code>的<code>IoC</code>容器，可以对应用开发中复杂的对象耦合关系实现一个<strong>文本化</strong>、<strong>外部化</strong>的工作，即通过一个或几个<code>XML</code>文件，可以方便地对应用的耦合关系进行浏览、修改和维护，很大程度上简化应用开发。通过<code>Ioc</code>容器实现的依赖反转，把<strong>依赖关系的管理从<code>Java</code>对象中解放出来</strong>，交给IoC容器来完成，从而完成了对象之间的解耦，将原来的<strong>对象—对象</strong>的关系，转化为<strong>对象—IoC容器—对象</strong>的关系。</p><p>​    Spring即作为用户和机器之间的平台，同时也为用户使用底层的机器资源提供了应用开发环境。Spring关系的是一些企业应用资源的使用，如数据持久化、数据集成、事务管理、消息中间件、Web2.0应用、分布式计算等对高效可靠处理企业数据方法的技术抽象。</p><p>​    Spring一方面通过IoC容器来管理POJO对象，以及它们相互之间的耦合关系，使企业的信息、数据、资源可以用简单得Java语言来抽象和描述；另一方面可通过AOP以动态和非侵入式的方式来增强服务的功能。</p><p>​    IoC容器和AOP模块是平台实现的核心，代表了最为基础的底层抽象，同时也是Spring其他模块实现的基础。</p><h3 id="Spring整体架构"><a href="#Spring整体架构" class="headerlink" title="Spring整体架构"></a>Spring整体架构</h3><h4 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h4><p>​    包含了最基本的<code>IoC</code>容器<code>BeanFactory</code>接口的实现，也提供了一系列这个接口的实现。如：<code>XmlBeanFactory</code>、<code>SimpleJndiBeanFactory</code>、<code>StaticListableBeanFactory</code>等，为了让应用更方便得使用<code>IoC</code>容器，还在<code>IoC</code>容器的外围提供如<code>Resource</code>访问资源的抽象和定位等支持。<code>Spring</code>还设计了<code>IoC</code>容器的高级形态<code>ApplicationContext</code>应用上下文提供用户使用。</p><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>​    Spring核心模块，围绕AOP增强功能，Spring集成了AspectJ作为AOP的一个特定实现，还在JVM动态代理/CGLIB的基础上实现了一个AOP框架。</p><h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><p>​    以DispatcherServlet为核心的模块，实现了MVC模式，包括怎样与Web容器环境集成、Web请求的拦截、分发、处理、和ModelAndView数据的返回，以及如何集成各种UI视图展现和数据表现。</p><h4 id="Spring-JDBC-ORM"><a href="#Spring-JDBC-ORM" class="headerlink" title="Spring JDBC/ORM"></a>Spring JDBC/ORM</h4><p>​    Spring JDBC包提供了JdbcTemplate作为模板类，封装了基本的数据库操作方法，如数据查询、更新等。</p><p>​    Spring还提供许多对ORM工具的封装。如Hibernate、iBatis等。可以把对这些工具的使用和Spring声明式事务处理结合起来。同时Spring还提供许多模板对象，如HibernateTemplate来实现对Hibernate的驱动。</p><h4 id="Spring事务处理"><a href="#Spring事务处理" class="headerlink" title="Spring事务处理"></a>Spring事务处理</h4><p>​    Spring事务处理是一个通过Spring AOP实现的自身功能增强的典型模块。通过AOP增强实现了声明式事务处理的功能，使应用只需要在IoC容器中对事务属性进行配置即可完成，同时这些事务处理的基本过程和具体的事务处理器实现是无关的，应用可以选择不同的具体的事务处理机制，使用了声明式事务处理，这些具体的事务处理机制会被纳入Spring事务处理的统一框架中完成，并完成与具体业务代码的解耦。</p><h4 id="Spring远端调用"><a href="#Spring远端调用" class="headerlink" title="Spring远端调用"></a>Spring远端调用</h4><p>​    通过Spring的封装，为应用屏蔽了各种通信和调用细节的实现，通过这一层的封装，使应用可以通过选择各种不同的远端调用来实现。如HTTP调用器、第三方二进制同学实现Hessian/Burlap、RMI调用。</p><h3 id="Spring应用场景"><a href="#Spring应用场景" class="headerlink" title="Spring应用场景"></a>Spring应用场景</h3><p>​    在Spring这个一站式应用平台或框架中，其中各个模块除了依赖IoC容器和AOP之外，相互之间没有很强的耦合性；Spring最重目标是简化应用开发的编程模型。其所提供的服务可贯穿应用道整个软件中，从最上层Web UI道底层数据操作，道其他企业信息数据集成，再到各种J2EE服务的使用。</p><p>​    可把Spring作为一个整体使用，也可以把Spring各个模块拿出来单独使用，因其本身是非常模块化的。Spring的价值：</p><ul><li>非侵入性框架，其目标是使应用程序代码对框架的依赖最小化。</li><li>提供了一个一致的编程模型，使应用直接使用POJO开发，从而可以与运行环境隔离开。</li><li>推动应用的设计风格向面向对象及面向接口编程转变，提高代码的重用性和可测性。</li><li>改进了体系结构的选择，Spring可以帮助我们选择不同的技术实现。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring子项目&quot;&gt;&lt;a href=&quot;#Spring子项目&quot; class=&quot;headerlink&quot; title=&quot;Spring子项目&quot;&gt;&lt;/a&gt;Spring子项目&lt;/h3&gt;&lt;h4 id=&quot;Spring-Framework（core）&quot;&gt;&lt;a href=&quot;#Spr
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>时间&amp;空间复杂</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/时间&amp;空间复杂/</id>
    <published>2020-07-31T16:00:00.000Z</published>
    <updated>2020-09-07T01:22:32.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>常见的时间复杂度：<code>O(1)</code>：常数复杂度，<code>O(log n)</code>：对数复杂度，<code>O(n)</code>：线性时间复杂度，<code>O(n^2)</code>：平方，<code>O(n^3)</code>：立方，<code>O(2^n)</code>：指数，<code>O(n!)</code>：阶乘。</p><p><img src="E:\Blog\source\images\算法\时间复杂度曲线.png" alt></p><h5 id="O-log-n"><a href="#O-log-n" class="headerlink" title="O(log n)"></a>O(log n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="O-log-n-1"><a href="#O-log-n-1" class="headerlink" title="O(log n)"></a>O(log n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i *= <span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="O-k-n"><a href="#O-k-n" class="headerlink" title="O(k^n)"></a>O(k^n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n -<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="O-n"><a href="#O-n" class="headerlink" title="O(n!)"></a>O(n!)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h3&gt;&lt;p&gt;常见的时间复杂度：&lt;code&gt;O(1)&lt;/code&gt;：常数复杂度，&lt;code&gt;O(log n)&lt;/code&gt;：对数复
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/二叉搜索树/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2020-08-27T03:35:30.098Z</updated>
    
    <content type="html"><![CDATA[<p><strong>左子树</strong>上所有节点的值<strong>均小于根节点</strong>的值，而<strong>右子树</strong>上所有结点的值<strong>均大于根节点</strong>的值。故二叉搜索树中序遍历是单调递增的。</p><p><strong>插入的序列越接近有序，生成的二叉搜索树就越像一个链表</strong>，为了避免二叉搜索树变成链表，故引入了<strong>平衡二叉树</strong>，即让树的结构看起来尽量均匀，左右子树的节点数尽量一样多。</p><p>生成平衡二叉树时，先按照生成二叉搜索树的方法构造二叉树，再根据插入的导致二叉树不平衡的节点位置进行调整，有<strong><code>LL</code>左旋</strong>、<strong><code>RR</code>右旋</strong>、<strong><code>LR</code>先左旋后右旋</strong>、<strong><code>RL</code>先右旋后左旋</strong>四种调整方式。</p><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer min;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> left = isValidBST(root.left);</span><br><span class="line">    <span class="keyword">if</span> (!left || min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    min = root.val;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBSTDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    Integer min = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.add(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; node.val &lt;= min) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        min = node.val;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树插入"><a href="#二叉搜索树插入" class="headerlink" title="二叉搜索树插入"></a>二叉搜索树插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = insertIntoBST701(root.right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.left = insertIntoBST701(root.left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul><li>若<code>key &gt; root.val</code>，说明要删除的节点在右子树，<code>root.right = deleteNode(root.right, key)</code>。</li><li>若<code>key &lt; root.val</code>，说明要删除的节点在左子树，<code>root.left = deleteNode(root.left, key)</code>。</li><li>若<code>key == root.val</code>，则该节点就是我们要删除的节点，则：<ul><li>若该节点是叶子节点，直接删除：<code>root = null</code>。</li><li>若该节点不是叶子节点且有右节点，则用其<strong>后继节点</strong>值替代<code>root.val = successor.val</code>，然后删除后继节点。</li><li>若该节点不是叶子节点且只有左节点，则用它的<strong>前驱节点</strong>值替代<code>root.val = predecessor.val</code>，然后删除前驱节点。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &gt; root.val) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root.val) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.val = successor(root);</span><br><span class="line">            root.right = deleteNode(root.right, root.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.val = predecessor(root);</span><br><span class="line">            root.left = deleteNode(root.left, root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后继节点</strong>，中序遍历序列的<strong>下一个节点</strong>。即<strong>比当前节点大的最小节点</strong>，先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前驱节点</strong>，中序遍历序列的<strong>前一个节点</strong>。即<strong>比当前节点小的最大节点</strong>，先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将树转换成链表"><a href="#将树转换成链表" class="headerlink" title="将树转换成链表"></a>将树转换成链表</h3><p><code>cursor</code>只是做一个引用传递，不断的将节点的<code>right</code>节点更新，然后将当前游标置为新节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode cursor;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    cursor = ans;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> ans.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">    node.left = <span class="keyword">null</span>;</span><br><span class="line">    cursor.right = node;</span><br><span class="line">    cursor = node;</span><br><span class="line">    inorder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树降序遍历"><a href="#二叉搜索树降序遍历" class="headerlink" title="二叉搜索树降序遍历"></a>二叉搜索树降序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    convertBST(root.right);</span><br><span class="line">    System.out.println(root);</span><br><span class="line">    convertBST(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证 p.val &lt; q.val</span></span><br><span class="line">    <span class="keyword">if</span> (p.val &gt; q.val) &#123;</span><br><span class="line">        TreeNode tmp = p;</span><br><span class="line">        p = q;</span><br><span class="line">        q = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// p,q 都在 root 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val) &#123;</span><br><span class="line">            <span class="comment">// 遍历至右子节点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">            <span class="comment">// p,q 都在 root 的左子树中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="comment">// 遍历至左子节点</span></span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; R) &#123;</span><br><span class="line">        <span class="keyword">return</span> trimBST(root.left, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; L) &#123;</span><br><span class="line">        <span class="keyword">return</span> trimBST(root.right, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    root.left = trimBST(root.left, L, R);</span><br><span class="line">    root.right = trimBST(root.right, L, R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序结果构建树"><a href="#前序结果构建树" class="headerlink" title="前序结果构建树"></a>前序结果构建树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> generateTree(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">generateTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == preorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rootVal = preorder[index];</span><br><span class="line">    <span class="keyword">if</span> (rootVal &gt; upper || rootVal &lt; lower) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    root.left = generateTree(preorder, lower, rootVal);</span><br><span class="line">    root.right = generateTree(preorder, rootVal, upper);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序结果构建树"><a href="#后序结果构建树" class="headerlink" title="后序结果构建树"></a>后序结果构建树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (postorder == <span class="keyword">null</span> || postorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> generateTree(postorder, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">generateTree</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == postorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rootVal = postorder[index];</span><br><span class="line">    <span class="keyword">if</span> (rootVal &gt; upper || rootVal &lt; lower) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    root.right = generateTree(postorder, rootVal, upper);</span><br><span class="line">    root.left = generateTree(postorder, lower, rootVal);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;左子树&lt;/strong&gt;上所有节点的值&lt;strong&gt;均小于根节点&lt;/strong&gt;的值，而&lt;strong&gt;右子树&lt;/strong&gt;上所有结点的值&lt;strong&gt;均大于根节点&lt;/strong&gt;的值。故二叉搜索树中序遍历是单调递增的。&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://yaoyinglong.github.io/tags/%E6%A0%91/"/>
    
      <category term="AVL" scheme="https://yaoyinglong.github.io/tags/AVL/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/平衡二叉树/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2020-09-02T07:04:47.570Z</updated>
    
    <content type="html"><![CDATA[<p>平衡二叉树是一种特殊的<strong>二叉排序树</strong>，<strong>每个</strong>节点<strong>左子树</strong>和<strong>右子树</strong>高度差<strong>至多等于<code>1</code></strong>。</p><p>将二叉树上节点<strong>左子树深度</strong>减去<strong>右子树深度</strong>的值称为<strong>平衡因子<code>BF</code></strong>，平衡二叉树上<strong>所有节点的平衡因子</strong>只可能是<strong>1，-1，0</strong>。</p><p>距离<strong>插入节点最近</strong>且<strong>平衡因子绝对值大于1</strong>的节点<strong>为根的子树</strong>，称为<strong>最小不平衡子树</strong>。</p><p>构建平衡二叉树时，每插入一个节点时，<strong>先检查是否因插入而破坏树的平衡性</strong>，若是则<strong>找出最小不平衡树</strong>，在<strong>保持二叉排序树特性的前提下</strong>，调整最小不平衡子树中各个节点之间的链接关系，<strong>进行相应的旋转</strong>，使之成为新的平衡子树。</p><ul><li><strong>右旋</strong>：最小不平衡子树的BF和它的子树BF符号相同且最小不平衡子树的BF大于0</li><li><strong>左旋</strong>：最小不平衡子树的BF和它的子树BF符号相同且最小不平衡子树的BF小于零</li><li><strong>左右旋</strong>：最小不平衡子树的BF与它的子树的BF符号相反时且最小不平衡子树的BF大于0时，需要对节点先进行一次向左旋使得符号相同后，在向右旋转一次完成平衡操作。</li><li><strong>右左旋</strong>：最小不平衡子树的BF与它的子树的BF符号相反时且最小不平衡子树的BF小于0时，需要对节点先进行一次向右旋转使得符号相同时，在向左旋转一次完成平衡操作。</li></ul><h3 id="左旋LL"><a href="#左旋LL" class="headerlink" title="左旋LL"></a>左旋LL</h3><p><img src="../../../../images/算法/LL单旋转.jpg" alt="LL旋转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">leftLeftRotation</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    root.left = left.right;</span><br><span class="line">    left.right = root;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右旋RR"><a href="#右旋RR" class="headerlink" title="右旋RR"></a>右旋RR</h3><p><img src="../../../../images/算法/RR单旋转.jpg" alt="RR旋转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">rightRightRotation</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode right = root.right;</span><br><span class="line">    root.right = right.left;</span><br><span class="line">    right.left = root;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左右旋LR"><a href="#左右旋LR" class="headerlink" title="左右旋LR"></a>左右旋LR</h3><p><img src="../../../../images/算法/LR旋转.jpg" alt="LR旋转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">leftRightRotation</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root.left = rightRightRotation(root.left);</span><br><span class="line">    <span class="keyword">return</span> leftLeftRotation(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右左旋RL"><a href="#右左旋RL" class="headerlink" title="右左旋RL"></a>右左旋RL</h3><p><img src="../../../../images/算法/RL旋转.jpg" alt="RL旋转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">rightLeftRotation</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root.right = leftLeftRotation(root.right);</span><br><span class="line">    <span class="keyword">return</span> rightRightRotation(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertAvl</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val == root.val) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不允许添加相同的节点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = insertAvl(root.left, val);</span><br><span class="line">        <span class="comment">// 插入节点后，若AVL树失去平衡，则进行相应的调节</span></span><br><span class="line">        <span class="keyword">if</span> (maxDepth(root.left) - maxDepth(root.right) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; root.left.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> leftLeftRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> leftRightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.right = insertAvl(root.right, val);</span><br><span class="line">        <span class="comment">// 插入节点后，若AVL树失去平衡，则进行相应的调节</span></span><br><span class="line">        <span class="keyword">if</span> (maxDepth(root.right) - maxDepth(root.left) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; root.right.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> rightRightRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> rightLeftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">remove</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = remove(root.left, val);</span><br><span class="line">        <span class="keyword">if</span> (maxDepth(root.right) - maxDepth(root.left) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxDepth(root.right.left) &gt; maxDepth(root.right.right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> rightLeftRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> rightRightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = remove(root.right, val);</span><br><span class="line">        <span class="keyword">if</span> (maxDepth(root.left) - maxDepth(root.right) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxDepth(root.left.right) &gt; maxDepth(root.left.left)) &#123;</span><br><span class="line">                <span class="keyword">return</span> leftRightRotation(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> leftLeftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxDepth(root.left) &gt; maxDepth(root.right)) &#123;</span><br><span class="line">                <span class="keyword">int</span> maxVal = findMax(root.left);</span><br><span class="line">                root.val = maxVal;</span><br><span class="line">                root.left = remove(root.left, maxVal);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> minVal = findMin(root.right);</span><br><span class="line">                root.val = minVal;</span><br><span class="line">                root.right = remove(root.right, minVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.left != <span class="keyword">null</span> ? root.left : root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> || root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findMax(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findMin(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序数组转换成AVL"><a href="#有序数组转换成AVL" class="headerlink" title="有序数组转换成AVL"></a>有序数组转换成<code>AVL</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toBstTraversalLeft(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">toBstTraversalLeft</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = toBstTraversalLeft(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = toBstTraversalLeft(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总是选择中间位置右边的数字作为根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">toBstTraversalRight</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = toBstTraversalRight(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = toBstTraversalRight(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择任意一个中间位置数字作为根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">toBstTraversalRandom</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right + <span class="keyword">new</span> Random().nextInt(<span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = toBstTraversalRandom(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = toBstTraversalRandom(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树判定"><a href="#平衡二叉树判定" class="headerlink" title="平衡二叉树判定"></a>平衡二叉树判定</h3><p>对二叉树做<strong>后序遍历</strong>，从底至顶返回子树深度，若判定某子树不是平衡树则 直接向上返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recur(treeNode) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftDepth = recur(treeNode.leftNode);</span><br><span class="line">    <span class="keyword">if</span> (leftDepth == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rightDepth = recur(treeNode.rightNode);</span><br><span class="line">    <span class="keyword">if</span> (rightDepth == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(leftDepth - rightDepth) &lt; <span class="number">2</span> ? Math.max(leftDepth, rightDepth) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树属于多叉树又名<strong>平衡多路查找树</strong>，<strong>数据库索引</strong>技术里大量使用者<code>B</code>树和<code>B+</code>树的数据结构。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。主要用于<strong>存储有序数据</strong>，时间复杂度为<code>O(lgn)</code>。<strong>一棵含有n个节点的红黑树的高度至多为<code>2log(n+1)</code></strong></p><ul><li>每个节点要么是黑色，要么是红色</li><li>根节点是黑色</li><li>每个<strong>空</strong>叶子节点是黑色</li><li>每个红色结点的两个子结点一定都是黑色</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平衡二叉树是一种特殊的&lt;strong&gt;二叉排序树&lt;/strong&gt;，&lt;strong&gt;每个&lt;/strong&gt;节点&lt;strong&gt;左子树&lt;/strong&gt;和&lt;strong&gt;右子树&lt;/strong&gt;高度差&lt;strong&gt;至多等于&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;。&lt;/
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://yaoyinglong.github.io/tags/%E6%A0%91/"/>
    
      <category term="AVL" scheme="https://yaoyinglong.github.io/tags/AVL/"/>
    
  </entry>
  
  <entry>
    <title>面试准备大纲</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/%E5%A4%A7%E7%BA%B2/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/大纲/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2020-08-01T05:17:24.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul><li><code>AOP</code></li><li><code>IOC</code></li><li>源码</li><li><code>SpringBoot</code></li><li><code>SpringCloud</code></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>常见面试笔试内容</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>树（前序遍历、中序遍历、后序遍历、层序遍历）<ul><li>二叉搜索树</li><li>平衡二叉树（AVL树）</li><li>红黑树</li></ul></li><li>图（广度优先遍历BFS、深度优先遍历DFS）</li><li><code>leetcode</code>题（<strong>前期每周5道，中期每周10道，后期每周15道</strong>）</li><li>常见排序总结</li><li>复杂度分析：了解常见时间复杂度，建立复杂度和数据规模之间的概念，理解均摊复杂度分析</li><li>数组<ul><li>双索引技术</li><li>对撞指针—浮动窗口</li></ul></li><li>查找表<ul><li>map</li><li>set</li><li>unordered_map</li><li>unordered_set</li></ul></li><li>链表<ul><li>虚拟头结点</li><li>双指针</li></ul></li><li>栈<ul><li>非递归算法</li><li>深入系统栈，模拟系统递归调用</li></ul></li><li>队列<ul><li>广度优先遍历</li></ul></li><li>回溯<ul><li>回溯算法</li><li>排序问题-组合问题</li><li>Floodfill</li></ul></li><li>动态规划<ul><li>记忆化搜索</li><li>重叠子问题和问题的无后效性</li><li>背包问题</li><li>LIS，LCS问题分析</li></ul></li><li>贪心算法：避过陷阱</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>6大基本原则（<strong>一周</strong>）</li><li>23种设计模式（<strong>一周5个</strong>）</li><li>设计模式对比</li></ul><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ul><li><code>JVM</code></li><li>源码</li><li>多线程</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul><li><code>RabbitMQ</code></li><li>常见面试笔试内容</li></ul><h3 id="Reids"><a href="#Reids" class="headerlink" title="Reids"></a>Reids</h3><ul><li>常见面试笔试内容</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>常用命令</li></ul><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><ul><li>常见面试笔试内容</li></ul><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><ul><li>常见面试笔试内容</li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AOP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IOC&lt;/code&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
</feed>
