<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YingLong</title>
  
  <subtitle>虽奔放不羁，但也自我束缚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoyinglong.github.io/"/>
  <updated>2020-10-20T02:18:01.122Z</updated>
  <id>https://yaoyinglong.github.io/</id>
  
  <author>
    <name>YaoYingLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis总结</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/Redis%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/Redis总结/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-20T02:18:01.122Z</updated>
    
    <content type="html"><![CDATA[<p><code>redis</code>的速度非常的快，<strong>单机</strong>的<code>redis</code>就可以支撑<strong>每秒<code>10</code>几万的并发</strong>，相对于<code>mysql</code>来说，性能是<code>mysql</code>的几十倍。速度快的原因主要有几点：</p><ol><li><strong>完全基于内存操作</strong></li><li><strong>C语言实现</strong>，<strong>优化过的数据结构</strong>，基于几种基础的数据结构，<code>redis</code>做了大量的优化，性能极高</li><li><strong>使用单线程，无上下文的切换成本</strong></li><li>基于<strong>非阻塞的<code>IO</code>多路复用机制</strong></li></ol><p>虽然<code>6.0</code>后改用多线程，但并非是完全摒弃单线程，<code>redis</code>还是使用<strong>单线程模型来处理客户端的请求</strong>，只是使用<strong>多线程来处理数据的读写和协议解析</strong>，因为<code>redis</code>的<strong>性能瓶颈</strong>在于<strong>网络<code>IO</code></strong>而非CPU，使用多线程能提升<code>IO</code>读写的效率，从而整体提高<code>redis</code>的性能，<strong>执行命令还是使用单线程</strong>。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>字符串</strong>：<code>redis</code>没有直接使用C语言传统的字符串表示，而是自己实现的叫做<strong>简单动态字符串<code>SDS</code>的抽象类型</strong>。C语言的字符串<strong>不记录自身的长度信息</strong>，而<code>SDS</code>则<strong>保存了长度信息</strong>，这样将获取字符串长度的时间由<code>O(N)</code>降低到了<code>O(1)</code>，同时可以<strong>避免缓冲区溢出</strong>和<strong>减少修改字符串长度</strong>时所需的<strong>内存重分配次数</strong>。</p><p><strong>链表<code>linkedlist</code></strong>：是一个<strong>双向无环链表结构</strong>，很多<strong>发布订阅</strong>、<strong>慢查询</strong>、<strong>监视器</strong>功能都是使用到了链表来实现，每个链表的节点由一个<strong><code>listNode</code>结构</strong>来表示，每个节点都有指向<strong>前置节点</strong>和<strong>后置节点</strong>的指针，<strong>表头节点的前置和后置节点都指向<code>NULL</code></strong>。</p><p><strong>字典<code>hashtable</code></strong>：用于保存<strong>键值对</strong>的抽象数据结构，<code>redis</code>使用<code>hash</code>表作为底层实现，<strong>每个字典带有两个<code>hash</code>表</strong>，供<strong>平时使用</strong>和<code>rehash</code>时使用，<code>hash</code>表使用<strong>链地址法</strong>来<strong>解决键冲突</strong>，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对<code>hash</code>表进行扩容或者缩容的时候，为了服务的可用性，<strong><code>rehash</code>的过程不是一次性完成的而是渐进式的</strong>。</p><p><strong>跳跃表<code>skiplist</code></strong>：<strong>有序集合的底层实现之一</strong>，<code>redis</code>中实现<strong>有序集合键</strong>和<strong>集群节点的内部结构</strong>中都是使用跳跃表。<code>redis</code>跳跃表由<code>zskiplist</code>和<code>zskiplistNode</code>组成，<code>zskiplist</code>用于保存<strong>跳跃表信息</strong>（表头、表尾节点、长度等），<code>zskiplistNode</code>用于表示<strong>表跳跃节点</strong>，每个跳跃表的<strong>层高</strong>都是<code>1-32</code>的<strong>随机数</strong>，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，<strong>节点按照分值大小排序</strong>，如果<strong>分值相同，则按照成员对象的大小排序</strong>。</p><p><strong>整数集合<code>intset</code></strong>：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</p><p><strong>压缩列表<code>ziplist</code></strong>：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</p><p>基于基础的数据结构，<code>redis</code>封装了自己的对象系统，包含<strong>字符串对象<code>string</code></strong>、<strong>列表对象<code>list</code></strong>、<strong>哈希对象<code>hash</code></strong>、<strong>集合对象<code>set</code></strong>、<strong>有序集合对象<code>zset</code></strong>，每种对象都用到了<strong>至少一种基础的数据结构</strong>。</p><p><code>redis</code>通过<code>encoding</code>属性设置对象的编码形式来提升灵活性和效率，基于不同的场景<code>redis</code>会自动做出优化。不同对象的编码如下：</p><ol><li>字符串对象<code>string</code>：<code>int</code>整数、<code>embstr</code>编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：<code>ziplist</code>、<code>linkedlist</code></li><li>哈希对象<code>hash</code>：<code>ziplist</code>、<code>hashtable</code></li><li>集合对象<code>set</code>：<code>intset</code>、<code>hashtable</code></li><li>有序集合对象<code>zset</code>：<code>ziplist</code>、<code>skiplist</code></li></ol><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>当查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。</p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。</p><h5 id="定期-惰性都没有删除过期的key"><a href="#定期-惰性都没有删除过期的key" class="headerlink" title="定期+惰性都没有删除过期的key"></a>定期+惰性都没有删除过期的key</h5><p>每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存无法被删除，这时候就会走到<code>redis</code>的<strong>内存淘汰机制</strong>。</p><ul><li><strong><code>volatile-lru</code></strong>：从已设置过期时间的key中，移出<strong>最近最少使用</strong>的key进行淘汰</li><li><strong><code>volatile-ttl</code></strong>：从已设置过期时间的key中，移出<strong>将要过期</strong>的key</li><li><strong><code>volatile-random</code></strong>：从已设置过期时间的key中，<strong>随机</strong>选择key淘汰</li><li><strong><code>allkeys-lru</code></strong>：从key中选择最近<strong>最少使用</strong>的进行淘汰</li><li><strong><code>allkeys-random</code></strong>：从key中<strong>随机</strong>选择key进行淘汰</li><li><strong><code>noeviction</code></strong>：当<strong>内存达到阈值</strong>的时候，<strong>新写入操作报错</strong></li></ul><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><code>RDB</code></h5><p><code>RDB</code>持久化<strong>可手动执行</strong>也<strong>可根据配置定期执行</strong>，它的作用是<strong>将某个时间点上的数据库状态保存到<code>RDB</code>文件中</strong>，<code>RDB</code>文件是一个<strong>压缩的二进制文件</strong>，<strong>通过它可以还原某个时刻数据库的状态</strong>。由于<code>RDB</code>文件是保存在硬盘上的，所以即使<code>redis</code>崩溃或者退出，只要<code>RDB</code>文件存在，就可以用它来恢复还原数据库的状态。</p><p>可以通过<code>SAVE</code>或者<code>BGSAVE</code>来生成<code>RDB</code>文件。<strong><code>SAVE</code>命令会阻塞<code>redis</code>进程</strong>，直到<code>RDB</code>文件生成完毕，在进程<strong>阻塞期间，<code>redis</code>不能处理任何命令请求</strong>，显然不合适。</p><p><code>BGSAVE</code>则是会<code>fork</code>出一个子进程，然后<strong>由子进程去负责生成<code>RDB</code>文件</strong>，父进程还可以继续处理命令请求，不会阻塞进程。</p><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><code>AOF</code></h5><p><code>AOF</code>是通过保存<code>redis</code>服务器所<strong>执行的写命令来记录数据库状态的</strong>，<code>AOF</code>通过<strong>追加</strong>、<strong>写入</strong>、<strong>同步</strong>三个步骤来实现持久化机制。</p><p>当<code>AOF</code>持久化处于<strong>激活状态</strong>，服务器<strong>执行完写命令之后</strong>，写命令将会<strong>被追加<code>append</code>到<code>aof_buf</code>缓冲区的末尾</strong>；</p><p>在服务器<strong>每结束一个事件循环之前</strong>，将调用<code>flushAppendOnlyFile</code>函数决定是否要将<code>aof_buf</code>的内容保存到<code>AOF</code>文件中，可以通过配置<code>appendfsync</code>来决定。</p><ul><li><code>always</code>：<code>aof_buf</code>内容写入并同步到<code>AOF</code>文件</li><li><code>everysec</code>：将<code>aof_buf</code>中内容写入到<code>AOF</code>文件，如果上次同步<code>AOF</code>文件时间距离现在超过1秒，则再次对<code>AOF</code>文件进行同步</li><li><code>no</code>：将<code>aof_buf</code>内容写入<code>AOF</code>文件，但是并不对<code>AOF</code>文件进行同步，同步时间由操作系统决定</li></ul><p>默认选项是<code>everysec</code>，因为<code>always</code>来说虽然最安全（只会丢失一次事件循环的写命令），但是<strong>性能较差</strong>，而<code>everysec</code>模式只不过会可能丢失1秒钟的数据，而no模式的效率和<code>everysec</code>相仿，但是会丢失上次同步<code>AOF</code>文件之后的所有写命令数据。</p><h3 id="热KEY"><a href="#热KEY" class="headerlink" title="热KEY"></a>热KEY</h3><p>突然有几十万的请求访问<code>redis</code>上的某个特定<code>key</code>，这样会造成<strong>流量过于集中</strong>，<strong>达到物理网卡上限</strong>，从而导致这台<code>redis</code>的服务器宕机引发雪崩。解决方案：</p><ul><li>提前把<strong>热<code>key</code>打散到不同的服务器</strong>，降低压力</li><li>加入<strong>二级缓存</strong>，<strong>提前加载热<code>key</code>数据到内存中</strong>，如果<code>redis</code>宕机，走内存查询</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上。解决方案：</p><ul><li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了</li><li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在缓存中的数据，每次请求都会打到DB。可以通过<strong>加一层布隆过滤器</strong>。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃。解决方案：</p><ul><li>针对不同<code>key</code>设置不同的过期时间，避免同时过期</li><li>限流，如果<code>redis</code>宕机，可以限流，避免同时刻大量请求打崩DB</li><li>二级缓存，同热<code>key</code>的方案。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;redis&lt;/code&gt;的速度非常的快，&lt;strong&gt;单机&lt;/strong&gt;的&lt;code&gt;redis&lt;/code&gt;就可以支撑&lt;strong&gt;每秒&lt;code&gt;10&lt;/code&gt;几万的并发&lt;/strong&gt;，相对于&lt;code&gt;mysql&lt;/code&gt;来说，性能是&lt;
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Redis" scheme="https://yaoyinglong.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis总结</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/Redis%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/Redis总结/</id>
    <published>2020-10-18T16:00:00.000Z</published>
    <updated>2020-10-19T03:12:17.465Z</updated>
    
    <content type="html"><![CDATA[<p><code>redis</code>的速度非常的快，<strong>单机</strong>的<code>redis</code>就可以支撑<strong>每秒<code>10</code>几万的并发</strong>，相对于<code>mysql</code>来说，性能是<code>mysql</code>的几十倍。速度快的原因主要有几点：</p><ol><li><strong>完全基于内存操作</strong></li><li><strong>C语言实现</strong>，<strong>优化过的数据结构</strong>，基于几种基础的数据结构，<code>redis</code>做了大量的优化，性能极高</li><li><strong>使用单线程，无上下文的切换成本</strong></li><li>基于<strong>非阻塞的<code>IO</code>多路复用机制</strong></li></ol><p>虽然<code>6.0</code>后改用多线程，但并非是完全摒弃单线程，<code>redis</code>还是使用<strong>单线程模型来处理客户端的请求</strong>，只是使用<strong>多线程来处理数据的读写和协议解析</strong>，因为<code>redis</code>的<strong>性能瓶颈</strong>在于<strong>网络<code>IO</code></strong>而非CPU，使用多线程能提升<code>IO</code>读写的效率，从而整体提高<code>redis</code>的性能，<strong>执行命令还是使用单线程</strong>。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>字符串</strong>：<code>redis</code>没有直接使用C语言传统的字符串表示，而是自己实现的叫做<strong>简单动态字符串<code>SDS</code>的抽象类型</strong>。C语言的字符串<strong>不记录自身的长度信息</strong>，而<code>SDS</code>则<strong>保存了长度信息</strong>，这样将获取字符串长度的时间由<code>O(N)</code>降低到了<code>O(1)</code>，同时可以<strong>避免缓冲区溢出</strong>和<strong>减少修改字符串长度</strong>时所需的<strong>内存重分配次数</strong>。</p><p><strong>链表<code>linkedlist</code></strong>：是一个<strong>双向无环链表结构</strong>，很多<strong>发布订阅</strong>、<strong>慢查询</strong>、<strong>监视器</strong>功能都是使用到了链表来实现，每个链表的节点由一个<strong><code>listNode</code>结构</strong>来表示，每个节点都有指向<strong>前置节点</strong>和<strong>后置节点</strong>的指针，<strong>表头节点的前置和后置节点都指向<code>NULL</code></strong>。</p><p><strong>字典<code>hashtable</code></strong>：用于保存<strong>键值对</strong>的抽象数据结构，<code>redis</code>使用<code>hash</code>表作为底层实现，<strong>每个字典带有两个<code>hash</code>表</strong>，供<strong>平时使用</strong>和<code>rehash</code>时使用，<code>hash</code>表使用<strong>链地址法</strong>来<strong>解决键冲突</strong>，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对<code>hash</code>表进行扩容或者缩容的时候，为了服务的可用性，<strong><code>rehash</code>的过程不是一次性完成的而是渐进式的</strong>。</p><p><strong>跳跃表<code>skiplist</code></strong>：<strong>有序集合的底层实现之一</strong>，<code>redis</code>中实现<strong>有序集合键</strong>和<strong>集群节点的内部结构</strong>中都是使用跳跃表。<code>redis</code>跳跃表由<code>zskiplist</code>和<code>zskiplistNode</code>组成，<code>zskiplist</code>用于保存<strong>跳跃表信息</strong>（表头、表尾节点、长度等），<code>zskiplistNode</code>用于表示<strong>表跳跃节点</strong>，每个跳跃表的<strong>层高</strong>都是<code>1-32</code>的<strong>随机数</strong>，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，<strong>节点按照分值大小排序</strong>，如果<strong>分值相同，则按照成员对象的大小排序</strong>。</p><p><strong>整数集合<code>intset</code></strong>：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</p><p><strong>压缩列表<code>ziplist</code></strong>：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</p><p>基于基础的数据结构，<code>redis</code>封装了自己的对象系统，包含<strong>字符串对象<code>string</code></strong>、<strong>列表对象<code>list</code></strong>、<strong>哈希对象<code>hash</code></strong>、<strong>集合对象<code>set</code></strong>、<strong>有序集合对象<code>zset</code></strong>，每种对象都用到了<strong>至少一种基础的数据结构</strong>。</p><p><code>redis</code>通过<code>encoding</code>属性设置对象的编码形式来提升灵活性和效率，基于不同的场景<code>redis</code>会自动做出优化。不同对象的编码如下：</p><ol><li>字符串对象<code>string</code>：<code>int</code>整数、<code>embstr</code>编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：<code>ziplist</code>、<code>linkedlist</code></li><li>哈希对象<code>hash</code>：<code>ziplist</code>、<code>hashtable</code></li><li>集合对象<code>set</code>：<code>intset</code>、<code>hashtable</code></li><li>有序集合对象<code>zset</code>：<code>ziplist</code>、<code>skiplist</code></li></ol><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>当查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。</p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。</p><h5 id="定期-惰性都没有删除过期的key"><a href="#定期-惰性都没有删除过期的key" class="headerlink" title="定期+惰性都没有删除过期的key"></a>定期+惰性都没有删除过期的key</h5><p>每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存无法被删除，这时候就会走到<code>redis</code>的<strong>内存淘汰机制</strong>。</p><ul><li><strong><code>volatile-lru</code></strong>：从已设置过期时间的key中，移出<strong>最近最少使用</strong>的key进行淘汰</li><li><strong><code>volatile-ttl</code></strong>：从已设置过期时间的key中，移出<strong>将要过期</strong>的key</li><li><strong><code>volatile-random</code></strong>：从已设置过期时间的key中，<strong>随机</strong>选择key淘汰</li><li><strong><code>allkeys-lru</code></strong>：从key中选择最近<strong>最少使用</strong>的进行淘汰</li><li><strong><code>allkeys-random</code></strong>：从key中<strong>随机</strong>选择key进行淘汰</li><li><strong><code>noeviction</code></strong>：当<strong>内存达到阈值</strong>的时候，<strong>新写入操作报错</strong></li></ul><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><code>RDB</code></h5><p><code>RDB</code>持久化<strong>可手动执行</strong>也<strong>可根据配置定期执行</strong>，它的作用是<strong>将某个时间点上的数据库状态保存到<code>RDB</code>文件中</strong>，<code>RDB</code>文件是一个<strong>压缩的二进制文件</strong>，<strong>通过它可以还原某个时刻数据库的状态</strong>。由于<code>RDB</code>文件是保存在硬盘上的，所以即使<code>redis</code>崩溃或者退出，只要<code>RDB</code>文件存在，就可以用它来恢复还原数据库的状态。</p><p>可以通过<code>SAVE</code>或者<code>BGSAVE</code>来生成<code>RDB</code>文件。<strong><code>SAVE</code>命令会阻塞<code>redis</code>进程</strong>，直到<code>RDB</code>文件生成完毕，在进程<strong>阻塞期间，<code>redis</code>不能处理任何命令请求</strong>，显然不合适。</p><p><code>BGSAVE</code>则是会<code>fork</code>出一个子进程，然后<strong>由子进程去负责生成<code>RDB</code>文件</strong>，父进程还可以继续处理命令请求，不会阻塞进程。</p><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><code>AOF</code></h5><p><code>AOF</code>是通过保存<code>redis</code>服务器所<strong>执行的写命令来记录数据库状态的</strong>，<code>AOF</code>通过<strong>追加</strong>、<strong>写入</strong>、<strong>同步</strong>三个步骤来实现持久化机制。</p><p>当<code>AOF</code>持久化处于<strong>激活状态</strong>，服务器<strong>执行完写命令之后</strong>，写命令将会<strong>被追加<code>append</code>到<code>aof_buf</code>缓冲区的末尾</strong>；</p><p>在服务器<strong>每结束一个事件循环之前</strong>，将调用<code>flushAppendOnlyFile</code>函数决定是否要将<code>aof_buf</code>的内容保存到<code>AOF</code>文件中，可以通过配置<code>appendfsync</code>来决定。</p><ul><li><code>always</code>：<code>aof_buf</code>内容写入并同步到<code>AOF</code>文件</li><li><code>everysec</code>：将<code>aof_buf</code>中内容写入到<code>AOF</code>文件，如果上次同步<code>AOF</code>文件时间距离现在超过1秒，则再次对<code>AOF</code>文件进行同步</li><li><code>no</code>：将<code>aof_buf</code>内容写入<code>AOF</code>文件，但是并不对<code>AOF</code>文件进行同步，同步时间由操作系统决定</li></ul><p>默认选项是<code>everysec</code>，因为<code>always</code>来说虽然最安全（只会丢失一次事件循环的写命令），但是<strong>性能较差</strong>，而<code>everysec</code>模式只不过会可能丢失1秒钟的数据，而no模式的效率和<code>everysec</code>相仿，但是会丢失上次同步<code>AOF</code>文件之后的所有写命令数据。</p><h3 id="热KEY"><a href="#热KEY" class="headerlink" title="热KEY"></a>热KEY</h3><p>突然有几十万的请求访问<code>redis</code>上的某个特定<code>key</code>，这样会造成<strong>流量过于集中</strong>，<strong>达到物理网卡上限</strong>，从而导致这台<code>redis</code>的服务器宕机引发雪崩。解决方案：</p><ul><li>提前把<strong>热<code>key</code>打散到不同的服务器</strong>，降低压力</li><li>加入<strong>二级缓存</strong>，<strong>提前加载热<code>key</code>数据到内存中</strong>，如果<code>redis</code>宕机，走内存查询</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上。解决方案：</p><ul><li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了</li><li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在缓存中的数据，每次请求都会打到DB。可以通过<strong>加一层布隆过滤器</strong>。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃。解决方案：</p><ul><li>针对不同<code>key</code>设置不同的过期时间，避免同时过期</li><li>限流，如果<code>redis</code>宕机，可以限流，避免同时刻大量请求打崩DB</li><li>二级缓存，同热<code>key</code>的方案。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;redis&lt;/code&gt;的速度非常的快，&lt;strong&gt;单机&lt;/strong&gt;的&lt;code&gt;redis&lt;/code&gt;就可以支撑&lt;strong&gt;每秒&lt;code&gt;10&lt;/code&gt;几万的并发&lt;/strong&gt;，相对于&lt;code&gt;mysql&lt;/code&gt;来说，性能是&lt;
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="Redis" scheme="https://yaoyinglong.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CAS原理及使用场景</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/CAS%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/CAS原理及使用场景/</id>
    <published>2020-10-14T16:00:00.000Z</published>
    <updated>2020-10-09T07:43:15.836Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="CAS" scheme="https://yaoyinglong.github.io/tags/CAS/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/单例模式/</id>
    <published>2020-10-08T16:00:00.000Z</published>
    <updated>2020-10-09T07:37:51.635Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式的核心代码就是将<strong>构造方法私有化</strong>，只有一个实例，自己负责创建自己的对象，提供一种访问其唯一对象的方式，可直接访问，不需要实例化该类的对象。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>实例在使用时才去创建，用的时候才去检查有没有实例。有线程安全和线程不安全两种写法，区别就是<code>synchronized</code>关键字。下面这种写法存在线程安全问题，在并发获取实例时，可能会存在创建多个实例的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>在类加载时实例被创建。实现简单且没有线程安全的问题，可能在还不需要此实例的时候就已经把实例创建出来了，浪费内存空间，没起到<code>lazy loading</code>的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双检锁"><a href="#双检锁" class="headerlink" title="双检锁"></a>双检锁</h3><p><strong>双重校验锁</strong>，综合了<strong>懒汉式</strong>和<strong>饿汉式</strong>两者的优缺点。特点在<code>synchronized</code>关键字内外都加了一层 <code>if</code> 条件判断，既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。这里还用到了<code>volatile</code>关键字来修饰<code>instance</code>，其最关键的作用是<strong>防止指令重排</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类的方式效果类似双检锁，但实现更简单且线程安全。同时静态内部类不会在<code>Singleton</code>类加载时就加载，而是在调用<code>getInstance()</code>方法时才进行加载，<strong>达到了懒加载的效果</strong>。但这种方式只适用于<strong>静态域</strong>的情况，双检锁方式可在<strong>实例域</strong>需要<strong>延迟初始化</strong>时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举的方式是比较少见的一种实现方式，却更简洁清晰。还<strong>自动支持序列化机制</strong>，绝对防止多次实例化。<strong>单元素</strong>的<strong>枚举类型</strong>已经成为实现<code>Singleton</code>的最佳方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring中典型应用"><a href="#Spring中典型应用" class="headerlink" title="Spring中典型应用"></a>Spring中典型应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">   Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">         singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">         <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式的核心代码就是将&lt;strong&gt;构造方法私有化&lt;/strong&gt;，只有一个实例，自己负责创建自己的对象，提供一种访问其唯一对象的方式，可直接访问，不需要实例化该类的对象。&lt;/p&gt;
&lt;h3 id=&quot;懒汉式&quot;&gt;&lt;a href=&quot;#懒汉式&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java与线程</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Java%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Java与线程/</id>
    <published>2020-10-05T16:00:00.000Z</published>
    <updated>2020-10-09T07:49:50.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><h4 id="使用内核实现"><a href="#使用内核实现" class="headerlink" title="使用内核实现"></a>使用内核实现</h4><h4 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h4><h4 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h4><h4 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h4><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程的实现&quot;&gt;&lt;a href=&quot;#线程的实现&quot; class=&quot;headerlink&quot; title=&quot;线程的实现&quot;&gt;&lt;/a&gt;线程的实现&lt;/h3&gt;&lt;h4 id=&quot;使用内核实现&quot;&gt;&lt;a href=&quot;#使用内核实现&quot; class=&quot;headerlink&quot; title=&quot;使
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Java内存模型与线程/</id>
    <published>2020-09-26T16:00:00.000Z</published>
    <updated>2020-10-09T07:49:50.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="硬件效率与一致性"><a href="#硬件效率与一致性" class="headerlink" title="硬件效率与一致性"></a>硬件效率与一致性</h3><p>计算机的<strong>存储设备</strong>与<strong>处理器的运算速度</strong>有<strong>几个数量级</strong>的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的<strong>高速缓存</strong>来作为<strong>内存</strong>与<strong>处理器</strong>之间的缓冲：<strong>将运算需要使用到的数据复制到缓存中</strong>，让运算能快速进行，<strong>当运算结束后再从缓存中将数据同步回内存之中</strong>。</p><p>基于高速缓存的存储交互很好的解决了<strong>处理器与内存的速度矛盾</strong>，但也引入了一个新的问题：<strong>缓存一致性</strong>。在多处理器系统中，每个处理器都有自己的高速缓存，又<strong>共享同一主内存</strong>，多个处理器的运算任务都涉及<strong>同一块</strong>主内存区域时，<strong>可能导致各自的缓存数据不一致</strong>。</p><p>为了解决<strong>缓存数据一致性</strong>问题，需要各个处理器访问缓存时都遵循一些<strong>协议</strong>，如：<code>MSI</code>、<code>MESI</code>、<code>MOSI</code>、<code>Synapse</code>、<code>Firefly</code>、<code>Dragon Protocol</code>等。</p><p><img src="../../../../../images/Java/处理器、高速缓存、主内存间的交互关系.jpg" alt="处理器、高速缓存、主内存间的交互关系"></p><p>除了增加高速缓存外，为了使处理器内部的运算单元尽可能被充分利用，处理器可能会对输入的代码进行<strong>乱序执行优化</strong>，即<strong>指令重排序</strong>，处理器会在<strong>计算之后将乱序执行的结果重组</strong>，<strong>保证该结果与顺序执行的结果是一致的</strong>，但不保证程序中各个语句计算的先后顺序与输入的代码中的顺序一致。</p><p><code>Java</code>虚拟机的即时编译器中也有类似的<strong>指令重排序优化</strong>。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p><code>Java</code>虚拟机中试图定义一种<strong><code>Java</code>内存模型<code>JMM</code></strong>来<strong>屏蔽</strong>各种<strong>硬件</strong>和<strong>操作系统</strong>的<strong>内存访问差异</strong>。<code>C/C++</code>语言是直接使用物理硬件和操作系统的内存模型，由于不同平台上内存模型的差异，可能导致不同平台上并发访问出错。</p><p><strong><code>Java</code>内存模型的主要目标是定义程序中各个变量的访问规则</strong>，即在虚拟机中<strong>将变量存储到内存</strong>和<strong>从内存中取出变量</strong>这样的底层细节。这里说的变量包括：<strong>实例字段</strong>、<strong>静态字段</strong>、<strong>构成数组对象的元素</strong>，不包括：<strong>局部变量</strong>、<strong>方法参数</strong>。因为局部变量和方法参数是<strong>线程私有</strong>的。</p><p><code>Java</code>内存模型并<strong>没有限制执行引擎使用处理器</strong>的<strong>特定寄存器</strong>或<strong>缓存</strong>来和<strong>主内存</strong>交互，也<strong>没有限制即时编译器进行调整代码执行顺序</strong>这类优化措施。</p><p><code>Java</code>内存模型<strong>规定</strong>了所有的<strong>变量都存储在主内存</strong>（虚拟机内存中的一部分）中，每条线程有自己的工作内存，线程的<strong>工作内存</strong>中保存了被该线程使用到的变量的<strong>主内存副本拷贝</strong>，线程对变量的<strong>所有操作都必须在工作内存中进行</strong>，<strong>不能直接读写主内存中的变量</strong>。不同的线程间也无法直接访问对方的工作内存中的变量，线程间变量值得传递均需要通过主内存来完成。</p><p>注：<strong>拷贝副本</strong>，事实上并<strong>不会完全复制一份对象</strong>拷贝出来，该<strong>对象的引用</strong>、<strong>对象中某个在线程访问到的字段</strong>是有可能存在拷贝的，但<strong>不会有虚拟机实现成把整个对象拷贝一次</strong>。</p><p><img src="../../../../../images/Java/线程、主内存、工作内存三者交互关系.jpg" alt="线程、主内存、工作内存三者交互关系"></p><p>注：若<strong>局部变量</strong>是一个<code>reference</code>类型，它引用的对象在堆中可被各个线程共享，但<code>reference</code>本身在Java栈的局部变量表中，是线程私有的。</p><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>Java内存模型中定义了以下<code>8</code>种操作来完成<strong>主内存</strong>与<strong>工作内存</strong>之间的具体<strong>交互协议</strong>，虚拟机实现时必须保证每一种操作都是<strong>原子</strong>的、不可再分的。</p><table><thead><tr><th>操作</th><th>作用域</th><th>完成的工作</th></tr></thead><tbody><tr><td><strong><code>lock</code></strong>（<strong>锁定</strong>）</td><td><strong>主</strong>内存变量</td><td>把一个变量标识为一条<strong>线程独占状态</strong></td></tr><tr><td><strong><code>unlock</code></strong>（<strong>解锁</strong>）</td><td><strong>主</strong>内存变量</td><td>把一个<strong>处于锁定状态的变量释放出来</strong>，释放后才可被其他线程锁定</td></tr><tr><td><strong><code>read</code></strong>（<strong>读取</strong>）</td><td><strong>主</strong>内存变量</td><td>把一个变量的值<strong>从主内存传输到线程的工作内存</strong>中</td></tr><tr><td><strong><code>load</code></strong>（<strong>载入</strong>）</td><td><strong>工作</strong>内存变量</td><td>把<strong><code>read</code></strong>操作从主内存中得到的变量值放入工作内存的<strong>变量副本</strong>中</td></tr><tr><td><strong><code>use</code></strong>（<strong>使用</strong>）</td><td><strong>工作</strong>内存变量</td><td>把工作内存中变量值传递给执行引擎</td></tr><tr><td><strong><code>assign</code></strong>（<strong>赋值</strong>）</td><td><strong>工作</strong>内存变量</td><td><strong>把从执行引擎接收到的值赋给工作内存的变量</strong></td></tr><tr><td><strong><code>store</code></strong>（<strong>存储</strong>）</td><td><strong>工作</strong>内存变量</td><td>把工作内存中一个变量的值传递到主内存中</td></tr><tr><td><strong><code>write</code></strong>（<strong>写入</strong>）</td><td><strong>主</strong>内存变量</td><td>把<strong><code>store</code></strong>操作从工作内存中得到的变量值放入主内存的变量中</td></tr></tbody></table><p>若把一个变量<strong>从主内存复制到工作内存</strong>，需要<strong>顺序</strong>执行<strong><code>read</code></strong>和<strong><code>load</code></strong>操作。若要将变量从<strong>工作内存同步回主内存</strong>，需<strong>顺序</strong>执行<strong><code>store</code></strong>和<strong><code>write</code></strong>操作。<code>Java</code>内存模型只要求上述两个操作必须顺序执行，而<strong>没有保证是连续执行</strong>。</p><p><code>Java</code>内存模型规定了在执行上述<code>8</code>种操作时必须满足以下规则：</p><ul><li><strong>不允许</strong><code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一<strong>单独出现</strong>，即<strong>不允许</strong>一个变量<strong>从主内存读取了但工作内存不接受</strong>，或<strong>从工作内存发起回写但主内存不接受</strong>的情况出现。</li><li><strong>不允许线程丢弃它最近的<code>assign</code>操作</strong>，即变量<strong>在工作内存中改变了之后必须把它同步回主内存</strong>。</li><li><strong>不允许</strong>线程无原因地（<strong>未发生任何<code>assign</code>操作</strong>）把数据从线程<strong>工作内存同步回主内存</strong>。</li><li>一个<strong>新变量只能在主内存中诞生</strong>，<strong>不允许工作内存</strong>中直接使用一个<strong>未被初始化</strong>（<code>load</code>或<code>assign</code>）的变量。即对一个变量实施<code>use</code>、<code>store</code>操作之前，必须先执行过了<code>assign</code>和<code>load</code>操作。</li><li>一个变量同一时刻<strong>只允许一条线程</strong>对其进行<code>lock</code>操作，但<code>lock</code>操作<strong>可以被同一条线程重复执行多次</strong>，多次执行<code>lock</code>后，只有<strong>执行相同次数</strong>的<code>unlock</code>操作，变量才会被解锁。</li><li>若对一个变量执行<code>lock</code>操作，将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量钱，需要<strong>重新执行<code>load</code>或<code>assign</code>操作初始化变量</strong>的值。</li><li>若变量<strong>事先没有被<code>lock</code>操作锁定，不允许对它执行<code>unlock</code>操作</strong>，也<strong>不允许<code>unlock</code></strong>一个被其<strong>他线程锁定</strong>的变量。</li><li><strong>对变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存中</strong>。</li></ul><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;硬件效率与一致性&quot;&gt;&lt;a href=&quot;#硬件效率与一致性&quot; class=&quot;headerlink&quot; title=&quot;硬件效率与一致性&quot;&gt;&lt;/a&gt;硬件效率与一致性&lt;/h3&gt;&lt;p&gt;计算机的&lt;strong&gt;存储设备&lt;/strong&gt;与&lt;strong&gt;处理器的运算速度&lt;/st
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JVM，线程" scheme="https://yaoyinglong.github.io/tags/JVM%EF%BC%8C%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>动态代理</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/动态代理/</id>
    <published>2020-09-09T16:00:00.000Z</published>
    <updated>2020-10-09T07:41:12.170Z</updated>
    
    <content type="html"><![CDATA[<p>代理的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealSubject do something "</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectProxy</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Do something before"</span>);</span><br><span class="line">        subject.doSomething(param);</span><br><span class="line">        System.out.println(<span class="string">"Do something after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是jre提供的类库，可直接使用<strong>不依赖第三方</strong>，但<code>JDK</code>的<strong>动态代理</strong>只能代理接口。首先创建一个<strong>代理类<code>EnhaceInvocationHandler</code></strong>实现<code>java.lang.reflect.InvocationHandler</code>接口，<strong>重写<code>invoke</code>方法</strong>。在<code>method.invoke</code>方法调用前后添加我们需要增强的代码逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhaceInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnhaceInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object obj : args) &#123;</span><br><span class="line">                System.out.println(<span class="string">"args=="</span> + obj.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"args==null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Do something before"</span>);</span><br><span class="line">            Object result = method.invoke(target, args);</span><br><span class="line">            System.out.println(<span class="string">"Do something after"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getCause().printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">creatProxyObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">Subject subject = (Subject) Proxy.newProxyInstance(Subject.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;Subject.class&#125;,</span><br><span class="line">        <span class="keyword">new</span> EnhaceInvocationHandler(realSubject));</span><br><span class="line">subject.doSomething(<span class="string">"AAAA"</span>);</span><br><span class="line"></span><br><span class="line">EnhaceInvocationHandler handler = <span class="keyword">new</span> EnhaceInvocationHandler(realSubject);</span><br><span class="line">Subject subject = (Subject)  handler.creatProxyObj();</span><br><span class="line">subject.doSomething(<span class="string">"AAAA"</span>);</span><br></pre></td></tr></table></figure><h3 id="CGLib代理"><a href="#CGLib代理" class="headerlink" title="CGLib代理"></a>CGLib代理</h3><p><strong>代理的目的是构造一个和被代理的对象同样行为的对象</strong>，一个对象的行为是在类中定义的，对象只是类的实例，故构造代理不一定非得通过持有、包装对象这一种方式。<strong><code>CGLib</code>是通过继承父类所有的公有方法</strong>，然后重写这些方法，在<strong>重写时对这些方法增强</strong>。首先也是创建一个代理类<code>CGLibProxy</code>实现<code>net.sf.cglib.proxy.MethodInterceptor</code>接口重写<code>intercept</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Do something before"</span>);</span><br><span class="line">        Object object = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">        System.out.println(<span class="string">"Do something after"</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">creatProxyObj</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置代理的地方与<strong><code>JDK</code>动态代理</strong>略有区别。并不要求委托类必须实现接口，底层采用<strong><code>asm</code>字节码</strong>生成框架生成代理类的字节码，<code>Enhancer</code>是<code>CGLib</code>的<strong>字节码增强器</strong>，可以方便的对类进行扩展，内部调用<code>GeneratorStrategy.generate</code>方法生成代理类的字节码，<strong><code>CGLib</code>动态代理</strong>不仅仅<strong>可以代理接口</strong>，还可以代理<strong>非接口类</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(realSubject.getClass());</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> CGLibProxy());</span><br><span class="line">Subject subject = (Subject) enhancer.create();</span><br><span class="line">subject.doSomething(<span class="string">"AAAA"</span>);</span><br><span class="line"></span><br><span class="line">CGLibProxy proxy = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line">Subject subject = (Subject) proxy.creatProxyObj(realSubject.getClass());</span><br><span class="line">subject.doSomething(<span class="string">"AAAA"</span>);</span><br></pre></td></tr></table></figure><p><code>CGLib</code>动态代理中生成的<strong>字节码更加复杂</strong>，生成的代理类是委托类的子类，且<strong>不能处理被<code>final</code>关键字修饰的方法</strong>；<code>JDK</code>采用<strong>反射机制</strong>调用委托类的方法，<code>CGLib</code>采用<strong>类似索引</strong>的方式<strong>直接调用委托类方法</strong>；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理的基础类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="动态代理" scheme="https://yaoyinglong.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>反射基础</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/反射基础/</id>
    <published>2020-09-07T16:00:00.000Z</published>
    <updated>2020-10-09T07:41:21.920Z</updated>
    
    <content type="html"><![CDATA[<p>反射主要指程序可以访问、检测和修改他本身状态和行为的一种能力，程序在运行时能获取自身的信息；对于任意一个类，都能够获取到这个类的<strong>所有属性和方法</strong>，对于任意一个对象，都能够调用它的<strong>任意一个方法和属性</strong>，包括<strong>私有</strong>的方法和属性，这种<strong>动态获取的信息以及动态调用对象的方法的功能</strong>就称为<code>Java</code>语言的反射机制。</p><p><strong>反射的优点</strong>：能使代码更灵活，更加容易实现面向对象，能够使我们很方便的创建灵活的代码，这些代码可以在运行时再装配，无需组件之间进行源代码的链接，体现了多态的应用，降低类之间的耦合性，可以动态的创建对象和编译；</p><p><strong>反射的缺点</strong>：打破了<code>Java</code>的封装性，导致了<code>Java</code>对像的不安全，使软件的性能降低，复杂度增加，维护成本变高。</p><p>反射相关的主要<code>API</code>:</p><ul><li><strong><code>java.lang.Class</code></strong>：代表一个类</li><li><strong><code>java.lang.reflect.Method</code></strong>：代表类的方法</li><li><strong><code>java.lang.reflect.Field</code></strong>：代表类的成员变量</li><li><strong><code>java.lang.reflect.Constructor</code></strong>：代表类的构造方法</li></ul><p>用于测试的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectIssue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String publicParam = <span class="string">"this is a reflect public parameter"</span>;</span><br><span class="line">    <span class="keyword">private</span> String privateParam = <span class="string">"this is a reflect private parameter"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectIssue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectIssue</span><span class="params">(String publicParam, String privateParam)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publicParam = publicParam;</span><br><span class="line">        <span class="keyword">this</span>.privateParam = privateParam;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reflectPrivate</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private : "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflectPublic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public : "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moreParam</span><span class="params">(String paramA, String paramB)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"paramA : "</span> + paramA + <span class="string">", paramB："</span> + paramB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reflection方式"><a href="#Reflection方式" class="headerlink" title="Reflection方式"></a>Reflection方式</h3><p>获取类的<code>Class</code>对象有以下<strong>四种</strong>方式，实际应用中最常用的是通过<code>Class.forName</code>和<code>classLoader</code>的方式来获取<code>Class</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReflectIssue reflectIssue = <span class="keyword">new</span> ReflectIssue();</span><br><span class="line">Class clazz = reflectIssue.getClass();</span><br><span class="line"></span><br><span class="line">Class clazz = ReflectIssue.class;</span><br><span class="line"></span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.example.ReflectIssue"</span>);</span><br><span class="line"></span><br><span class="line">ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">Class clazz = classLoader.loadClass(<span class="string">"com.example.ReflectIssue"</span>);</span><br></pre></td></tr></table></figure><p><strong><code>getField</code>不能</strong>获取<strong>私有属性</strong>，要获取私有属性使用<code>getDeclaredField</code>方法，该方法<strong>也可以</strong>用于获取<code>public</code>属性。如果要访问私有属性必须通过<code>setAccessible</code>将<strong>访问权限</strong>打开。如果在<strong>当前类</strong>中进行<strong>反射调用自己</strong>可以不用通过<code>setAccessible</code>打开权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.example.ReflectIssue"</span>);</span><br><span class="line">ReflectIssue reflectIssue = (ReflectIssue) clazz.newInstance();</span><br><span class="line">Field publicParam = clazz.getField(<span class="string">"publicParam"</span>);</span><br><span class="line">System.out.println(publicParam.getName());</span><br><span class="line">System.out.println(publicParam.get(reflectIssue));</span><br><span class="line"></span><br><span class="line">Field privateParam = clazz.getDeclaredField(<span class="string">"privateParam"</span>);</span><br><span class="line">privateParam.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(privateParam.getName());</span><br><span class="line">System.out.println(privateParam.get(reflectIssue));</span><br><span class="line">privateParam.set(reflectIssue, <span class="string">"new private param value"</span>);</span><br></pre></td></tr></table></figure><p>同样针对于方法的获取，私有方法获取必须使用<code>getDeclaredMethod</code>方法，该方法也可以用于获取<code>public</code>方法，关于参数的列表可以<strong>直接传入一个数组</strong>，也可以<strong>按照顺序传入多个参数</strong>。私有方法的调用需要通过<code>setAccessible</code>方法打开权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Method method = clazz.getMethod(<span class="string">"reflectPublic"</span>, String.class);</span><br><span class="line">method.invoke(clazz.newInstance(), <span class="string">"this is a public function"</span>);</span><br><span class="line"></span><br><span class="line">Method method = clazz.getMethod(<span class="string">"reflectPublic"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">method.invoke(clazz.newInstance(), <span class="keyword">new</span> Object[]&#123;<span class="string">"this is a public function"</span>&#125;);</span><br><span class="line"></span><br><span class="line">Method reflectPrivate = clazz.getDeclaredMethod(<span class="string">"reflectPrivate"</span>, String.class);</span><br><span class="line">reflectPrivate.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">reflectPrivate.invoke(clazz.newInstance(), <span class="string">"this is a private function"</span>);</span><br><span class="line"></span><br><span class="line">((ReflectIssue) clazz.newInstance()).reflectPrivate(<span class="string">"this is a private function"</span>);</span><br></pre></td></tr></table></figure><p>在实际使用中可能需要用到<strong>多参数构造方法</strong>进行对象的实例化，多参数构造方法实例化类，使用<code>getConstructor</code>和<code>getDeclaredConstructor</code>都可以。<code>getDeclaredConstructor</code>可以获取私有构造方法。和私有属性私有方法访问一样私有构造方法访问需要通过<code>Constructor</code>的<code>setAccessible</code>打开访问权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.example.ReflectIssue"</span>);</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(String.class, String.class);</span><br><span class="line">ReflectIssue reflectIssue2 = (ReflectIssue) constructor.newInstance(<span class="string">"paramA"</span>, <span class="string">"paramB"</span>);</span><br><span class="line"></span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ReflectIssue reflectIssue2 = (ReflectIssue) constructor.newInstance(<span class="string">"paramA"</span>);</span><br></pre></td></tr></table></figure><h3 id="MethodHandle方式"><a href="#MethodHandle方式" class="headerlink" title="MethodHandle方式"></a>MethodHandle方式</h3><p>也可以使用虚拟机提供的<code>MethodHandle</code>通过模拟<strong>字节码层次</strong>的调用来实现反射，需要主意得是，默认所有得方法得第一个参数一定是一个<code>void</code>参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.example.ReflectIssue"</span>);</span><br><span class="line"></span><br><span class="line">MethodType methodType = MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">MethodHandle methodHandle = MethodHandles.lookup().findVirtual(clazz, <span class="string">"reflectPublic"</span>, methodType).bindTo(clazz.newInstance());</span><br><span class="line">methodHandle.invokeExact(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">MethodType methodType = MethodType.methodType(<span class="keyword">void</span>.class, String.class, String.class);</span><br><span class="line">MethodHandle methodHandle = MethodHandles.lookup().findVirtual(clazz, <span class="string">"moreParam"</span>, methodType).bindTo(clazz.newInstance());</span><br><span class="line">methodHandle.invokeExact(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">Method pm = clazz.getDeclaredMethod(<span class="string">"reflectPrivate"</span>, String.class);</span><br><span class="line">pm.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">MethodHandle methodHandle = lookup.unreflect(pm);</span><br><span class="line">methodHandle.invoke(clazz.newInstance(), <span class="string">"a"</span>);</span><br><span class="line">methodHandle.invokeExact((ReflectIssue) clazz.newInstance(), <span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><p><code>MethodHandle</code>服务于<strong>所有<code>java</code>虚拟机上的语言</strong>，<code>Reflection</code>仅仅<strong>服务于<code>java</code>语言</strong>，<code>Reflection</code>在<strong>模拟<code>Java</code>代码层次</strong>的调用，而<code>MethodHandle</code>在<strong>模拟字节码层次</strong>的方法调用。<code>Reflection</code>是<strong>重量级</strong>，而<code>MethodHandle</code>是<strong>轻量级</strong>。<code>MethodHandle</code>可以进行<strong>内联优化</strong>，<code>Reflection</code>完全没有。但<code>JDK8</code>环境下<strong><code>MethodHandles.lookup</code>方法是调用者敏感的</strong>。不同调用者访问权限不同，其结果也不同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反射主要指程序可以访问、检测和修改他本身状态和行为的一种能力，程序在运行时能获取自身的信息；对于任意一个类，都能够获取到这个类的&lt;strong&gt;所有属性和方法&lt;/strong&gt;，对于任意一个对象，都能够调用它的&lt;strong&gt;任意一个方法和属性&lt;/strong&gt;，包括&lt;st
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="反射" scheme="https://yaoyinglong.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析JDK8</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90JDK8/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/HashMap源码分析JDK8/</id>
    <published>2020-09-06T16:00:00.000Z</published>
    <updated>2020-10-09T07:40:44.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><p><code>JDK7</code>中数据结构的存储由<strong>数组</strong>+<strong>链表</strong>的方式，因为数组是一组连续的内存空间，易查询，不易增删，而链表是不连续的内存空间，通过节点相互连接，易删除，不易查询。</p><p><code>JDK8</code>中为了解决<code>hash</code>碰撞过于频繁和链表过长查询效率过低，采用<strong>数组</strong>+<strong>链表</strong>+<strong>红黑树</strong>的存储方式，<strong>当链表长度超过阈值<code>8</code>时，将链表转换为红黑树</strong>。极大的提高了查询效率。</p><p><img src="../../../../../images/Java/JDK8中HashMap存储结构.png" alt="JDK8中HashMap存储结构"></p><p>在<code>JDK8</code>中默认容量，最大容量以及装载因子等默认值未发生变化。但是多了一些树相关的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><code>JDK8</code>中<code>hash</code>方法有略微的简化了，可能是因为引用了<strong>红黑树</strong>，没有必要再对<code>hashCode</code>过于离散化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法略微变化，最大的变化是将获取<code>table</code>的容量的方法<code>tableSizeFor</code>进行了优化，且移位方式由带符号右移变成了无符号又移，在构造方法中就计算好<code>threshold</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><p>在<code>JDK8</code>中<code>table</code>的扩容是在<strong>添加元素后再进行</strong>的。当<code>table</code>为空时通过<code>resize()</code>方法对<code>table</code>进行初始化，以及<code>++size &gt; threshold</code>时通过<code>resize()</code>方法对<code>table</code>的扩容。</p><p>如果新插入的元素的<code>key</code>不存在与链表中，则将新元素插入到对应链表的<strong>尾部</strong>，相对于<code>JDK7</code>的头插法，解决了并发情况下的死循环问题。当插入新元素后链表的长度大于等于8时，会通过<code>treeifyBin</code>方法将链表转换成红黑树。</p><p>如果新插入的元素的key存在于链表中，退出<code>for (int binCount = 0; ; ++binCount)</code>循环，将旧值替换为新的值。其中<code>13、14</code>行干的是同样的事。</p><p>如果<code>table</code>中存的已经是<strong>红黑树</strong>了，就直接进行红黑树的插入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>threshold</code>的值在构造方法中被赋值为<code>table</code>的<code>capacity</code>，但是在<code>resize()</code>方法中被重新设置为<code>capacity * loadFactor</code>。这里对<code>table</code>的扩容以及<code>threshold</code>调整都是通过<strong>向左移位</strong>来完成的。</p><p><code>43</code>行的<code>if</code>判断，主要是为了将老的<code>table</code>中的一个链表按照<strong>高位</strong>和<strong>低位</strong>拆分成两个链表。这个跟JDK是类是的，只不过<code>JDK7</code>是使用的头插法，这里是使用的尾插法，实现方式不一样。高位链表的数据下标按照<code>JDK7</code>的实现方式就为<code>hiHead.hash &amp; (newCap - 1)</code>其实就等于这里的<code>j + oldCap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resize()</code>方法中当table存储的元素是红黑树时，将通过<code>split</code>方法按照<code>hash</code>值得<strong>高低位</strong>将一颗树拆分成两棵树。如果拆分后树得节点个数小于等于<code>UNTREEIFY_THRESHOLD = 6</code>时，将树转换回链表。否正将<code>loHead</code>和<code>hiHead</code>转换成红黑树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据存储结构&quot;&gt;&lt;a href=&quot;#数据存储结构&quot; class=&quot;headerlink&quot; title=&quot;数据存储结构&quot;&gt;&lt;/a&gt;数据存储结构&lt;/h3&gt;&lt;p&gt;&lt;code&gt;JDK7&lt;/code&gt;中数据结构的存储由&lt;strong&gt;数组&lt;/strong&gt;+&lt;strong&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="HashMap" scheme="https://yaoyinglong.github.io/tags/HashMap/"/>
    
      <category term="JDK8" scheme="https://yaoyinglong.github.io/tags/JDK8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析JDK7</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90JDK7/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/HashMap源码分析JDK7/</id>
    <published>2020-09-06T16:00:00.000Z</published>
    <updated>2020-10-09T07:40:59.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ul><li><p><strong>直接定址法</strong>：直接以<strong>关键字<code>k</code></strong>或者<code>k</code>加上某个常数（<code>k+c</code>）作为哈希地址。</p></li><li><p><strong>数字分析法</strong>：提取关键字中<strong>取值比较均匀</strong>的数字作为哈希地址。</p></li><li><p><strong>除留余数法</strong>：用关键字<code>k</code>除以某个<strong>不大于哈希表长度</strong><code>m</code>的数<code>p</code>，将所得<strong>余数</strong>作为哈希表地址。</p></li><li><p><strong>分段叠加法</strong>：按照哈希表<strong>地址位数</strong>将关键字分成<strong>位数相等</strong>的几部分，其中最后一部分可以比较短。然后将这几部分<strong>相加</strong>，<strong>舍弃最高进位后</strong>的结果就是该关键字的哈希地址。</p></li><li><p><strong>平方取中法</strong>：如果关键字各个部分分布都不均匀的话，可以先求出它的<strong>平方值</strong>，然后按照需求<strong>取中间的几位</strong>作为哈希地址。</p></li><li><p><strong>伪随机数法</strong>：采用一个<strong>伪随机数</strong>当作哈希函数</p></li></ul><h3 id="解决碰撞算法"><a href="#解决碰撞算法" class="headerlink" title="解决碰撞算法"></a>解决碰撞算法</h3><p>衡量一个哈希函数的好坏的重要指标就是<strong>发生碰撞的概率</strong>以及<strong>发生碰撞的解决方案</strong>。任何哈希函数<strong>基本都无法彻底避免碰撞</strong>，常见的解决碰撞的方法有以下几种：</p><ul><li><p><strong>开放定址法</strong>：开放定址法就是<strong>一旦发生了冲突，就去寻找下一个空的散列地址</strong>，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p></li><li><p><strong>链地址法</strong>：将哈希表的每个单元作为链表的头结点，所有哈希地址为<code>i</code>的元素构成一个同义词链表。即<strong>发生冲突时就把该关键字链在以该单元为头结点的链表的尾部</strong>。</p></li><li><p><strong>再哈希法</strong>：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</p></li><li><p><strong>建立公共溢出区</strong>：将哈希表分为<strong>基本表</strong>和<strong>溢出表</strong>两部分，发生冲突的元素都放入溢出表中。</p></li></ul><h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><p><code>HashMap</code>是由<strong>数组</strong>和<strong>链表</strong>来实现的对数据的存储，采用<code>Entry</code>数组来存储<code>key-value</code>对，每一个键值对组成了一个<code>Entry</code>实体，<code>Entry</code>类实际上是一个单向的链表结构，它具有<code>Next</code>指针，可以连接下一个<code>Entry</code>实体，<strong>以此来解决<code>Hash</code>冲突</strong>的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashSeed问题"><a href="#hashSeed问题" class="headerlink" title="hashSeed问题"></a><code>hashSeed</code>问题</h3><p>对<code>key</code>的<code>hashCode</code>进行了<strong>二次<code>hash</code></strong>，即hash扰动，<strong>以获得更好的散列值</strong>。这里做二次hash的目的是避免，自定义对象的<code>hashCode</code>方法，算出来的<code>hashCode</code>离散性比较差，从而导致某些链表特别长，而有些特别短，从而导致性能差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到的<code>hashSeed</code>值在<code>HashMap</code>初始化时默认为0，根据源码来看<code>hashSeed</code>可能会在初始化<code>table</code>时通过<code>inflateTable</code>中调用的<code>initHashSeedAsNeeded</code>方法被重新设置。<code>currentAltHashing</code>显然为<code>false</code>，<code>useAltHashing</code>通过下面分析可知其值为也为<code>false</code>，故<code>initHashSeedAsNeeded</code>始终返回<code>false</code>，而<code>hashSeed</code>值始终得不到重新设置，所以其始终为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sun.misc.VM.isBooted()</code>的源码如下，但是实际通过调用发现其返回值为<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> booted = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBooted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> booted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而关于<code>Holder.ALTERNATIVE_HASHING_THRESHOLD</code>，如下所示该值取决于<code>altThreshold</code>的值，实际条用发现该值其实为<code>null</code>，故<code>Holder.ALTERNATIVE_HASHING_THRESHOLD</code>为<code>Integer.MAX_VALUE</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        String altThreshold = java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"jdk.map.althashing.threshold"</span>));</span><br><span class="line">        <span class="keyword">int</span> threshold;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threshold = (<span class="keyword">null</span> != altThreshold) ? Integer.parseInt(altThreshold)</span><br><span class="line">                    : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;</span><br><span class="line">            <span class="keyword">if</span> (threshold == -<span class="number">1</span>) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (threshold &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"value must be positive integer."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException failed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Illegal value for 'jdk.map.althashing.threshold'"</span>, failed);</span><br><span class="line">        &#125;</span><br><span class="line">        ALTERNATIVE_HASHING_THRESHOLD = threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>HashMap</code>的前三个构造方法仅仅是给负载系数<code>loadFactor</code>和数组容量阈值<code>threshold</code>赋值，并不会对数组<code>table</code>进行填充初始化等。<code>HashMap</code>的填充是在真正使用时才会通过<code>inflateTable</code>方法进行填充。如<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>、<code>put(K key, V value)</code>、<code>putAll(Map&lt;? extends K, ? extends V&gt; m)</code>等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="comment">// 用于存储链表数据</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="comment">// 存储KV的数量, 所有链表元素总和</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// threshold=capacity*loadFactor，size大于threshold时会执行resize操作</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 装载因子，用来衡量HashMap满的程度</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 记录当前集合被修改的次数: 添加，删除，为了实现快速失败的机制</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表的初始化"><a href="#表的初始化" class="headerlink" title="表的初始化"></a>表的初始化</h3><p><code>inflateTable</code>方法是为了初始化数组<code>table</code>，当通过构造方法创建<code>HashMap</code>时设置了<code>initialCapacity</code>，但是实际上创建数组时，使用的并不是我们设置<code>initialCapacity</code>来创建的数组的长度，而是通过<code>roundUpToPowerOf2</code>方法对数组容量进行了优化，不管怎么设置<code>initialCapacity</code>大小，数组容量始终是<code>2</code>的幂，且是大于等于<code>threshold</code>的最近的<code>2</code>的幂。也为后续通过<code>indexFor</code>方法为<code>hash</code>值取模起到帮助。</p><p><code>highestOneBit</code>方法是为了获取二进制数据的最高位，低位全部置0，在调用<code>highestOneBit</code>方法之所以传入的是<code>(number - 1) &lt;&lt; 1</code>而不是直接传入<code>number &lt;&lt; 1</code>，因为若<code>number</code>本身就是<code>2</code>的幂，就会造成将数组容量扩大一倍，若<code>number = 16</code>期望返回的是<code>16</code>，若传入<code>number &lt;&lt; 1</code>将放回<code>32</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取大于等于number的最接近的2的幂的数作为数组的容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据二进制的最高位，低位全部置0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><p>当存在相同的<code>key</code>且<code>hash</code>相同时，是替换已有的值，并将旧值返回，而不知直接插入到链表中。之所以即要判断散列值也要判断key，是因为<strong>不同的输入可能会散列成相同的输出</strong>。<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。同一散列函数计算出的散列值相同的现象叫做碰撞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅当 <code>b = 2^n</code> 时位运算才可以转换成取模运算，<code>a % b = a &amp; (b - 1)</code> 。故<code>HashMap</code>才将初始长度设置为 <code>16</code>，且扩容只能是以 <code>2</code> 的倍数扩容。由上面可知数组容量始终是2的幂，故可通过<code>h &amp; (length-1)</code>对<code>hash</code>值取余，从而获取对应的<code>table</code>数组的下标。使用位运算代替取模运算，除了性能之外，还有一个好处就是可以很好的<strong>解决负数</strong>的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>put</code>方法中<code>key</code>为空的情况调用的<code>putForNullKey()</code>方法可知，<code>HashMap</code>中<code>key</code>为空的数据始终是存储到数组<code>table</code>下标为<code>0</code>的链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>table数组的长度并不是初始化后就固定不变了，将链表变得非常长后效率将变得低下，故当元素个数大于等于<code>threshold = capacity * loadFactor</code>时且<strong>该数组下标对应的链表不为空</strong>，就对数组进行扩容。且是按<strong>两倍</strong>进行扩容。并将数据从旧的<code>table</code>中拷贝到新的<code>table</code>中。在<code>createEntry</code>仅仅只有两行代码，实现了数据在链表中的头插法插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>newCapacity</code>容量变化了，故<code>indexFor</code>返回的数据下标将可能变化或变成另一个固定的值，故旧的<code>table</code>中同一个链表的数据拷贝到新的<code>table</code>中<strong>可能会拆分成两个链表</strong>，且将旧表中的数据使用的<strong>头插法</strong>进行拷贝到新的<code>table</code>中的链表中，<strong>链表中的数据将被反序</strong>。而不是直接将数组的前N个元素对拷贝到新的数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>1.8</code>之前，新插入的元素都是放在了<strong>链表的头部</strong>位置，但是这种操作在<strong>高并发</strong>的环境下<strong>容易导致死锁</strong>，所以<code>1.8</code>之后，新插入的元素都放在了<strong>链表的尾部</strong>。</p><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>首先计算<code>hash</code>值通过<code>indexFor()</code>方法得到该<code>key</code>在<code>table</code>中的存储位置，遍历链表，在获取数据时不仅判断了hash值是否相等，还判断了key是否相等，故有时候重写<code>hashCode</code>和<code>equals</code>方法尤为重要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;直接定址法&lt;/strong&gt;：直接以&lt;strong&gt;关键字&lt;code&gt;k&lt;/code&gt;&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="HashMap" scheme="https://yaoyinglong.github.io/tags/HashMap/"/>
    
      <category term="JDK7" scheme="https://yaoyinglong.github.io/tags/JDK7/"/>
    
  </entry>
  
  <entry>
    <title>基础面试题</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/基础面试题/</id>
    <published>2020-09-04T16:00:00.000Z</published>
    <updated>2020-10-12T09:35:39.557Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li>== 与 equals区别</li><li>hashCode和equals</li><li><p>HashMap原理</p><ul><li>如何解决hash冲突</li><li>扩展策略</li></ul></li><li>Lambda表达式</li><li>final有哪些用法：类、方法、变量、提高运行效率、常量在编译时放入常量池</li><li>反射</li><li>动态代理InvocationHandler</li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li>实现方式：Thread、Runnable、Callable（配合FutureTask）、线程池</li><li>线程池的使用：ThreadPoolTaskExecutor</li><li>最大线程数、核心线程数</li><li>拒绝策略：CallerRunsPolicy、AbortPolicy、DiscardPolicy、DiscardOldestPolicy</li><li>sleep与wait区别</li><li>start与run区别</li><li><p>Callable</p></li><li><p>ThreadLocal</p></li><li>synchronized的锁对象是哪些：<ul><li>普通方法是当前实例对象</li><li>同步方法快是括号中配置内容，可以是类Class对象，可以是实例对象</li><li>静态方法是当前类Class对象</li><li>只要不是同一个锁，就可以并行执行，同一个锁，只能串行执行</li></ul></li><li>volatile作用：只能修饰变量，保证可见性，禁止指令重排序，但是不保证原子性。</li><li>volatile和synchronized的区别是什么<ul><li>volatile只能使用在变量上；而synchronized可以在类，变量，方法和代码块上。</li></ul><ol start="2"><li>volatile至保证可见性；synchronized保证原子性与可见性。</li></ol><ul><li>volatile禁用指令重排序；synchronized不会。</li><li>volatile不会造成阻塞；synchronized会。</li></ul></li><li>CAS是什么：通过对指定内存地址的实际值与期望值进行比较，如果相同，则替换成新值，否则不替换。</li><li>多线程请求最终合并结果Future</li><li>Spring中的@Async(value = “cusPool”)注解的使用自定义该注解的线程池</li><li>Spring中的夸线程池数据共享</li></ul><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><ul><li>当实体类中的属性名和表中的字段名不一样<ul><li>sql语句中定义字段名的别名</li><li>通过resultMap来映射字段名和实体类属性名的</li></ul></li><li>#{}与${}的区别<ul><li>#{}是预编译处理，${}是字符串替换。</li><li>#{}可以有效的防止SQL注入，提高系统安全性</li></ul></li><li>like语句怎么写：concat、”%”${value}”%”、在Java代码中添加sql通配符</li><li>动态SQL常用标签：trim | where | set | foreach | if | choose | when | otherwise | bind</li></ul><h3 id="Hystrix使用"><a href="#Hystrix使用" class="headerlink" title="Hystrix使用"></a>Hystrix使用</h3><ul><li>基于编程式</li><li>基于注解</li><li>断路器</li><li>服务限流-降级</li></ul><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul><li>常用注解：@ConfigurationProperties、@Value默认值、@Qualifier作用、@PathVariable</li><li>IOC的原理<ul><li>注入方式：构造器注入、setter方法注入、注解注入</li><li>Bean的生命周期：<ul><li>实例化Bean：通过获取BeanDefinition实例化Bean</li><li>通过BeanWrapper提供的设置属性的接口完成依赖注入</li><li>处理Aware接口</li><li>BeanPostProcessor接口：postProcessBeforeInitialization</li><li>InitializingBean 与 init-method：配置了 init-method 属性，则会自动调用其配置的初始化方法</li><li>BeanPostProcessor接口：postProcessAfterInitialization</li><li>Bean不再使用时：DisposableBean</li><li>配置了destroy-method属性，会自动调用其配置的销毁方法</li></ul></li><li>Bean的几种作用域：singleton、prototype、request、session、global-session</li></ul></li><li>BeanFactory和ApplicationContext有什么区别<ul><li>ApplicationContext是BeanFactory子类、提供了更完整的框架功能</li><li>BeanFactory采用延迟加载调用getBean时才实例化bean、ApplicationContext容器初始化时创建所有Bean，Bean多启动变慢、前者以编程的方式创建、后者以声明的方式</li><li>都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册</li></ul></li><li>SpringAOP的动态代理方式：JDK动态代理、CGLib动态代理<ul><li>切面、连接点、通知、切入点</li></ul></li><li>使用过哪些Aware接口：ApplicationContextAware</li><li>配置参数的注入</li><li>用过哪些Aware 接口 </li><li>三级缓存、循环依赖</li><li>基于Java的配置@Configuration 、@Bean </li><li>BeanFactory和FactoryBean有什么区别<ul><li>BeanFactory是IoC容器或对象工厂，FactoryBean是个Bean，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean</li></ul></li><li>@Autowired是通过什么来查找依赖的</li></ul><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><ul><li>超时时间设置：Feign 的负载均衡底层用的就是 <strong>Ribbon</strong>:ribbon.ConnectTimeout；ribbon.ReadTimeout</li><li>如何启用和禁用对hystrix的使用：feign.hystrix.enabled</li></ul><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ul><li>数据类型：String、hash、list、set、sorted set</li><li>使用Reids做过哪些业务场景</li><li>redis实现分布式锁</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>事务四大特性：原子性、隔离性、一致性、持久性</li><li>隔离级别：<ul><li>脏读：事务B读取事务A还没有提交的数据</li><li>不可重复读：一行被检索两次，并且该行中的值在不同的读取之间不同时</li><li>幻读：当在事务处理过程中执行两个相同的查询，并且第二个查询返回的行集合与第一个查询不同时</li></ul></li><li>索引：<ul><li>B+索引：数据有序,范围查询</li><li>Hash索引：等值查询效率高，不能排序,不能进行范围查询</li><li>聚集索引：数据按索引顺序存储，中子结点存储真实的物理数据</li><li>非聚集索引：存储指向真正数据行的指针</li><li>优缺点：提高查询速度、更新数据时效率低、数据频繁查询建立索引，频繁更改数据不建议使用索引</li></ul></li><li>SQL优化<ul><li>limit优化：先利用ID定位，再分页</li><li>or条件优化，多个or条件可以用union all对结果进行合并</li><li>如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了</li><li>like查询尽量在字段后面使用模糊查询 LIKE ‘zhang%’</li></ul></li><li>索引失效：like查询以%开头、对索引列进行计算、需要类型转换、where中索引列有运算、where中索引列使用了函数、复合索引未用左列字段、有or必全有索引、is null不会用，is not null 会用</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li><p>树的遍历</p></li><li><p>排序算法  快排</p></li><li>并发</li><li>做过的项目，使用到那些技术</li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li>内存<ul><li>程序计数器</li><li>Java虚拟机栈<ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口</li></ul></li><li>本地方法栈</li><li>堆<ul><li>年轻代：Eden、Survivor1、Survivor1</li><li>老年代</li></ul></li><li>方法区（永久代来实现）<ul><li>常量、静态变量、已加载的类信息、编译后的代码、运行时常量池</li></ul></li><li>直接内存</li></ul></li><li>垃圾回收<ul><li>几种回收算法：老年代：标记清除、标记整理；新生代：复制算法</li><li>对象是否存活：引用计数、可达性分析算法</li></ul></li><li>JVisualVM等工具的使用</li></ul><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><ul><li>phase绑定到生命周期</li><li>如何解决依赖冲突</li></ul><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ul><li>MockIto：Spy、Mock、InjectMocks</li><li>PowerMock等测试工具</li><li>单元测试、集成测试</li></ul><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;== 与 equals区别&lt;/li&gt;
&lt;li&gt;hashCode和equals&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HashMap原理&lt;/p&gt;
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/位运算/</id>
    <published>2020-09-02T16:00:00.000Z</published>
    <updated>2020-10-09T07:41:44.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字节、字、位、比特"><a href="#字节、字、位、比特" class="headerlink" title="字节、字、位、比特"></a>字节、字、位、比特</h3><p>1位 = 1比特， 1字节 = 8位，1字=2字节， <code>1Byte=8bit 1B = 8bit</code>， <code>1KB = 1024B</code></p><p><strong>位</strong>：计算机最小存储单位，简记为<strong><code>b</code></strong>，也成为<strong>比特<code>bit</code></strong>，计算机中用<code>0</code>和<code>1</code>来表示数据，一个<code>0</code>或<code>1</code>就代表<code>1</code>位。</p><p><strong>比特（<code>bit</code>）</strong>：也是二进制数字中的位，信息量的最小单位。</p><p><strong>字节（<code>Byte</code>）</strong>：计算存储容量的计量单位，<strong>一个字节等于八位</strong>。习惯上用<strong><code>B</code></strong>表示。</p><p><strong>字</strong>：计算机进行数据处理时，一次存取、加工和传送的数据长度称为字（<code>word</code>），一个字通常由一个或多个（一般是字节的整数位）字节构成。如286微机的字由2个字节组成；486微机的字由4个字节组成。</p><h3 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h3><p>Java中有三个位移运算：</p><ul><li><code>&lt;&lt;：左移</code>：正数高位丢弃，低位补0，负数符号位保持不变</li><li><code>&gt;&gt;：右移</code>：正数低位丢弃，高位补0；负数高位补1</li><li><code>&gt;&gt;&gt;：无符号右移</code>：低位丢弃，高位补0，符号位也会跟着一起移动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">2</span> &lt;&lt; <span class="number">1</span>);     <span class="comment">// 4</span></span><br><span class="line">System.out.println(<span class="number">2</span> &gt;&gt; <span class="number">1</span>);     <span class="comment">// 1</span></span><br><span class="line">System.out.println(<span class="number">2</span> &gt;&gt;&gt; <span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line">System.out.println(-<span class="number">2</span> &lt;&lt; <span class="number">1</span>);    <span class="comment">// -4</span></span><br><span class="line">System.out.println(-<span class="number">2</span> &gt;&gt; <span class="number">1</span>);    <span class="comment">// -1</span></span><br><span class="line">System.out.println(-<span class="number">2</span> &gt;&gt;&gt; <span class="number">1</span>);   <span class="comment">// 2147483647</span></span><br></pre></td></tr></table></figure><h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><p><strong>原码</strong>，利用二进制中的第一位来表示符号位，<code>0</code>表示正数，<code>1</code>表示负数。</p><p><strong>反码</strong>，正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。</p><p><strong>补码</strong>，补码是为了解决反码的问题，<strong>正数的补码和原码、反码一样</strong>，<strong>负数的补码就是反码<code>+1</code></strong>。</p><table><thead><tr><th>十进制</th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td>2</td><td>0000 0010</td><td>0000 0010</td><td>0000 0010</td></tr><tr><td>-2</td><td>1000 0010</td><td>1111 1101</td><td>1111 1110</td></tr></tbody></table><p>计算机在进行运算时是不会去管符号位的，计算时用到的时补码，让符号位也参与运算，最后将运算得到的结果再转换成源码即可。</p><h3 id="负数位移运算"><a href="#负数位移运算" class="headerlink" title="负数位移运算"></a>负数位移运算</h3><p>-2用原码表示为<code>10000000 00000000 00000000 00000010</code></p><p>-2用反码表示为<code>11111111 11111111 11111111 11111101</code></p><p>-2用补码表示为<code>11111111 11111111 11111111 11111110</code></p><p><code>-2 &lt;&lt; 1</code>，表示<code>-2</code>的补码左移一位后为<code>11111111 11111111 11111111 11111100</code>，该补码对应的反码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111111 11111100</span><br><span class="line">- 1</span><br><span class="line">= 11111111 11111111 11111111 11111011</span><br></pre></td></tr></table></figure><p>该反码对应的原码为：符号位不变，其他位取反，为<code>10000000 00000000 00000000 00000100</code>，表示-4。所以<code>-2 &lt;&lt; 1 = -4</code>。</p><p><code>-2 &gt;&gt; 1</code>，表示<code>-2</code>的补码右移一位后（高位补1）为<code>11111111 11111111 11111111 11111111</code>，该补码对应的反码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111111 11111111</span><br><span class="line">- 1</span><br><span class="line">= 11111111 11111111 11111111 11111110</span><br></pre></td></tr></table></figure><p>该反码对应的原码为：符号位不变，其他位取反，为<code>10000000 00000000 00000000 00000001</code>，表示-1。所以<code>-2 &gt;&gt; 1 = -1</code>。</p><h3 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h3><p>在<strong>对补码进行移动时，符号位是固定不动的</strong>，而无符号右移是指在进行移动时，<strong>符号位也会跟着一起移动</strong>。比如<code>-2 &gt;&gt;&gt; 1</code>。</p><p>-2用原码表示为<code>10000000 00000000 00000000 00000010</code></p><p>-2用反码表示为<code>11111111 11111111 11111111 11111101</code></p><p>-2用补码表示为<code>11111111 11111111 11111111 11111110</code></p><p>-2的补码右移1位为：<code>01111111 11111111 11111111 11111111</code></p><p>右移后的补码对应的反码、原码为：<code>01111111 11111111 11111111 11111111</code> ，因为现在的符号位为0表示正数，正数的原、反、补码都相同，所以<code>-2 &gt;&gt;&gt; 1 = 2147483647</code></p><h4 id="（取反运算）"><a href="#（取反运算）" class="headerlink" title="~（取反运算）"></a>~（取反运算）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>：    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span></span><br><span class="line">~<span class="number">5</span>：   <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span> <span class="comment">// 补码形式</span></span><br><span class="line">       <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111001</span> <span class="comment">// 反码</span></span><br><span class="line">       <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000110</span> <span class="comment">// 原码</span></span><br></pre></td></tr></table></figure><h3 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h3><h5 id="交换内容"><a href="#交换内容" class="headerlink" title="交换内容"></a>交换内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &amp; <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="求平均数"><a href="#求平均数" class="headerlink" title="求平均数"></a>求平均数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; y) + ((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取大于等于i的最接近的2的幂"><a href="#获取大于等于i的最接近的2的幂" class="headerlink" title="获取大于等于i的最接近的2的幂"></a>获取大于等于<code>i</code>的最接近的<code>2</code>的幂</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数据二进制的最高位，低位全部置0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字节、字、位、比特&quot;&gt;&lt;a href=&quot;#字节、字、位、比特&quot; class=&quot;headerlink&quot; title=&quot;字节、字、位、比特&quot;&gt;&lt;/a&gt;字节、字、位、比特&lt;/h3&gt;&lt;p&gt;1位 = 1比特， 1字节 = 8位，1字=2字节， &lt;code&gt;1Byte=8bi
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="位运算" scheme="https://yaoyinglong.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized总结</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Synchronized%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Synchronized总结/</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2020-10-16T10:04:32.271Z</updated>
    
    <content type="html"><![CDATA[<p><code>synchronized</code>是<code>Java</code>中解决并发问题的一种最常用最简单的方法 ，它可以确保线程互斥的访问同步代码，保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>Java</code>中使用<code>synchronized</code>可使用在<strong>代码块</strong>和<strong>方法</strong>中，<code>synchronized</code>用的位置不同锁得对象就不同。</p><table><thead><tr><th>分类</th><th>被锁对象</th><th>实例</th></tr></thead><tbody><tr><td>实例方法</td><td>类得实例对象</td><td><code>public synchronized void sync1() {}</code></td></tr><tr><td>静态方法</td><td>类对象</td><td><code>public static synchronized void sync2() {}</code></td></tr><tr><td>实例对象</td><td>类得实例对象</td><td><code>synchronized (this) {}</code></td></tr><tr><td>class对象</td><td>类对象</td><td><code>synchronized (SynchronizedDemo.class) {}</code></td></tr><tr><td>任意实例对象Object</td><td>实例对象Object</td><td><code>String lock = &quot;&quot;; synchronized (lock) {}</code></td></tr></tbody></table><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>JVM</code>是通过进入、退出对象监视器<code>Monitor</code>来实现对方法、同步块的同步，而对象监视器的本质依赖于底层操作系统的互斥锁（Mutex Lock）实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是&lt;code&gt;Java&lt;/code&gt;中解决并发问题的一种最常用最简单的方法 ，它可以确保线程互斥的访问同步代码，保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Synchronized" scheme="https://yaoyinglong.github.io/tags/Synchronized/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal原理</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/ThreadLocal%E5%8E%9F%E7%90%86/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/ThreadLocal原理/</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2020-10-09T07:42:04.521Z</updated>
    
    <content type="html"><![CDATA[<p><code>ThreadLocal</code>是一个<strong>线程内部的存储类</strong>，可以在<strong>指定线程内存储数据</strong>，数据存储以后，只有指定线程可以得到存储数据。提供了线程内存储变量的能力，这些变量不同之处在于<strong>每一个线程读取的变量是对应的互相独立的</strong>。</p><p>单看<code>ThreadLocal</code>类的源码其实很简单，对外提供的方法也很少。复杂的点在于内部静态类<code>ThreadLocalMap</code>。<strong>每个线程</strong>持有一个<code>ThreadLocalMap</code>对象，每一个新的线程<code>Thread</code>都会实例化一个<code>ThreadLocalMap</code>并赋值给成员变量<code>threadLocals</code>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>HASH_INCREMENT</code>魔数的选取与<strong>斐波那契散列</strong>有关，用<code>0x61c88647</code>作为魔数累加为每个<code>ThreadLocal</code>分配各自的ID也就是<code>threadLocalHashCode</code>再与<code>2</code>的幂取模，得到的结果分布很均匀。<code>ThreadLocalMap</code>使用的是<strong>线性探测法</strong>，均匀分布的好处在于很快就能探测到下一个临近的可用<code>slot</code>，从而保证效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initialValue</code>和<code>withInitial</code>两个方法是使用的时候用于重写赋初始值。<code>withInitial</code>通过<code>lambda</code>表达式的方式来重写<code>initialValue</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>ThreadLocal</code>的<code>get</code>源码可以看到，数据是存储在<code>ThreadLocalMap</code>中，而具体的<code>ThreadLocalMap</code>实例并不是<code>ThreadLocal</code>保持，而是保持在每个<code>Thread</code>持有的成员变量<code>threadLocals</code>中。不同的<code>Thread</code>持有不同的<code>ThreadLocalMap</code>实例，因此它们是不存在线程竞争。每次线程死亡，所有<code>map</code>中引用到的对象都会随着这个<code>Thread</code>的死亡而被垃圾收集器一起收集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set</code>方法跟上面的<code>setInitialValue</code>差不多。如果当前线程的<code>ThreadLocalMap</code>为空就创建一个新的<code>ThreadLocalMap</code>并赋值给当前线程的成员变量<code>threadLocals</code>，否则<code>set</code>当前值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类为每个<code>Thread</code>都维护了一个<strong>数组<code>table</code></strong>，<code>ThreadLocal</code>确定了一个数组下标，而这个下标就是<code>value</code>存储的对应位置。</p><p>实例化<code>ThreadLocalMap</code>时创建了一个<strong>初始长度</strong>为<code>16</code>的<code>Entry</code>数组，且数组长度始终为<strong><code>2</code>的幂</strong>。与<code>HashMap</code>类似通过<code>hashCode</code>与<code>length</code>位运算确定数组下标。结合此处的构造方法可以理解成每个线程<code>Thread</code>都持有一个<code>Entry</code>型的数组<code>table</code>，而一切的读取过程都是通过操作这个数组<code>table</code>完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p>为了解决内存回收，这里的<code>Entry</code>继承了<code>WeakReference</code>弱引用。<code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<strong><code>ThreadLocal</code>没有外部强引用引用他</strong>，系统<code>gc</code>的时候，该<code>ThreadLocal</code>势必会被回收。</p><p><strong><code>Entry</code>的<code>key</code>是对<code>ThreadLocal</code>的弱引用</strong>，当抛弃掉<code>ThreadLocal</code>对象时，垃圾收集器会忽略这个<code>key</code>的引用而清理掉<code>ThreadLocal</code>对象， 防止了内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i</code>是通过对<code>threadLocalHashCode</code>的取模得到数组的下标，将构建的<code>Entry</code>放到<code>table</code>数组中。并设置<code>threshold</code>。<code>ThreadLocalMap</code>有两个方法用于得到<strong>上一个<code>/</code>下一个</strong>索引，从<code>nextIndex</code>和<code>prevIndex</code>两个方法的实现上来看，<code>Entry</code>数组在程序逻辑上是作为一个<strong>环形</strong>存在的，这也是由于<strong><code>ThreadLocalMap</code>是使用线性探测法来解决散列冲突</strong>。</p><p><strong>线性探测法</strong>：往哈希表中插入数据时，通过哈希函数计算该值的哈希地址，若发现该位置已有数据，则找紧跟着的下一个位置，若无数据则插入，若有数据则继续探测下一个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getEntry</code>方法在<code>ThreadLocal</code>中的<code>get</code>方法中被调用，首先从<code>ThreadLocal</code>的<strong>直接索引位置</strong>获取<code>Entry e</code>，若<strong><code>e</code>不为<code>null</code>并且<code>key</code>相同</strong>则返回<code>e</code>，若<code>e</code>为<code>null</code>直接返回<code>null</code>，若<strong><code>e</code>不为<code>null</code>且<code>key</code>不一致</strong>则向<strong>下一个位置查询</strong>，如果下一个位置的<code>key</code>和当前需要查询的<code>key</code>相等，则返回对应的<code>Entry</code>，否则若<code>key</code>值为<code>null</code>，则<strong>擦除该位置的<code>Entry</code></strong>，返回<code>null</code>，否则继续向下一个位置查询，直到<code>e</code>为<code>null</code>还没有找到对应的<code>Entry</code>则返回<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于使用的是线性探索，往后还可能找到目标Entry</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>Entry</code>的<code>key</code>为空时通过<code>expungeStaleEntry</code>方法<strong>擦除该位置的<code>Entry</code></strong>。防止该<code>Entry</code>的<code>value</code>被一直强引用从而导致内存泄露。<code>ThreadLocal</code>引用示意图如下，实线表示强引用，虚线表示弱引用</p><p><img src="../../../../../images/Java/ThreadLocal引用示意图.png" alt="ThreadLocal引用示意图"></p><p>从图中可看到，虽然<code>Entry</code>的<code>key</code>是<code>ThreadLocal</code>的弱引用，<code>key</code>在其他地方没有强引用时即会被回收，但是<code>Entry</code>的<code>value</code>会一直被引用，不能得到释放。当然若线程执行结束<code>threadLocal</code>和<code>threadRef</code>会断掉，因此<code>threadLocal</code>、<code>threadLocalMap</code>、<code>entry</code>都会被回收，但实际中为了<strong>线程复用</strong>我们会使用线程池，<code>threadRef</code>可能永远不会断掉，可能导致<code>value</code>永远无法回收。所以这里是直接将<code>table</code>的<code>Entry</code>和<code>Entry</code>的<code>value</code>的引用置空。</p><p><code>for</code>循环是往后环形查找，直到遇到<code>table[i] == null</code>时结束，<code>k == null</code>表示再次遇到脏<code>Entry</code>同样将其清理掉。<code>k != null</code>且<code>h != i</code>表示处理<code>rehash</code>的情况，将起挪到<strong><code>hash</code>表</strong>下标为<code>h</code>开始的第一个为空的位置。</p><p>注：脏<code>Entry</code>仅仅是<code>key</code>为<code>null</code>，而不是通过<strong><code>table[i]</code></strong>获取的<code>Entry</code>为空。这也是为什么遇到<code>tab[i] == null</code>就退出搜索了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 对于还没有被回收的情况，需要做一次rehash。</span></span><br><span class="line"><span class="comment">             * 如果对应的ThreadLocal的ID对len取模出来的索引h不为当前位置i，</span></span><br><span class="line"><span class="comment">             * 则从h向后线性探测到第一个空的slot，把当前的entry给挪过去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * ThreadLocalMap因为使用了弱引用，所以其实每个slot的状态有三种也即</span></span><br><span class="line"><span class="comment">                 * 有效（value未回收），无效（value已回收），空（entry==null）。</span></span><br><span class="line"><span class="comment">                 * 正是因为ThreadLocalMap的entry有三种状态，所以不能完全套高德纳原书的R算法。</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 因为expungeStaleEntry函数在扫描过程中还会对无效slot清理将之转为空slot，</span></span><br><span class="line"><span class="comment">                 * 如果直接套用R算法，可能会出现具有相同哈希值的entry之间断开（中间有空entry）。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若当前<code>table[i] != null</code>说明<code>hash</code>冲突就<strong>需要向后环形查找</strong>，若查找过程中遇到脏<code>entry</code>就通过<code>replaceStaleEntry</code>进行处理；若当前<code>table[i] == null</code>说明新的<code>entry</code>可以直接插入，但是插入后会调用<code>cleanSomeSlots</code>方法<strong>检测并清除脏<code>entry</code></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换失效的entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>replaceStaleEntry</code>并不仅仅局限于处理当前已知的<strong>脏<code>Entry</code></strong>，首先通过<code>for</code>循环<strong>向前</strong>找到<strong>第一个</strong>脏<code>Entry</code>，这里的第一个是指向前查找遇到的最靠近<code>table[i] == null</code>的<code>Entry</code>，它认为在出现脏<code>Entry</code>的<strong>相邻位置</strong>也有很<strong>大概率</strong>出现脏<code>Entry</code>，为了一次处理到位，就需要向前环形搜索，找到前面的脏<code>Entry</code>。</p><p>根据向前搜索中是否有脏Entry以及在for循环向后环形查找中是否找到可覆盖的Entry，，最后使用<code>cleanSomeSlots</code>方法从<code>slotToExpunge</code>为起点开始进行清理脏<code>Entry</code>，可分四种情况：</p><ul><li>前向<code>有</code>脏<code>Entry</code>，向后环形查找<strong>找到</strong>可覆盖的<code>Entry</code></li></ul><p><img src="../../../../../images/Java/环形查找情况1.png" alt></p><ul><li>前向<strong>有</strong>脏<code>Entry</code>，向后环形查找<strong>未找到</strong>可覆盖的<code>Entry</code></li></ul><p><img src="../../../../../images/Java/环形查找情况2.png" alt></p><ul><li>前向<strong>无</strong>脏<code>Entry</code>，向后环形查找<strong>找到</strong>可覆盖的<code>Entry</code></li></ul><p><img src="../../../../../images/Java/环形查找情况3.png" alt></p><ul><li>前向<strong>无</strong>脏<code>Entry</code>，向后环形查找<strong>未找到</strong>可覆盖的<code>Entry</code></li></ul><p><img src="../../../../../images/Java/环形查找情况4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前扫描，查找最前的一个无效slot</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向后遍历table</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果在整个扫描过程中（包括函数一开始的向前扫描与i之前的向后扫描）</span></span><br><span class="line"><span class="comment">             * 找到了之前的无效slot则以那个位置作为清理的起点，否则以当前的i作为清理起点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 从slotToExpunge开始做一次连续段的清理，再做一次启发式清理</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key在table中不存在，则在原地放一个即可</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在探测过程中如果发现任何无效slot，则做一次清理（连续段清理+启发式清理）</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>n</code>主要用于<strong>扫描次数控制</strong>，若没有遇到脏<code>Entry</code>，整个扫描过程持续<code>log2(n)</code>次，若遇到脏<code>Entry</code>将<code>n</code>重置为当前hash表的长度，再扫描<code>log2(n)</code>次，注意这里的<code>nextIndex</code>获取的数组下标是一个环。遇到脏<code>Entry</code>时通过<code>expungeStaleEntry</code>清理脏<code>Entry</code>。</p><p><img src="../../../../../images/Java/cleanSomeSlots执行情景图.png" alt="cleanSomeSlots执行情景图"></p><p>若当前<code>n</code>等于<code>hash</code>表的<code>size</code>即<code>n=10</code>，<code>i=1</code>,在第一趟搜索过程中通过<code>nextIndex</code>，<code>i</code>指向索引为<code>2</code>的位置，此时<code>table[2]</code>为<code>null</code>，则第一趟未发现脏<code>Entry</code>，进行第二趟搜索。</p><p>第二趟搜索先通过<code>nextIndex</code>方法，<code>table[3] != null</code>找到脏Entry，<strong>先将<code>n</code>置为哈希表的长度<code>len</code>，然后继续调用<code>expungeStaleEntry</code>方法</strong>，将当前索引为<code>3</code>的脏<code>Entry</code>给清除掉，令<code>value</code>为<code>null</code>且<code>table[3]</code>为<code>null</code>，但<strong>该方法会继续往后环形搜索</strong>，往后发现索引<code>4、5</code>的位置的<code>Entry</code>同样为脏<code>Entry</code>，索引<code>6</code>的<code>Entry</code>不是脏<code>Entry</code>保持不变，直至<code>i=7</code>时此处<code>table[7]</code>为<code>null</code>，返回索引<code>7</code>。</p><p>继续向后环形搜索，直到在整个搜索范围里都未发现脏<code>Entry</code>，<code>cleanSomeSlot</code>方法执行结束退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启发式地清理slot</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 扩大扫描控制因子</span></span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 清理一个连续段</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用set方法时发现需要扩容时，会调用<code>rehash</code>方法对<code>table</code>进行扩容。扩容前回先清理掉hash表中所有的脏<code>Entry</code>，然后在进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做一次全量清理</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 因为做了一次清理，所以size很可能会变小。</span></span><br><span class="line"><span class="comment">     * ThreadLocalMap这里的实现是调低阈值来判断是否需要扩容，</span></span><br><span class="line"><span class="comment">     * threshold默认为len*2/3，所以这里的threshold - threshold / 4相当于len/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 线性探测来存放Entry</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>threadLocal.remove</code>方法时候，实际上会调用<code>threadLocalMap</code>的<code>remove</code>方法，当遇到了<code>key</code>为<code>null</code>的脏<code>entry</code>的时候，也会调用<code>expungeStaleEntry</code>清理掉脏<code>entry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>threadLocal</code>的<strong>生命周期</strong>里，针对<code>threadLocal</code>存在的<strong>内存泄漏</strong>的问题，都会通过<code>expungeStaleEntry</code>，<code>cleanSomeSlots</code>,<code>replaceStaleEntry</code>这三个方法清理掉<code>key</code>为<code>null</code>的脏<code>entry</code>。</p><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InheritableThreadLocal</code>提供了一种<strong>父子</strong>线程之间的<strong>数据共享机制</strong>，在线程初始化<code>init</code>时，会调用<code>ThreadLocal</code>的<code>createInheritedMap</code>从父线程的<code>inheritableThreadLocals</code>中把<strong>有效的<code>entry</code></strong>都拷过来。<code>InheritableThreadLocal</code>只是在<strong>子线程创建时</strong>会去拷一份父线程的<code>inheritableThreadLocals</code>。若父线程是在子线程创建后再<code>set</code>某个<code>InheritableThreadLocal</code>对象的值，对子线程是<strong>不可见</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在使用<code>ThreadLocal</code>时很可能出现<strong>数据错乱</strong>，这是由于通过线程池时，<strong>线程池对线程进行了复用</strong>，从而导致<code>ThreadLocal</code>中的数据串了。<strong>用完及时清理数据</strong>。在<code>Web</code>环境中可以自定义<code>HandlerInterceptorAdapter</code>，在<code>preHandler</code>中去设置<code>ThreadLocal</code>，在<code>afterCompletion</code>时区<code>remove</code>。</p><h4 id="重写initialValue方法"><a href="#重写initialValue方法" class="headerlink" title="重写initialValue方法"></a>重写initialValue方法</h4><p>重写<code>initialValue</code>赋初值方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = ThreadLocal.withInitial(() -&gt; Thread.currentThread().getId());</span><br></pre></td></tr></table></figure><h4 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h4><p><code>MDC</code>主要是用于将某个或某些所有日志中都需要打印的字符串设置于<code>MDC</code>中，这样就不需要每次打印日志时专门写出来，这里也是通过<code>ThreadLocal</code>来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MDCAdapter mdcAdapter;</span><br><span class="line">mdcAdapter.put(key, val);</span><br><span class="line">mdcAdapter.get(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jMDCAdapter</span> <span class="keyword">implements</span> <span class="title">MDCAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Log4jMDCAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String val)</span> </span>&#123;</span><br><span class="line">        ThreadContext.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>DefaultThreadContextMap</code>可以看到<code>localMap</code>其实就是一个<code>ThreadLocal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadContextMap contextMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        contextMap.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadContextMap</span> <span class="keyword">implements</span> <span class="title">ThreadContextMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INHERITABLE_MAP = <span class="string">"isThreadContextMapInheritable"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; localMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadContextMap</span><span class="params">(<span class="keyword">boolean</span> useMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.useMap = useMap;</span><br><span class="line">        <span class="keyword">this</span>.localMap = createThreadLocalMap(useMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; createThreadLocalMap(<span class="keyword">final</span> <span class="keyword">boolean</span> isMapEnabled) &#123;</span><br><span class="line">        PropertiesUtil managerProps = PropertiesUtil.getProperties();</span><br><span class="line">        <span class="keyword">boolean</span> inheritable = managerProps.getBooleanProperty(<span class="string">"isThreadContextMapInheritable"</span>);</span><br><span class="line">        <span class="keyword">return</span> (ThreadLocal)(inheritable ? <span class="keyword">new</span> InheritableThreadLocal&lt;Map&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Map&lt;String, String&gt; <span class="title">childValue</span><span class="params">(Map&lt;String, String&gt; parentValue)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> parentValue != <span class="keyword">null</span> &amp;&amp; isMapEnabled ? Collections.unmodifiableMap(<span class="keyword">new</span> HashMap(parentValue)) : <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; : <span class="keyword">new</span> ThreadLocal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.useMap) &#123;</span><br><span class="line">            Map&lt;String, String&gt; map = (Map)<span class="keyword">this</span>.localMap.get();</span><br><span class="line">            Map&lt;String, String&gt; map = map == <span class="keyword">null</span> ? <span class="keyword">new</span> HashMap() : <span class="keyword">new</span> HashMap(map);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">this</span>.localMap.set(Collections.unmodifiableMap(map));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据库连接、-Session-管理"><a href="#数据库连接、-Session-管理" class="headerlink" title="数据库连接、 Session 管理"></a>数据库连接、 Session 管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用ThreadLocal代替锁"><a href="#使用ThreadLocal代替锁" class="headerlink" title="使用ThreadLocal代替锁"></a>使用ThreadLocal代替锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HashSet&lt;Val&lt;Integer&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addSet</span><span class="params">(Val&lt;Integer&gt; val)</span> </span>&#123;</span><br><span class="line">    set.add(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Val&lt;Integer&gt;&gt; c = <span class="keyword">new</span> ThreadLocal&lt;Val&lt;Integer&gt;&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Val&lt;Integer&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Val&lt;Integer&gt; v = <span class="keyword">new</span> Val&lt;Integer&gt;();</span><br><span class="line">        v.set(<span class="number">0</span>);</span><br><span class="line">        addSet(v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 统计结果</span></span><br><span class="line">set.stream().map(Val::get).reduce((a, sum) -&gt; a + sum).get()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Val</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自实现"><a href="#自实现" class="headerlink" title="自实现"></a>自实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger atomic = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadLocalHash = atomic.addAndGet(<span class="number">0x61c88647</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;Thread, HashMap&lt;Integer, Object&gt;&gt; threadLocalHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> HashMap&lt;Integer, Object&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (!threadLocalHashMap.containsKey(thread)) &#123;</span><br><span class="line">            threadLocalHashMap.put(thread, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocalHashMap.get(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Object&gt; map = getMap ();</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(<span class="keyword">this</span>.threadLocalHash)) &#123;</span><br><span class="line">            map.put(<span class="keyword">this</span>.threadLocalHash, initialValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) map.get(<span class="keyword">this</span>.threadLocalHash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Object&gt; map = getMap ();</span><br><span class="line">        map.put(<span class="keyword">this</span>.threadLocalHash, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与Synchronized的区别"><a href="#与Synchronized的区别" class="headerlink" title="与Synchronized的区别"></a>与Synchronized的区别</h3><p>相同：都是为了解决多线程中相同变量的访问冲突问题，</p><p>不同：<code>Synchronized</code>同步机制是通过以<strong>时间换空间</strong>的方式控制线程访问共享对象的顺序，而<code>threadLocal</code>是以<strong>空间换时间</strong>为每一个线程分配一个该对象各用各的互不影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;是一个&lt;strong&gt;线程内部的存储类&lt;/strong&gt;，可以在&lt;strong&gt;指定线程内存储数据&lt;/strong&gt;，数据存储以后，只有指定线程可以得到存储数据。提供了线程内存储变量的能力，这些变量不同之处在于&lt;strong&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ThreadLocal" scheme="https://yaoyinglong.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概览</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/设计模式概览/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-08-25T08:44:58.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p><code>23</code>种设计模式大体上可以分为三类：</p><ul><li><strong>创建型模式</strong>（<code>5</code>个）：对象实例化的模式，用于<strong>解耦对象的实例化过程</strong>；</li><li><strong>结构型模式</strong>（<code>7</code>个）：把类或对象结合在一起<strong>形成一个更大的结构</strong>；</li><li><strong>行为型模式</strong>（<code>11</code>个）：类和对象<strong>如何交互</strong>，及<strong>划分职责和算法</strong>；</li></ul><p><img src="../../../../images/设计模式/设计模式分类.png" alt="设计模式分类"></p><h3 id="各种模式的关键点"><a href="#各种模式的关键点" class="headerlink" title="各种模式的关键点"></a>各种模式的关键点</h3><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><p><strong>单例模式</strong>：某个类只能有一个实例，提供一个全局的访问点。</p><p><strong>简单工厂</strong>：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</p><p><strong>工厂方法</strong>：定义一个创建对象的接口，让子类决定实例化那个类。</p><p><strong>抽象工厂</strong>：创建相关或依赖对象的家族，而无需明确指定具体类。</p><p><strong>建造者模式</strong>：封装一个复杂对象的构建过程，并可以按步骤构造。</p><p><strong>原型模式</strong>：通过复制现有的实例来创建新的实例。</p><h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><p><strong>适配器模式</strong>：将一个类的方法接口转换成客户希望的另外一个接口。</p><p><strong>组合模式</strong>：将对象组合成树形结构以表示“”部分-整体“”的层次结构。</p><p><strong>装饰模式</strong>：动态的给对象添加新的功能。</p><p><strong>代理模式</strong>：为其他对象提供一个代理以便控制这个对象的访问。</p><p><strong>亨元模式</strong>：通过共享技术来有效的支持大量细粒度的对象。</p><p><strong>外观模式</strong>：对外提供一个统一的方法，来访问子系统中的一群接口。</p><p><strong>桥接模式</strong>：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</p><h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><p><strong>模板模式</strong>：定义一个算法结构，而将一些步骤延迟到子类实现。</p><p><strong>解释器模式</strong>：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</p><p><strong>策略模式</strong>：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</p><p><strong>状态模式</strong>：允许一个对象在其对象内部状态改变时改变它的行为。</p><p><strong>观察者模式</strong>：对象间的一对多的依赖关系。</p><p><strong>备忘录模式</strong>：在不破坏封装的前提下，保持对象的内部状态。</p><p><strong>中介者模式</strong>：用一个中介对象来封装一系列的对象交互。</p><p><strong>命令模式</strong>：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</p><p><strong>访问者模式</strong>：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</p><p><strong>责任链模式</strong>：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</p><p><strong>迭代器模式</strong>：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</p><h3 id="23种设计模式间的关系"><a href="#23种设计模式间的关系" class="headerlink" title="23种设计模式间的关系"></a>23种设计模式间的关系</h3><p><img src="../../../../images/设计模式/23种设计模式关系图.png" alt="23种设计模式关系图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设计模式分类&quot;&gt;&lt;a href=&quot;#设计模式分类&quot; class=&quot;headerlink&quot; title=&quot;设计模式分类&quot;&gt;&lt;/a&gt;设计模式分类&lt;/h3&gt;&lt;p&gt;&lt;code&gt;23&lt;/code&gt;种设计模式大体上可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/MySQL基础/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-08-25T09:25:46.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务基本特征ACID"><a href="#事务基本特征ACID" class="headerlink" title="事务基本特征ACID"></a>事务基本特征ACID</h3><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事务基本特征ACID&quot;&gt;&lt;a href=&quot;#事务基本特征ACID&quot; class=&quot;headerlink&quot; title=&quot;事务基本特征ACID&quot;&gt;&lt;/a&gt;事务基本特征ACID&lt;/h3&gt;&lt;h3 id=&quot;四种隔离级别&quot;&gt;&lt;a href=&quot;#四种隔离级别&quot; class=&quot;
      
    
    </summary>
    
      <category term="DB" scheme="https://yaoyinglong.github.io/categories/DB/"/>
    
    
      <category term="MySQL" scheme="https://yaoyinglong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JVM整体概览</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/JVM%E6%95%B4%E4%BD%93%E6%A6%82%E8%A7%88/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/JVM整体概览/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-08-25T10:18:18.327Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../images/JVM/JVM整体概览.png" alt="JVM整体概览"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../../../images/JVM/JVM整体概览.png&quot; alt=&quot;JVM整体概览&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://yaoyinglong.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring知识点</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/Spring/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/Spring/Spring知识点/</id>
    <published>2020-08-23T16:00:00.000Z</published>
    <updated>2020-08-24T12:54:23.929Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../images/Spring/Spring知识点概览.png" alt="Spring知识点概览"></p><p><img src="../../../../images/Spring/Spring知识点详情.png" alt="Spring知识点详情"></p><p><img src="../../../../images/Spring/Spring生命周期.png" alt="Spring生命周期"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../../../images/Spring/Spring知识点概览.png&quot; alt=&quot;Spring知识点概览&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../images/Spring/Spring知识点详情.png&quot; alt=&quot;
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>IoC容器</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/Spring/IoC%E5%AE%B9%E5%99%A8/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/Spring/IoC容器/</id>
    <published>2020-08-15T16:00:00.000Z</published>
    <updated>2020-08-18T14:02:41.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IoC容器概述"><a href="#IoC容器概述" class="headerlink" title="IoC容器概述"></a>IoC容器概述</h3><p><strong>依赖反转</strong>的概念：<strong>依赖对象的获得被反转了</strong>，基于该结论为控制反转创造了一个更好听的名字：<strong>依赖注入</strong>。依赖控制反转的实现方式有很多种，<code>Spring</code>中<code>IoC</code>容器是实现该模式的载体，它可以在<strong>对象生成</strong>或<strong>初始化</strong>时<strong>直接将数据注入到对象中</strong>，也可以通过将<strong>对象引用注入到对象数据域中</strong>的方式来注入对方法调用的依赖。这种<strong>依赖注入是可以递归的，对象被逐层注入</strong>。</p><p>应用控制反转后，当对象被创建时，由<strong>一个调用系统内的所有对象的外界实体将其所依赖的对象的引用传递给它</strong>，控制反转是关于<strong>一个对象如何获取它所依赖的对象的引用</strong>，<strong>反转指的是责任的反转</strong>。</p><p>通过使用<code>IoC</code>容器，对象的<strong>依赖关系的管理被反转了</strong>或者说是把<strong>资源的获取方式反转了</strong>，对象之间的相互依赖关系由<code>IoC</code>容器进行管理，并由<code>IoC</code>容器完成对象的注入。注入的主要实现方式有：<strong>接口注入</strong>、<strong><code>setter</code>注入</strong>、<strong>构造器注入</strong>。<code>Spring</code>中<code>setter</code>注入和构造器注入是主要的注入方式，使用<code>Spring</code>时<code>setter</code>注入是常见的注入方式。且<code>Spring</code>还提<strong>供了对特定依赖的检查</strong>。</p><p><code>Spring IoC</code>提供了一个基本的<code>JavaBean</code>容器，通过<code>IoC</code>容器管理依赖关系，并通过依赖注入和<code>AOP</code>切面增强了为<code>JavaBean</code>这样的<code>POJO</code>对象赋予事务管理、生命周期管理等基本功能。</p><h3 id="IoC容器的设计与实现"><a href="#IoC容器的设计与实现" class="headerlink" title="IoC容器的设计与实现"></a>IoC容器的设计与实现</h3><p><code>Spring IoC</code>容器的设计中，实现了<code>BeanFactory</code>接口的<strong>简单容器系列</strong>，该系列容器只实现了容器的<strong>最基本的功能</strong>；和<strong>容器的高级形态<code>ApplicationContext</code>应用上下文</strong>，两个主要的容器系列。<code>BeanFactory</code>是<code>IoC</code>容器具体实现的<strong>基本功能规范的设计表现</strong>。</p><p>对于使用者来说，可将<code>BeanFactory</code>和<code>ApplicationContext</code>看成容器的具体表现形式。通常所说的IoC容器实际上代表的是一系列功能各异的容器产品。Spring中有各种各样的<code>IoC</code>容器的实现。</p><p>在Spring提供的基本的<code>IoC</code>容器的接口定义和实现的基础上，Spring通过定义<code>BeanDefinition</code>来管理基本的Spring的应用中的<strong>各种对象以及它们之间的相互依赖关系</strong>。<strong><code>BeanDefinition</code>抽象了对Bean的定义</strong>，<strong>是让容器起作用的主要数据类型</strong>。对于<code>IoC</code>容器来说，<code>BeanDefinition</code>就是对<strong>依赖反转模式</strong>中管理的<strong>对象依赖关系的数据抽象</strong>，也是容器<strong>实现依赖反转功能的核心数据结构</strong>，<strong>依赖反转功能都是围绕对<code>BeanDefinition</code>的处理来完成</strong>的。</p><p><img src="../../../../../images/Spring/IoC容器接口设计图.png" alt="IoC容器接口设计图"></p><p><code>BeanFactory</code>接口定义了基本的<code>IoC</code>容器规范，从接口<code>BeanFactory</code>到<code>HierarchicalBeanFactory</code>再到<code>ConfigurableBeanFactory</code>是一条<strong>主要</strong>的<code>BeanFactory</code>设计路径。<code>HierarchicalBeanFactory</code>接口增加了<code>getParentBeanFactory()</code>的接口功能，使<code>BeanFactory</code>具备了<strong>双亲<code>IoC</code>容器的管理功能</strong>。<code>ConfigurableBeanFactory</code>接口主要定义了一些对<code>BeanFactory</code>的<strong>配置功能</strong>。可<strong>设置双亲<code>IoC</code>容器</strong>，<strong>配置<code>Bean</code>后置处理器</strong>等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;IoC容器概述&quot;&gt;&lt;a href=&quot;#IoC容器概述&quot; class=&quot;headerlink&quot; title=&quot;IoC容器概述&quot;&gt;&lt;/a&gt;IoC容器概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;依赖反转&lt;/strong&gt;的概念：&lt;strong&gt;依赖对象的获得被反转了&lt;/stro
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
      <category term="IoC" scheme="https://yaoyinglong.github.io/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>Spring整体架构</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/Spring/Spring整体架构/</id>
    <published>2020-08-11T16:00:00.000Z</published>
    <updated>2020-08-13T14:12:06.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring子项目"><a href="#Spring子项目" class="headerlink" title="Spring子项目"></a>Spring子项目</h3><h4 id="Spring-Framework（core）"><a href="#Spring-Framework（core）" class="headerlink" title="Spring Framework（core）"></a>Spring Framework（core）</h4><p>包含一系列<code>Ioc</code>容器的设计，提供了<strong>依赖反转</strong>的实现，集成了<code>AOP</code>，还包含了<code>MVC</code>、<code>JDBC</code>、<strong>事务处理</strong>模块的实现。</p><h4 id="Spring-Web-Flow"><a href="#Spring-Web-Flow" class="headerlink" title="Spring Web Flow"></a>Spring Web Flow</h4><p><strong>定义了一种特定的语言来描述工作流</strong>，同时高级的工作流控制引擎可以管理会话状态，支持<code>AJAX</code>来构建丰富的客户端体验，并提供<code>JSF</code>支持。其实际上是构建在<code>Spring MVC</code>的基础上的，相对于<code>Spring Framework（core）</code>独立发展的。</p><h4 id="Spring-BlazeDS-Integration"><a href="#Spring-BlazeDS-Integration" class="headerlink" title="Spring BlazeDS Integration"></a>Spring BlazeDS Integration</h4><p>提供<code>Spring</code>于<code>Adobe Flex</code>技术集成的模块。</p><h4 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h4><p>基于<code>Spring</code>的<strong>认证</strong>和<strong>安全工具</strong>。</p><h4 id="Spring-Security-OAuth"><a href="#Spring-Security-OAuth" class="headerlink" title="Spring Security OAuth"></a>Spring Security OAuth</h4><p>为OAuth在Spring上集成提供支持，OAuth是一个第三方模块，提供一个开放协议的实现，通过改协议，前端桌面应用可以对Web应用进行简单而标准的安全调用。</p><h4 id="Spring-Dynamic-Modules"><a href="#Spring-Dynamic-Modules" class="headerlink" title="Spring Dynamic Modules"></a>Spring Dynamic Modules</h4><p>可以让Spring运行在OSGi平台上。</p><h4 id="Spring-Batch"><a href="#Spring-Batch" class="headerlink" title="Spring Batch"></a>Spring Batch</h4><p>提供构建<strong>批处理应用</strong>和<strong>自动化操作</strong>的框架。</p><h4 id="Spring-Integration"><a href="#Spring-Integration" class="headerlink" title="Spring Integration"></a>Spring Integration</h4><p>为企业数据集成提供了各种适配器，通过这些适配器来转换各种消息格式，并帮助Spring应用完成与企业应用系统的集成。</p><h4 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h4><p>为Spring应用更好地使用基于AMQP（高级消息队列协议）的消息服务而开发。</p><h4 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h4><p>为Spring应用提供使用费关系型数据的能力。</p><h3 id="Spring设计目标"><a href="#Spring设计目标" class="headerlink" title="Spring设计目标"></a>Spring设计目标</h3><p>​    为开发者提供的是一个<strong>一站式的轻量级应用开发框架</strong>。其抽象了许多应用开发中遇到的共性问题。支持<code>POJO</code>和使用<code>JavaBean</code>的开发方式，使应用<strong>面向接口开发</strong>，充分支持<code>OO</code>（面向对象）的设计方法，使<strong>开发的入门</strong>、<strong>测试</strong>、<strong>应用部署都得到简化</strong>。</p><p>​    通过使用<code>Spring</code>的<code>IoC</code>容器，可以对应用开发中复杂的对象耦合关系实现一个<strong>文本化</strong>、<strong>外部化</strong>的工作，即通过一个或几个<code>XML</code>文件，可以方便地对应用的耦合关系进行浏览、修改和维护，很大程度上简化应用开发。通过<code>Ioc</code>容器实现的依赖反转，把<strong>依赖关系的管理从<code>Java</code>对象中解放出来</strong>，交给IoC容器来完成，从而完成了对象之间的解耦，将原来的<strong>对象—对象</strong>的关系，转化为<strong>对象—IoC容器—对象</strong>的关系。</p><p>​    Spring即作为用户和机器之间的平台，同时也为用户使用底层的机器资源提供了应用开发环境。Spring关系的是一些企业应用资源的使用，如数据持久化、数据集成、事务管理、消息中间件、Web2.0应用、分布式计算等对高效可靠处理企业数据方法的技术抽象。</p><p>​    Spring一方面通过IoC容器来管理POJO对象，以及它们相互之间的耦合关系，使企业的信息、数据、资源可以用简单得Java语言来抽象和描述；另一方面可通过AOP以动态和非侵入式的方式来增强服务的功能。</p><p>​    IoC容器和AOP模块是平台实现的核心，代表了最为基础的底层抽象，同时也是Spring其他模块实现的基础。</p><h3 id="Spring整体架构"><a href="#Spring整体架构" class="headerlink" title="Spring整体架构"></a>Spring整体架构</h3><h4 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h4><p>​    包含了最基本的<code>IoC</code>容器<code>BeanFactory</code>接口的实现，也提供了一系列这个接口的实现。如：<code>XmlBeanFactory</code>、<code>SimpleJndiBeanFactory</code>、<code>StaticListableBeanFactory</code>等，为了让应用更方便得使用<code>IoC</code>容器，还在<code>IoC</code>容器的外围提供如<code>Resource</code>访问资源的抽象和定位等支持。<code>Spring</code>还设计了<code>IoC</code>容器的高级形态<code>ApplicationContext</code>应用上下文提供用户使用。</p><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>​    Spring核心模块，围绕AOP增强功能，Spring集成了AspectJ作为AOP的一个特定实现，还在JVM动态代理/CGLIB的基础上实现了一个AOP框架。</p><h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><p>​    以DispatcherServlet为核心的模块，实现了MVC模式，包括怎样与Web容器环境集成、Web请求的拦截、分发、处理、和ModelAndView数据的返回，以及如何集成各种UI视图展现和数据表现。</p><h4 id="Spring-JDBC-ORM"><a href="#Spring-JDBC-ORM" class="headerlink" title="Spring JDBC/ORM"></a>Spring JDBC/ORM</h4><p>​    Spring JDBC包提供了JdbcTemplate作为模板类，封装了基本的数据库操作方法，如数据查询、更新等。</p><p>​    Spring还提供许多对ORM工具的封装。如Hibernate、iBatis等。可以把对这些工具的使用和Spring声明式事务处理结合起来。同时Spring还提供许多模板对象，如HibernateTemplate来实现对Hibernate的驱动。</p><h4 id="Spring事务处理"><a href="#Spring事务处理" class="headerlink" title="Spring事务处理"></a>Spring事务处理</h4><p>​    Spring事务处理是一个通过Spring AOP实现的自身功能增强的典型模块。通过AOP增强实现了声明式事务处理的功能，使应用只需要在IoC容器中对事务属性进行配置即可完成，同时这些事务处理的基本过程和具体的事务处理器实现是无关的，应用可以选择不同的具体的事务处理机制，使用了声明式事务处理，这些具体的事务处理机制会被纳入Spring事务处理的统一框架中完成，并完成与具体业务代码的解耦。</p><h4 id="Spring远端调用"><a href="#Spring远端调用" class="headerlink" title="Spring远端调用"></a>Spring远端调用</h4><p>​    通过Spring的封装，为应用屏蔽了各种通信和调用细节的实现，通过这一层的封装，使应用可以通过选择各种不同的远端调用来实现。如HTTP调用器、第三方二进制同学实现Hessian/Burlap、RMI调用。</p><h3 id="Spring应用场景"><a href="#Spring应用场景" class="headerlink" title="Spring应用场景"></a>Spring应用场景</h3><p>​    在Spring这个一站式应用平台或框架中，其中各个模块除了依赖IoC容器和AOP之外，相互之间没有很强的耦合性；Spring最重目标是简化应用开发的编程模型。其所提供的服务可贯穿应用道整个软件中，从最上层Web UI道底层数据操作，道其他企业信息数据集成，再到各种J2EE服务的使用。</p><p>​    可把Spring作为一个整体使用，也可以把Spring各个模块拿出来单独使用，因其本身是非常模块化的。Spring的价值：</p><ul><li>非侵入性框架，其目标是使应用程序代码对框架的依赖最小化。</li><li>提供了一个一致的编程模型，使应用直接使用POJO开发，从而可以与运行环境隔离开。</li><li>推动应用的设计风格向面向对象及面向接口编程转变，提高代码的重用性和可测性。</li><li>改进了体系结构的选择，Spring可以帮助我们选择不同的技术实现。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring子项目&quot;&gt;&lt;a href=&quot;#Spring子项目&quot; class=&quot;headerlink&quot; title=&quot;Spring子项目&quot;&gt;&lt;/a&gt;Spring子项目&lt;/h3&gt;&lt;h4 id=&quot;Spring-Framework（core）&quot;&gt;&lt;a href=&quot;#Spr
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
