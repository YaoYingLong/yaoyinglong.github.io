<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YingLong</title>
  
  <subtitle>虽奔放不羁，但也自我束缚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoyinglong.github.io/"/>
  <updated>2021-06-21T09:34:16.549Z</updated>
  <id>https://yaoyinglong.github.io/</id>
  
  <author>
    <name>YaoYingLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>命令模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/命令模式/</id>
    <published>2021-06-20T16:00:00.000Z</published>
    <updated>2021-06-21T09:34:16.549Z</updated>
    
    <content type="html"><![CDATA[<p>命令模式是一个高内聚的模式 ，将一个请求封装成一个对象， 从而让你使用不同的请求把客户端参数化， 对请<br>求排队或者记录请求日志， 可以提供命令的撤销和恢复功能 。</p><p><img src="../../../../../images/设计模式/命令模式通用类图.png" alt="命令模式通用类图"></p><p>命令模式有三个角色：</p><ul><li><strong><code>Receiver</code>接收者角色</strong>：执行命令功能的相关操作，具体命令对象业务的真正实现者。</li><li><strong><code>Command</code>命令角色</strong>：需要执行的所有命令在该角色中声明，拥有执行命令的抽象方法<code>execute()</code>。</li><li><strong><code>Invoker</code>调用者角色</strong>：是请求发送者，通常拥有很多命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>通用的Receiver类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收者可以是多个，具体的Receiver类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteReceiver1</span> <span class="keyword">extends</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteReceiver2</span> <span class="keyword">extends</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令角色是命令模式的核心，抽象的Command类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的Command类，可以在实际应用中扩展该命令类，在每个命令类中，通过构造函数定义该命令是针对哪个接收者发出的，定义一个命令接收的主题，这样调用者就仅需要实现命令的传递即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand1</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.find();</span><br><span class="line">        <span class="keyword">this</span>.receiver.add();</span><br><span class="line">        <span class="keyword">this</span>.receiver.delete();</span><br><span class="line">        <span class="keyword">this</span>.receiver.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand2</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.find();</span><br><span class="line">        <span class="keyword">this</span>.receiver.add();</span><br><span class="line">        <span class="keyword">this</span>.receiver.delete();</span><br><span class="line">        <span class="keyword">this</span>.receiver.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者Invoker类，不管什么命令都要接收、执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先声明调用者Invoker</span></span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">        <span class="comment">//定义接收者</span></span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> ConcreteReceiver1();</span><br><span class="line">        <span class="comment">//定义一个发送给接收者的命令</span></span><br><span class="line">        Command command = <span class="keyword">new</span> ConcreteCommand1(receiver);</span><br><span class="line">        <span class="comment">//把命令交给调用者去执行</span></span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令模式的<code>Receiver</code>在实际应用中可以被封装掉，从而减少高层模块Client类对低层模块Receiver角色类的依赖关系，提高系统整体的稳定性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个子类的全局共享变量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Receiver receiver;</span><br><span class="line">    <span class="comment">//实现类必须定义一个接收者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(Receiver _receiver)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = _receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> ConcreteReceiver1());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand1</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(receiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.find();</span><br><span class="line">        <span class="keyword">this</span>.receiver.add();</span><br><span class="line">        <span class="keyword">this</span>.receiver.delete();</span><br><span class="line">        <span class="keyword">this</span>.receiver.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>类间解耦：调用者角色和接收者角色之间没有任何依赖关系，调用者实现功能时只需要调用Command抽象类的execute方法即可，不需要了解到底是哪个接收者执行。</p><p>可扩展性：Command子类可以非常容易地扩展，而调用者Invoker和高层模块Client不产生严重代码耦合。</p><p>和其他模式结合会更优秀：命令模式和<strong>结合责任链模式</strong>，实现<strong>命令族解析任务</strong>；<strong>结合模板方法模式</strong>，可<strong>减少Command子类的膨胀</strong>问题。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Command子类会出现膨胀问题。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>命令模式在<code>Spring</code>框架<strong><code>JdbcTemplate</code></strong>源码的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action, <span class="keyword">boolean</span> closeResources)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">    Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line">    Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt = con.createStatement();</span><br><span class="line">        applyStatementSettings(stmt);</span><br><span class="line">        T result = action.doInStatement(stmt);</span><br><span class="line">        handleWarnings(stmt);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        String sql = getSql(action);</span><br><span class="line">        JdbcUtils.closeStatement(stmt);</span><br><span class="line">        stmt = <span class="keyword">null</span>;</span><br><span class="line">        DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">        con = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">throw</span> translateException(<span class="string">"StatementCallback"</span>, sql, ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeResources) &#123;</span><br><span class="line">            JdbcUtils.closeStatement(stmt);</span><br><span class="line">            DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">    Assert.notNull(sql, <span class="string">"SQL must not be null"</span>);</span><br><span class="line">    Assert.notNull(rse, <span class="string">"ResultSetExtractor must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Executing SQL query ["</span> + sql + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">SqlProvider</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs = stmt.executeQuery(sql);</span><br><span class="line">                <span class="keyword">return</span> rse.extractData(rs);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                JdbcUtils.closeResultSet(rs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sql;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> execute(<span class="keyword">new</span> QueryStatementCallback(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StatementCallback</code>接口，类似<code>Command</code>命令接口，<code>QueryStatementCallback</code>匿名内部类，实现了命令接口，同时也充当命令接收者；命令调用者是 <code>JdbcTemplate</code>，不同的实现<code>StatementCallback</code>接口的对象，对应不同的<code>doInStatement</code>实现逻辑；</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>实现在没有执行或执行后撤回，有两种方法可以解决，一是结合备忘录模式还原最后状态，该方法适合接收者为状态的变更情况，而不适合事件处理；二是通过增加一个新的命令，实现事件的回滚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;命令模式是一个高内聚的模式 ，将一个请求封装成一个对象， 从而让你使用不同的请求把客户端参数化， 对请&lt;br&gt;求排队或者记录请求日志， 可以提供命令的撤销和恢复功能 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../../images/设计模式/命令模式通用类图
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，命令模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/MySQL基础/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2021-06-18T07:38:50.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务基本特征ACID"><a href="#事务基本特征ACID" class="headerlink" title="事务基本特征ACID"></a>事务基本特征ACID</h3><p>事务是并发控制的单位，是用户定义的一个操作序列，这些操作要么都成功，要么都失败，是一个不可分割的工作单位。</p><ul><li><strong><code>Atomicity</code>原子性</strong>：事务中的包含的操作被看做是一个逻辑单元，要么全部成功，要么全部失败</li><li><strong><code>Isolation</code>隔离性</strong>：多个用户可以对同一个数据并发访问，而不破坏数据的正确性和完整性，并行事务的修改必须与其他并行事务的修改相互独立</li><li><strong><code>Consistency</code>一致性</strong>：合法的数据被写入到数据库，否则事务回滚到最初状态</li><li><strong><code>Durability</code>持久性</strong>：事务结束后，事务处理的结果必须能够得到固化</li></ul><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><h4 id="Read-Uncommitted读未提交"><a href="#Read-Uncommitted读未提交" class="headerlink" title="Read Uncommitted读未提交"></a><code>Read Uncommitted</code>读未提交</h4><p>级别最低，<strong>一个事务可以读到另外一个事务未提交的数据</strong>，事务在<strong>读数据</strong>的时候并<strong>未对数据加锁</strong>，在<strong>修改数据</strong>的时候只对数据增加<strong>行级共享锁</strong>。</p><p><strong>事务1</strong>读取某行记录时，<strong>事务2</strong>也能对这行记录进行读取、更新，因为<strong>事务1</strong>并未对数据增加任何锁；</p><p>当<strong>事务2</strong>对该记录进行更新时，<strong>事务1</strong>再次读取该记录，能读到<strong>事务2</strong>对该记录的修改版本，因为<strong>事务2</strong>只增加了共享读锁，<strong>事务1</strong>可以再增加共享读锁读取数据，即使该修改尚未被提交；</p><p><strong>事务1</strong>更新某行记录时，<strong>事务2</strong>不能对这行记录做更新，直到<strong>事务1</strong>结束，因为<strong>事务1</strong>对数据增加了共享读锁，<strong>事务2</strong>不能增加排他写锁进行数据的修改；</p><h4 id="Read-Committed读已提交"><a href="#Read-Committed读已提交" class="headerlink" title="Read Committed读已提交"></a><code>Read Committed</code>读已提交</h4><p>在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据，事务对当前被读取的数据加<strong>行级共享锁</strong>且当读到时才加锁，一旦读完该行，立即释放该行级共享锁；事务在<strong>更新某数据的瞬间</strong>，必须先对其加<strong>行级排他锁</strong>，直到事务结束才释放。</p><p><strong>事务1</strong>在读取某行记录的整个过程中，<strong>事务2</strong>都可以对该行记录进行读取，因为<strong>事务1</strong>对该行记录增加行级共享锁的情况下，<strong>事务2</strong>同样可以对该数据增加共享锁来读数据；</p><p><strong>事务1</strong>读取某行的一瞬间，<strong>事务2</strong>不能修改该行数据，但只要<strong>事务1</strong>读取完改行数据，<strong>事务2</strong>就可以对该行数据进行修改。因为<strong>事务1</strong>在读取的一瞬间会对数据增加共享锁，<strong>任何其他事务</strong>都不能对该行数据增加<strong>排他锁</strong>。但<strong>事务1</strong>只要读完该行数据，就会释放<strong>行级共享锁</strong>，一旦锁释放，<strong>事务2</strong>就可以对数据增加排他锁并修改数据；</p><p><strong>事务1</strong>更新某行记录时，<strong>事务2</strong>不能对这行记录做更新，直到<strong>事务1</strong>结束。因为<strong>事务1</strong>在更新数据时，会对该行数据增加<strong>排他锁</strong>，直到事务结束才会释放锁，所以在<strong>事务2</strong>没有提交之前，<strong>事务1</strong>都能不对数据增加<strong>共享锁</strong>进行数据的读取。所以<strong>可以解决脏读的现象</strong>，但<strong>不能解决不可重复读现象</strong>。</p><h4 id="Repeatable-Read可重复读"><a href="#Repeatable-Read可重复读" class="headerlink" title="Repeatable Read可重复读"></a><code>Repeatable Read</code>可重复读</h4><p>事务在读取某数据的瞬间，必须先对其加<strong>行级共享锁</strong>，直到事务结束才释放；事务在更新某数据的瞬间，必须先对其加<strong>行级排他锁</strong>，直到事务结束才释放。</p><p><strong>事务1</strong>在读取某行记录的整个过程中，<strong>事务2</strong>都可以对该行记录进行读取，因为<strong>事务1</strong>对该行记录增加行级共享锁的情况下，<strong>事务2</strong>同样可以对该数据增加共享锁来读数据；</p><p><strong>事务1</strong>在读取某行记录的整个过程中，<strong>事务2</strong>都不能修改该行数据，<strong>事务1</strong>在读取的<strong>整个过程</strong>会对数据增加共享锁，直到事务提交才会释放锁，所以整个过程中，<strong>任何其他事务</strong>都不能对该行数据增加排他锁。<strong>所以能解决不可重复读的读现象</strong>；</p><p><strong>事务1</strong>更新某行记录时，<strong>事务2</strong>不能对这行记录做更新，直到<strong>事务1</strong>结束，<strong>事务1</strong>在更新数据的时候，会对该行数据增加排他锁，直到事务结束才会释放锁，所以在<strong>事务2</strong>没有提交之前，<strong>事务1</strong>都能不对数据增加共享锁进行数据的读取。<strong>所以可以解决可重复读的现象</strong>，但<strong>不能解决幻读现象</strong>。</p><h4 id="Serializable串行化"><a href="#Serializable串行化" class="headerlink" title="Serializable串行化"></a><code>Serializable</code>串行化</h4><p>可序列化的隔离级别中可以解决幻读，产生幻读的原因是事务在进行范围查询的时候没有增加<strong>范围锁</strong>所以导致幻读，范围锁<strong><code>range-locks</code></strong>：给<code>SELECT</code> 的查询中使用一个<code>WHERE</code>子句描述范围加锁。事务在读取数据时，必须先对其加<strong>表级共享锁</strong> ，直到事务结束才释放；事务在更新数据时，必须先对其加<strong>表级排他锁</strong> ，直到事务结束才释放。</p><p><strong>事务1</strong>正在读取<strong>A表</strong>中的记录时，则<strong>事务2</strong>也能读取<strong>A表</strong>，但不能对<strong>A表</strong>做<strong>更新、新增、删除</strong>，直到<strong>事务1</strong>结束，因为<strong>事务1</strong>对表增加了<strong>表级共享锁</strong>，<strong>其他事务</strong>只能增加<strong>共享锁读取数据</strong>，不能进行其他任何操作；</p><p><strong>事务1</strong>正在<strong>更新A表</strong>中的记录时，则<strong>事务2</strong>不能读取<strong>A表</strong>的任意记录，更不可能对<strong>A表</strong>做更新、新增、删除，直到<strong>事务1</strong>结束，<strong>事务1</strong>对表增加了<strong>表级排他锁</strong>，其他事务不能对表增加共享锁或排他锁，也就无法进行任何操作；</p><p>可序列化解决了<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>等读现象，但无法读取其它事务已修改但未提交的记录，在当前事务完成之前，其它事务不能修改目前事务已读取的记录，在当前事务完成之前，其它事务所插入的新记录，其索引键值不能在当前事务的任何语句所读取的索引键范围中。</p><p>四种事务隔离级别从<strong>隔离程度上越来越高</strong>，但同时在<strong>并发性上也就越来越低</strong>。之所以有这么几种隔离级别，就是为了方便开发人员在开发过程中根据业务需要选择最合适的隔离级别。</p><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏读又称无效数据的读出，在一个事务的处理过程中读到另一个未提的交事务中的数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>在对数据库中的某个数据，一个事务范围类多次查询却返回了不同的数据值与脏读的区别是：不可重复读是读取了前一事务提交的数据</p><h4 id="虚读（幻读）"><a href="#虚读（幻读）" class="headerlink" title="虚读（幻读）"></a>虚读（幻读）</h4><p>事务在操作过程中两次查询，第二次查询的结果包含了第一次查询中未出现的数据或缺少第一次查询中出现的数据，一般解决幻读的方法是增加<strong>范围锁<code>RangeS</code></strong>，锁定检锁范围为只读，这样就避免了幻读。</p><h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><p><strong><code>1NF</code></strong>：强调的是列的原子性，即列不能够再分成其他几列<br><strong><code>2NF</code></strong>：表必须有一个主键，没有包含在主键中的列必须完全依赖于主键，而不只是依赖于主键的一部分<br><strong><code>3NF</code></strong>：非主键列必须直接依赖于主键列，不能存在传递依赖</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事务基本特征ACID&quot;&gt;&lt;a href=&quot;#事务基本特征ACID&quot; class=&quot;headerlink&quot; title=&quot;事务基本特征ACID&quot;&gt;&lt;/a&gt;事务基本特征ACID&lt;/h3&gt;&lt;p&gt;事务是并发控制的单位，是用户定义的一个操作序列，这些操作要么都成功，要么都失
      
    
    </summary>
    
      <category term="DB" scheme="https://yaoyinglong.github.io/categories/DB/"/>
    
    
      <category term="MySQL" scheme="https://yaoyinglong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁机制</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/MySQL锁机制/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2021-06-18T07:40:09.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><h3 id="页面锁"><a href="#页面锁" class="headerlink" title="页面锁"></a>页面锁</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;表级锁&quot;&gt;&lt;a href=&quot;#表级锁&quot; class=&quot;headerlink&quot; title=&quot;表级锁&quot;&gt;&lt;/a&gt;表级锁&lt;/h3&gt;&lt;h3 id=&quot;行级锁&quot;&gt;&lt;a href=&quot;#行级锁&quot; class=&quot;headerlink&quot; title=&quot;行级锁&quot;&gt;&lt;/a&gt;行级锁&lt;/h
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="MySQL" scheme="https://yaoyinglong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/Innodb/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/Innodb/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2021-06-18T03:05:28.563Z</updated>
    
    <content type="html"><![CDATA[<p>文件系统的<strong>最小单元是块</strong>，一个块的大小是<strong><code>4K</code></strong>，在文件系统中即使一个文件只有<strong>一个字节</strong>，但也不得不占<strong><code>4KB</code></strong>的磁盘空间。</p><p><code>InnoDB</code>存储引擎的<strong>最小存储单元是<code>Page</code>页</strong>，页可用于存<strong>放数据</strong>也可用于存放<strong>键值<code>+</code>指针</strong>，指针大小在<code>InnoDB</code>源码中设置为<strong><code>6</code>字节</strong>，在<code>B+</code>树中<strong>叶子节点存放数据</strong>，<strong>非叶子节点存放键值<code>+</code>指针</strong>，默认一个页的大小是<strong><code>16382</code></strong>即<strong><code>16K</code></strong>。<code>InnoDB</code>的所有数据文件后缀为<strong><code>ibd</code></strong>，其大小始终都是<strong><code>16K</code>的整倍数</strong>。数据表中的数据都是存储在页中，若一行数据大小为<code>1K</code>，则一页可存放16行这样的数据。</p><p>一个页中不可能所有空间都用于存放数据，它还会存放一些少量的其他字段比如<code>page level</code>，<code>index number</code>等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件系统的&lt;strong&gt;最小单元是块&lt;/strong&gt;，一个块的大小是&lt;strong&gt;&lt;code&gt;4K&lt;/code&gt;&lt;/strong&gt;，在文件系统中即使一个文件只有&lt;strong&gt;一个字节&lt;/strong&gt;，但也不得不占&lt;strong&gt;&lt;code&gt;4KB&lt;/code&gt;&lt;/
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="MySQL" scheme="https://yaoyinglong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/分库分表/</id>
    <published>2021-06-16T16:00:00.000Z</published>
    <updated>2021-06-17T06:32:16.932Z</updated>
    
    <content type="html"><![CDATA[<p>中大型项目中，一旦遇到数据量比较大，都知道对数据进行拆分，有<strong>垂直拆分</strong>和<strong>水平拆分</strong>两种。</p><p><strong>垂直拆分</strong>：从业务角度拆分多个库。</p><p><strong>水平拆分</strong>：同一个业务数据量大，进行水平拆分。</p><h3 id="分库分表方案"><a href="#分库分表方案" class="headerlink" title="分库分表方案"></a>分库分表方案</h3><p><strong><code>hash</code>取模</strong>和<strong><code>range</code>范围</strong>方案是分库分表方案中常用的方案；分库分表方案<strong>最主要</strong>就是<strong>路由算法</strong>，把路由的<code>key</code>按照指定的算法进行路由存放。</p><h4 id="hash取模方案"><a href="#hash取模方案" class="headerlink" title="hash取模方案"></a>hash取模方案</h4><p><strong><code>hash</code></strong>的方案就是对指定的<strong>路由key</strong>对<strong>分表总数进行取模</strong>，可以参考<strong><code>HashMap</code></strong>源码。</p><p><strong>优点</strong>：是可以<strong>将数据均匀放到各个分表中</strong>，<strong>不会出现热点问题</strong>。</p><p><strong>缺点</strong>：是数据<strong>迁移</strong>和<strong>扩容</strong>会比较困难。因为若之前分表是4，现在分表变成了8，由于取模基数变化导致之前的数据可能会找不到。要解决这样的问题，就需要将之前的数据重新按照新的取模基数做hash方案把数据进行迁移，放到新规划的分表中。但是对某些不允许停机做数据迁移的业务就会非常痛苦。</p><h4 id="range范围方案"><a href="#range范围方案" class="headerlink" title="range范围方案"></a>range范围方案</h4><p>range方案比较简单，就是<strong>把一定范围内的订单，存放到一个表中</strong>；如id=12放到0表中，id=1300万的放到1表中。设计这个方案时就是前期把表的范围设计好。通过id进行路由存放。</p><p><strong>优点</strong>：有利于将来的扩容，不需要做数据迁移。</p><p><strong>缺点</strong>：有热点问题。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>hash是可以解决数据均匀的问题，range可以解决数据迁移问题</strong>，可以将两种方案结合，在<strong>一定的范围内数据均匀</strong>，每次扩容肯定会<strong>先设计好这次扩容的范围大小</strong>，只要<strong>保证这次的范围内的数据均匀</strong>就行了。</p><p>可以先定义一个<strong><code>group</code>组</strong>的概念，首先通过范围range定位是哪个group组，然后根据hash方案定位是哪个DB，再根据range方案定位哪个Table。</p><p>例如对10进行取模，如果值为【0，1，2，3】就路由到DB_0，【4，5，6】路由到DB_1，【7，8，9】路由到DB_2。1000万以内的id都均匀的分配到DB_0，DB_1，DB_2三个数据库中的Table_0表中。</p><p><img src="../../../../images/DB/数据存储示意图.png" alt></p><p><strong>扩容</strong>的时候只需要再设计一个<strong><code>group02</code></strong>组就行了。</p><p>设计是比较简单的，就3张表，把group，DB，table之间建立好关联关系就行了。</p><p><img src="../../../../images/DB/group与DB的关系.png" alt="group与DB的关系"></p><p><img src="../../../../images/DB/table与db的关系.png" alt="table与db的关系"></p><p>在开发的时候把三张关联数据保存到缓存中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中大型项目中，一旦遇到数据量比较大，都知道对数据进行拆分，有&lt;strong&gt;垂直拆分&lt;/strong&gt;和&lt;strong&gt;水平拆分&lt;/strong&gt;两种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;垂直拆分&lt;/strong&gt;：从业务角度拆分多个库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;水平拆分
      
    
    </summary>
    
      <category term="DB" scheme="https://yaoyinglong.github.io/categories/DB/"/>
    
    
      <category term="DB" scheme="https://yaoyinglong.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>Spring初始化扩展</title>
    <link href="https://yaoyinglong.github.io/Blog/%E4%B8%AD%E9%97%B4%E4%BB%B6/Spring/Spring%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%A9%E5%B1%95/"/>
    <id>https://yaoyinglong.github.io/Blog/中间件/Spring/Spring初始化扩展/</id>
    <published>2021-06-16T16:00:00.000Z</published>
    <updated>2021-06-17T08:17:22.551Z</updated>
    
    <content type="html"><![CDATA[<p>经常需要在<strong>容器启动时做一些钩子动作</strong>，比如注册消息消费者，监听配置等。</p><h2 id="容器刷新完成扩展点"><a href="#容器刷新完成扩展点" class="headerlink" title="容器刷新完成扩展点"></a>容器刷新完成扩展点</h2><h3 id="监听容器刷新完成扩展点ApplicationListener-lt-ContextRefreshedEvent-gt"><a href="#监听容器刷新完成扩展点ApplicationListener-lt-ContextRefreshedEvent-gt" class="headerlink" title="监听容器刷新完成扩展点ApplicationListener&lt;ContextRefreshedEvent&gt;"></a>监听容器刷新完成扩展点<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code></h3><p>容器刷新成功意味着所有的<code>Bean</code>已初始化完成，当容器刷新之后<code>Spring</code>将会调用容器内所有实现了<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>的<code>Bean</code>的<code>onApplicationEvent</code>方法，应用程序可以以此达到监听容器初始化完成事件的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerExample</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"ApplicationListenerExample Startup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法，就会造成<code>onApplicationEvent</code>方法被执行两次。因为在<code>Spring MVC</code>项目中，系统会存在两个容器，一个是<code>root ApplicationContext</code>，一个是作为<code>root ApplicationContext</code>的子容器的<code>WebApplicationContext</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerExample</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getApplicationContext().getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"ApplicationListenerExample Startup"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h5><p>可以借助<code>Spring</code>以最小成本实现一个观察者模式，首先定义一个事件，然后注册一个监听器，最后发布事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotifyEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">NotifyEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(NotifyEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"NotifyListener Startup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext webApplicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NotifyEvent event = <span class="keyword">new</span> NotifyEvent(<span class="string">"object"</span>);</span><br><span class="line">        webApplicationContext.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot的CommandLineRunner接口"><a href="#SpringBoot的CommandLineRunner接口" class="headerlink" title="SpringBoot的CommandLineRunner接口"></a><code>SpringBoot</code>的<code>CommandLineRunner</code>接口</h3><p>当容器上下文初始化完成之后，<code>SpringBoot</code>也会调用所有实现了<code>CommandLineRunner</code>接口的<code>run</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandLineStartupRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"CommandLineStartupRunner Startup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个实现了<code>CommandLineRunner</code>的<code>Bean</code>的执行顺序可以根据<code>Bean</code>上的<code>@Order</code>注解调整。其<code>run</code>方法可以接受从控制台输入的参数，跟<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>这种扩展相比更加灵活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar CommandLineStartupRunner.jar abc abcd</span><br></pre></td></tr></table></figure><h3 id="SpringBoot的ApplicationRunner接口"><a href="#SpringBoot的ApplicationRunner接口" class="headerlink" title="SpringBoot的ApplicationRunner接口"></a><code>SpringBoot</code>的<code>ApplicationRunner</code>接口</h3><p><code>SpringBoot</code>的<code>CommandLineRunner</code>接口扩展类似，只不过接受参数是一个<code>ApplicationArguments</code>类，对控制台输入的参数提供了更好的封装，以<code>--</code>开头的被视为<strong>带选项的参数</strong>，否则是普通的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationStartupRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"ApplicationStartupRunner Startup: &#123;&#125;"</span>, args.getOptionNames());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输入参数示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ApplicationStartupRunner.jar abc abcd --autho=mark verbose</span><br></pre></td></tr></table></figure><h2 id="Bean初始化完成扩展点"><a href="#Bean初始化完成扩展点" class="headerlink" title="Bean初始化完成扩展点"></a><code>Bean</code>初始化完成扩展点</h2><h4 id="PostConstruct注解"><a href="#PostConstruct注解" class="headerlink" title="@PostConstruct注解"></a><code>@PostConstruct</code>注解</h4><p><code>@PostConstruct</code>注解一般放在<code>Bean</code>的方法上，被<code>@PostConstruct</code>修饰的方法会在<code>Bean</code>初始化后马上调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostConstructExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InitializingBean接口"><a href="#InitializingBean接口" class="headerlink" title="InitializingBean接口"></a><code>InitializingBean</code>接口</h4><p><code>InitializingBean</code>的用法基本上与<code>@PostConstruct</code>一致，只不过相应的<code>Bean</code>需要实现<code>afterPropertiesSet</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingBeanExample</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bean注解的初始化方法"><a href="#Bean注解的初始化方法" class="headerlink" title="@Bean注解的初始化方法"></a><code>@Bean</code>注解的初始化方法</h4><p>通过<code>@Bean</code>注入<code>Bean</code>的时候可以指定初始化方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitMethodExampleBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> InitMethodExampleBean <span class="title">initMethodExampleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> InitMethodExampleBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过构造函数注入"><a href="#通过构造函数注入" class="headerlink" title="通过构造函数注入"></a>通过构造函数注入</h4><p><code>Spring</code>也支持通过构造函数注入，我们可以把搞事情的代码写在构造函数中，同样能达到目的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorExampleBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstructorExampleBean</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bean</code>初始化完成扩展点执行顺序是：<strong>构造函数注入</strong>，<strong><code>@PostConstruct</code>注解</strong>，<strong><code>InitializingBean</code>接口</strong>，<strong><code>@Bean</code>注解的初始化方法</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经常需要在&lt;strong&gt;容器启动时做一些钩子动作&lt;/strong&gt;，比如注册消息消费者，监听配置等。&lt;/p&gt;
&lt;h2 id=&quot;容器刷新完成扩展点&quot;&gt;&lt;a href=&quot;#容器刷新完成扩展点&quot; class=&quot;headerlink&quot; title=&quot;容器刷新完成扩展点&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="中间件" scheme="https://yaoyinglong.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/中介者模式/</id>
    <published>2021-04-18T16:00:00.000Z</published>
    <updated>2021-04-19T07:43:20.096Z</updated>
    
    <content type="html"><![CDATA[<p>常常会出现好多对象之间存在<strong>复杂的交互关系</strong>，这种交互关系常常是<strong>网状结构</strong>，它要求每个对象都必须知道它需要交互的对象。若把这种<strong>网状结构</strong>改为<strong>星形结构</strong>的话，将大大降低它们之间的<strong>耦合性</strong>，这时只要找一个<strong>中介者</strong>就可以了。</p><p>定义一个中介对象来封装一系列对象之间的交互，中介者使各对象不需要显示地相互作用 ，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。<strong>中介者模式</strong>又叫<strong>调停模式</strong>，它是<strong>迪米特法则的典型应用</strong>。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>中介者模式由<strong>抽象中介者</strong>、<strong>具体中介者</strong>、<strong>抽象同事</strong>、<strong>具体同事</strong>几个主要角色。</p><p><strong>抽象中介者</strong>：定义统一的接口， 用于各同事角色之间的通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义同事类</span></span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleague1 c1;</span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleague2 c2;</span><br><span class="line">    <span class="comment">//中介者模式的业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体中介者</strong>：通过协调各同事角色实现协作行为， 因此它必须依赖于各个同事角色 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.c1.selfMethod1();</span><br><span class="line">        <span class="keyword">super</span>.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.c1.selfMethod1();</span><br><span class="line">        <span class="keyword">super</span>.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象同事类</strong>：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体同事类</strong>：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互，每个同事角色都知道中介者角色， 且与其他同事角色通信时， 一定要通过中介者角色协作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague1</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">        <span class="comment">//自己不能处理的业务逻辑， 委托给中介者处理</span></span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague2</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">        <span class="comment">//自己不能处理的业务逻辑， 委托给中介者处理</span></span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomething2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>类之间各司其职，符合迪米特法则</p><p>降低了对象之间的耦合性，使得对象易于独立地被复用</p><p>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在<code>MVC</code>框架中，控制器（C）就是模型（M）和视图（V）的中介者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常常会出现好多对象之间存在&lt;strong&gt;复杂的交互关系&lt;/strong&gt;，这种交互关系常常是&lt;strong&gt;网状结构&lt;/strong&gt;，它要求每个对象都必须知道它需要交互的对象。若把这种&lt;strong&gt;网状结构&lt;/strong&gt;改为&lt;strong&gt;星形结构&lt;/strong
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，中介者模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/创建型模式/原型模式/</id>
    <published>2021-04-07T16:00:00.000Z</published>
    <updated>2021-04-08T10:26:12.777Z</updated>
    
    <content type="html"><![CDATA[<p>用一个已经创建的实例作为原型，<strong>通过复制该原型对象来创建一个和原型相同或相似的新对象</strong>。用这种方式创建对象非常高效，无须知道对象创建的细节。</p><p>在实际项目中，原型模式很少单独出现，一般是和<strong>工厂方法模式</strong>一起出现， 通过<code>clone</code>的方法创建一个对象，然后由工厂方法提供给调用者。 </p><p>原型模式简单程度仅次于<strong>单例模式</strong>和<strong>迭代器模式</strong>，<code>Java</code>中的<code>Object</code>类提供了浅克隆的<code>clone()</code>方法，具体原型类只要实现<strong><code>Cloneable</code></strong>接口就可实现对象的浅克隆。<code>Cloneable</code> 接口只是一个<strong>标记</strong>作用， 在<code>JVM</code>中具有这个标记的对象才有可能被拷贝。 </p><p><img src="../../../../images/设计模式/原型模式结构图.png" alt="原型模式结构图"></p><p>原型模式的克隆分为浅克隆和深克隆</p><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thing</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thing thing = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thing = (Thing) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thing</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thing thing = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thing = (Thing) <span class="keyword">super</span>.clone();</span><br><span class="line">            thing.arrayList = (ArrayList&lt;String&gt;)<span class="keyword">this</span>.arrayList.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象的<code>clone</code>与对象内的<code>final</code>关键字是有冲突的 ，要使用<code>clone</code>方法， 类的成员变量上不要增加<code>final</code>关键字</strong>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><code>Java</code>自带的原型模式基于内存二进制流的复制，在性能上比直接new一个对象更加优良，特别是要在一<br>个循环体内产生大量的对象时</p><p>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用。</p><p><strong>逃避构造函数的约束</strong>，直接在内存中拷贝， 构造函数是不会执行的</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>需要为每一个类都配置一个<strong><code>clone</code></strong>方法</p><p>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则</p><p>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>对象之间相同或相似，即只是个别的几个属性不同的时候</p><p>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源</p><p>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性</p><p>系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值</p><p>一个对象需要提供给其他对象访问， 而且各个调用者可能都需要修改其值时， 可以考虑使用原型模式拷贝多个对象供调用者使用 </p><p><code>JDK</code>源码中 <code>ArrayList</code>的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用一个已经创建的实例作为原型，&lt;strong&gt;通过复制该原型对象来创建一个和原型相同或相似的新对象&lt;/strong&gt;。用这种方式创建对象非常高效，无须知道对象创建的细节。&lt;/p&gt;
&lt;p&gt;在实际项目中，原型模式很少单独出现，一般是和&lt;strong&gt;工厂方法模式&lt;/strong
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，原型模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E9%9A%90%E5%BD%A2%E7%9C%BC%E9%95%9C%E6%94%BB%E7%95%A5/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/隐形眼镜攻略/</id>
    <published>2021-01-28T06:49:56.328Z</published>
    <updated>2021-01-28T07:18:47.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="隐形眼镜攻略"><a href="#隐形眼镜攻略" class="headerlink" title="隐形眼镜攻略"></a>隐形眼镜攻略</h1><h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p>硅水凝胶已经是目前主流材质，各方面参数、安全性、透氧性都远远好于水凝胶</p><p>新—水凝胶</p><h3 id="品牌"><a href="#品牌" class="headerlink" title="品牌"></a>品牌</h3><p>视康爱尔康、库博、强生安视优、博士伦</p><h3 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h3><p>为了更健康的使用隐形眼镜，请选用<strong>短周期产品</strong>，避免使用年抛、半年抛、季抛等传统产品，选择月抛、双周抛和日抛产品，减少因蛋白质、脂质沉淀或镜片发生的破损引发的问题，同时长周期镜片大多都是使用低含水量，较硬的HEMA材质，透氧性较差，很多产品远达不到足够的安全佩戴含氧量，长期佩戴必然会导致眼红、干涩、甚至引发更严重的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;隐形眼镜攻略&quot;&gt;&lt;a href=&quot;#隐形眼镜攻略&quot; class=&quot;headerlink&quot; title=&quot;隐形眼镜攻略&quot;&gt;&lt;/a&gt;隐形眼镜攻略&lt;/h1&gt;&lt;h3 id=&quot;材质&quot;&gt;&lt;a href=&quot;#材质&quot; class=&quot;headerlink&quot; title=&quot;材质&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="自度" scheme="https://yaoyinglong.github.io/categories/%E8%87%AA%E5%BA%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>2020总结</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/2020%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/2020总结/</id>
    <published>2021-01-25T16:00:00.000Z</published>
    <updated>2021-01-22T02:12:02.393Z</updated>
    
    <content type="html"><![CDATA[<p>之前没有写年终总结的习惯，但是今年发生了太多的事，对于我而言算是意义非凡的一年吧。</p><p>总的来说今年算是梦幻开局，平淡结束吧。</p><p>去年底和今年初疫情的原因，开始有点人心惶惶，但是过年没法走亲戚以及开年延迟上班在家办公对于一个宅男来说算是一种慰藉。</p><p>今年经历了曾经从来没有经历过的事，虽然最后还是以失败告终，不去追究谁对谁错，每个人都有自己的选择，有些是没有经历过真的是不太懂，失去过后才来后悔，在那段时间里我不断自我反省，到处寻找答案，甚至买了好几本书看，渐渐的可能找到了一些答案吧。这段经历使我成长了好多好多，撞碎了一些我以为的思想。不再对任何人任何事一开始抱有比较高的期望，逐渐明悟自己想要的是什么，对待感情不再那么执着较真。</p><p>为了转移注意力开始学习，买了差不多二三十本专业的书来看，去LeetCode刷题。</p><p>感谢一路上有人一直带我走出我自己的世界，面对真实的自己，人前人后展现更加真实的自己。可能很多人对我有比较大的误解，觉得我没什么主见什么都听别人的感觉，在意一个人的时候很容易全部注意力都在她身上，总是把她的一举一动一言一行看得很重要所以很容易失去了自我，显得自己很没有主见，</p><p>曾经我是一个极度容易尴尬的人，经过今年的成长，参加了很多活动，内心平静自然多了。</p><p>每次要写点东西的时候总是感觉有好多东西要说，但是真正写的时候又说不出来什么，感觉好像很多事又不值得一说反正也就那样。2020就这样潦草结尾吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前没有写年终总结的习惯，但是今年发生了太多的事，对于我而言算是意义非凡的一年吧。&lt;/p&gt;
&lt;p&gt;总的来说今年算是梦幻开局，平淡结束吧。&lt;/p&gt;
&lt;p&gt;去年底和今年初疫情的原因，开始有点人心惶惶，但是过年没法走亲戚以及开年延迟上班在家办公对于一个宅男来说算是一种慰藉。&lt;/p
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/结构型模式/代理模式/</id>
    <published>2020-11-04T16:00:00.000Z</published>
    <updated>2021-04-09T06:08:06.870Z</updated>
    
    <content type="html"><![CDATA[<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>代理模式是一个使用率非常高的模式，<strong>为其他对象提供一种代理以控制这个对象的访问</strong>。代理模式也叫做<strong>委托模式</strong>，它是一项<strong>基本设计技巧</strong>。许多其他的模式，如<strong>状态模式</strong>、<strong>策略模式</strong>、<strong>访问者模式</strong>本质上是在<strong>更特殊的场合</strong>采用了<strong>委托模式</strong>，而且在日常的应用中，代理模式可以提供非常好的访问控制。</p><p><img src="../../../../images/设计模式/代理模式类图.png" alt="代理模式类图"></p><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问；</p><p>抽象主题类<strong><code>Subject</code></strong>通过<strong>接口</strong>或<strong>抽象类</strong>声明<strong>真实主题</strong>和<strong>代理对象</strong>实现的业务方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实主题类<code>RealSubject</code>实现了<strong>抽象主题中的具体业务</strong>，是代理对象所代表的真实对象，是最终要引用的对象，为<strong>具体主题角色</strong>，也叫<strong>被委托角色</strong>或<strong>被代理角色</strong>，是<strong>业务逻辑的具体执行者</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类<code>Proxy</code>提供了<strong>与真实主题相同的接口</strong>，其内部<strong>含有对真实主题的引用</strong>，它可以<strong>访问</strong>、<strong>控制</strong>或<strong>扩展</strong>真实主题的功能，也叫<strong>委托类</strong>或<strong>代理类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before();</span><br><span class="line">        <span class="keyword">this</span>.subject.request();</span><br><span class="line">        <span class="keyword">this</span>.after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知；一个代理类可以<strong>代理多个</strong>被委托者或被代理者， 因此一个代理类具体代理哪个真实主题角色， 是由场景类决定。 </p><p>代理模式优点<strong>职责清晰</strong>，真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务；<strong>高扩展性</strong>；<strong>智能化</strong>。</p><p>根据代理的创建时期，代理模式分为<strong>静态代理</strong>和<strong>动态代理</strong>，还可以通过<strong>反射</strong>的方式实现<strong><a href="../../Java/基础/动态代理">动态代理</a></strong></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</p><p>可以扩展目标对象的功能</p><p>能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>会造成系统设计中类的数量增加</p><p>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢</p><p>增加了系统的复杂度</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：<strong>保护目标对象</strong>，<strong>增强目标对象</strong>。</p><ul><li>远程代理，通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。</li><li>虚拟代理，通常用于要创建的目标对象开销很大时。</li><li>安全代理，通常用于控制不同种类客户对真实对象的访问权限。</li><li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。</li><li>延迟加载，指为了提高系统的性能，延迟对目标的加载。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于某些原因需要给某对象提供一个代理以控制对该对象的访问。访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。&lt;/p&gt;
&lt;p&gt;代理模式是一个使用率非常高的模式，&lt;strong&gt;为其他对象提供一种代理以控制这个对象的访问&lt;/strong&gt;。代理模
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，代理模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/创建型模式/建造者模式/</id>
    <published>2020-11-03T16:00:00.000Z</published>
    <updated>2021-04-06T02:48:47.440Z</updated>
    
    <content type="html"><![CDATA[<p><strong>建造者模式</strong>也叫<strong>生成器模式</strong>，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<strong>当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。</strong></p><p><img src="../../../../images/设计模式/建造者模式类图.png" alt="建造者模式类图"></p><p>车辆模型抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; sequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequence = sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String actionName : sequence) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"stop"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"alarm"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.alarm();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"engineBoom"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.engineBoom();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>车辆模型的具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzModel</span> <span class="keyword">extends</span> <span class="title">CarModel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz开动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz停车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz鸣笛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz发动引擎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWModel</span> <span class="keyword">extends</span> <span class="title">CarModel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW开动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW停车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW鸣笛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW发动引擎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象汽车的组装者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; seqence)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CarModel <span class="title">getCarModel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的车的组装者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzBuilder</span> <span class="keyword">extends</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BenzModel benz = <span class="keyword">new</span> BenzModel();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.benz.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CarModel <span class="title">getCarModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.benz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWBuilder</span> <span class="keyword">extends</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BMWModel bmw = <span class="keyword">new</span> BMWModel();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bmw.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CarModel <span class="title">getCarModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bmw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">sequence.add(<span class="string">"engineBoom"</span>);</span><br><span class="line">sequence.add(<span class="string">"start"</span>);</span><br><span class="line">sequence.add(<span class="string">"stop"</span>);</span><br><span class="line">BenzBuilder benzBuilder = <span class="keyword">new</span> BenzBuilder();</span><br><span class="line">benzBuilder.setSequence(sequence);</span><br><span class="line">BenzModel benz = (BenzModel)benzBuilder.getCarModel();</span><br><span class="line">benz.run();</span><br><span class="line">BMWBuilder bmwBuilder = <span class="keyword">new</span> BMWBuilder();</span><br><span class="line">bmwBuilder.setSequence(sequence);</span><br><span class="line">BMWModel bmw = (BMWModel)bmwBuilder.getCarModel();</span><br><span class="line">bmw.run();</span><br></pre></td></tr></table></figure><p><code>CarModel</code>及其之类都是产品类，<code>CarBuilder</code>是抽象的建造者，用于规范产品的组建，其子类是具体的建造者，实现抽象类定义的所有，并返回一个组建好的对象。</p><p>建造者模式有良好的<strong>封装性</strong>，使用建造者模式可以使客户端不必知道产品内部组成的细节，建造者是独立的<strong>容易扩展</strong>，因此也<strong>便于控制细节风险</strong>，对建造过程逐步细化，而不对其他的模式产生任何影响。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>相同的方法，不同的执行顺序</strong>，产生不同的事件结果时。</li><li><strong>多个部件或零件，都可以装配到一个对象中</strong>，但是产生的<strong>运行结果又不相同</strong>时。</li><li><strong>产品类非常复杂</strong>，或者产品类中的<strong>调用顺序</strong>不同产生了不同的效能。</li><li>在对象创建过程中会<strong>使用到系统中的一些其他对象</strong>，这些对象在产品对象的<strong>创建过程中不易得到</strong>时，也可以采用建造者模式封装该对象的创建过程，该种场景只能是一个补偿方法。</li></ul><h3 id="与工厂模式的区别"><a href="#与工厂模式的区别" class="headerlink" title="与工厂模式的区别"></a>与工厂模式的区别</h3><p><strong>建造者模式</strong>最主要的功能是<strong>基本方法的调用顺序安排</strong>，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同；而<strong>工厂方法</strong>则重点是<strong>创建</strong>，创建零件是它的主要职责，组装顺序则不是它关心的。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;建造者模式&lt;/strong&gt;也叫&lt;strong&gt;生成器模式&lt;/strong&gt;，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;strong&gt;当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。&lt;/
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，建造者模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/模板方法模式/</id>
    <published>2020-11-02T16:00:00.000Z</published>
    <updated>2021-04-06T01:42:09.059Z</updated>
    
    <content type="html"><![CDATA[<p><strong>模板方法模式</strong>非常简单应用非常广泛的模式，定义一个操作中的<strong>算法框架</strong>，而将一些步骤<strong>延迟到子类</strong>中。使得子类可以<strong>不改变一个算法的结构</strong>即可重定义该算法的某些特定步骤。</p><p><img src="../../../../images/设计模式/模板方法模式类图.png" alt="模板方法模式类图"></p><p><code>AbstractClass</code>叫做<strong>抽象模板</strong>，其方法分为<strong>基本方法</strong>和<strong>模板方法</strong>两类。<strong>基本方法</strong>也叫做基本操作，由子类实现的方法，且在模板方法中被调用。<strong>模板方法</strong>可以有一个或几个，用于实现对基本方法的调度，完成固定的逻辑。为了防止恶意操作，一般模板方法都使用<code>final</code>关键之修饰，防止被覆盖。</p><p>抽象模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareGotoSchool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        derssUp();</span><br><span class="line">        eatBreakfast();</span><br><span class="line">        tackThings();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">derssUp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">tackThings</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">derssUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿衣服"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃妈妈做的早餐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tackThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"背书包，带上家庭作业和红领巾"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">derssUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿工作服"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"做早饭，照顾孩子吃早饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tackThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带上昨天晚上准备的考卷"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.prepareGotoSchool();</span><br><span class="line">Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">teacher.prepareGotoSchool();</span><br></pre></td></tr></table></figure><p><strong>抽象模板</strong>中的<strong>基本方法</strong>尽量设计为<code>protected</code>类型，符合<strong>迪米特法则</strong>，不需要暴露的属性或方法尽量不要设置为protected类型。实现类若非必要，尽量不要扩大父类中的访问权限。 </p><p>模板方法模式可<strong>封装不变部分</strong>，<strong>扩展可变部分</strong>；可提取公共部分代码，便于维护；<strong>行为由父类控制，子类实现</strong>。但一般的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，<strong>子类执行的结果影响了父类的结果</strong>，也就是子类对父类产生了影响，在复杂的项目中，会带来代码阅读的难度。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>多个子类有公有的方法，且逻辑基本相同时</li><li>重要、复杂的算发，可以把核心算法设计为模板方法，周边的相关细节功能由各个子类实现</li><li>重构时，模板方法模式时一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为</li></ul><p>在Spring源码中<strong><code>refresh()</code></strong>就是典型的模板方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span>, <span class="title">ifecycle</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.refresh"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            prepareRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">                StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.beans.post-process"</span>);</span><br><span class="line">                <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line">                beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                initMessageSource();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                onRefresh();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                registerListeners();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                                <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">                destroyBeans();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">                <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">                resetCommonCaches();</span><br><span class="line">                contextRefresh.end();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>JDK</code></strong>中<strong><code>HashMap</code></strong>、<strong><code>Map</code></strong>、<strong><code>AQS</code></strong>中都有用到模板方法设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS中用到的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK8 Map中的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">return</span> (((v = get(key)) != <span class="keyword">null</span>) || containsKey(key))</span><br><span class="line">        ? v : defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt;非常简单应用非常广泛的模式，定义一个操作中的&lt;strong&gt;算法框架&lt;/strong&gt;，而将一些步骤&lt;strong&gt;延迟到子类&lt;/strong&gt;中。使得子类可以&lt;strong&gt;不改变一个算法的结构&lt;/strong&gt;即可重定义该算
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，模板方法模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/创建型模式/工厂模式/</id>
    <published>2020-11-02T16:00:00.000Z</published>
    <updated>2020-11-03T08:00:50.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><strong>工厂方法模式</strong>使用的频率非常高 ，用于创建对象的接口， 让<strong>子类</strong>决定实例化哪一个类。 工厂方法使一个<strong>类的实例化延迟到其子类</strong> 。用于<strong>封装</strong>和<strong>管理</strong>对象的创建，是一种<strong>创建模式</strong>。是<strong>典型的解耦框架</strong>，在需要<strong>灵活的</strong>、<strong>可扩展</strong>的框架时可以采用，可以用在<strong>异构项目</strong>中，可以使用在测试驱动的开发框架下。</p><p><img src="../../../../images/设计模式/工厂方法模式类图.png" alt="工厂方法模式类图"></p><p>抽象产品类，抽象人种类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的产品类可以有多个， 都继承于抽象产品类，具体的人种类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YellowHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂类负责定义产品对象的产生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体如何产生一个产品的对象， 是由具体的工厂类实现的，具体的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"人种生成错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AbstractHumanFactory YinYangLu = <span class="keyword">new</span> HumanFactory();</span><br><span class="line">Human whiteHuman = YinYangLu.createHuman(WhiteHuman.class);</span><br><span class="line">whiteHuman.getColor();</span><br><span class="line">whiteHuman.talk();</span><br><span class="line">Human blackHuman = YinYangLu.createHuman(BlackHuman.class);</span><br><span class="line">blackHuman.getColor();</span><br><span class="line">blackHuman.talk();</span><br><span class="line">Human yellowHuman = YinYangLu.createHuman(YellowHuman.class);</span><br><span class="line">yellowHuman.getColor();</span><br><span class="line">yellowHuman.talk();</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>良好的<strong>封装性</strong>， 代码结构清晰</li><li>良好的<strong>扩展性</strong>，增加产品类， 只要适当地修改具体的工厂类或扩展一个工厂类</li><li><strong>屏蔽产品类</strong>，产品类的实现如何变化， 调用者都不需要关心，上层模块不发生变化</li><li>典型的<strong>解耦框架</strong>，高层模块值需要知道产品的抽象类，符合迪米特法则、依赖倒置原则、里氏替换原则</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>需要<strong>生成对象</strong>的地方都可以使用， 但是需要慎重考虑是否要增加一个工厂类进行管理， 增加代码的复杂度</li><li>需要<strong>灵活</strong>的、 <strong>可扩展</strong>的框架时</li><li><strong>异构项目中</strong>，如通过<code>WebService</code>与一个非Java的项目交互 </li><li>可以使用在<strong>测试驱动开发的框架下</strong></li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>工厂方法模式有很多扩展，且与其他模式结合使用威力更大，可将其<strong>缩小为简单工厂模式</strong>，可<strong>升级为多个工厂类</strong>，可<strong>替代单例模式</strong>，可<strong>延迟初始化</strong>。</p><h4 id="缩小为简单工厂模式"><a href="#缩小为简单工厂模式" class="headerlink" title="缩小为简单工厂模式"></a>缩小为简单工厂模式</h4><p>该模式是工厂方法模式的弱化，<strong>简单工厂模式</strong>又叫<strong>静态工厂模式</strong>，仅简单的对<strong>不同类</strong>对象的创建进行了简单的封装。<strong>缺点</strong>是<strong>工厂类的扩展比较困难</strong>， <strong>不符合开闭原则</strong>。 </p><p><img src="../../../../images/设计模式/简单工厂模式类图.png" alt="简单工厂模式类图"></p><p>简单工厂模式相对于工厂方法模式，去掉了<code>AbstractHumanFactory</code>抽象类， 同时把<code>createHuman</code>方法设置为静态类型， 简化了类的创建过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"人种生成错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Human whiteHuman = HumanFactory.createHuman(WhiteHuman.class);</span><br><span class="line">whiteHuman.getColor();</span><br><span class="line">whiteHuman.talk();</span><br><span class="line">Human blackHuman = HumanFactory.createHuman(BlackHuman.class);</span><br><span class="line">blackHuman.getColor();</span><br><span class="line">blackHuman.talk();</span><br><span class="line">Human yellowHuman = HumanFactory.createHuman(YellowHuman.class);</span><br><span class="line">yellowHuman.getColor();</span><br><span class="line">yellowHuman.talk();</span><br></pre></td></tr></table></figure><h4 id="升级为多个工厂类"><a href="#升级为多个工厂类" class="headerlink" title="升级为多个工厂类"></a>升级为多个工厂类</h4><p>在相对比较复杂的项目中，经常遇到初始化一个对象很耗费精力的情况，所有产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为每个产品定义一个创造者， 然后由调用者自己去选择与哪个工厂方法关联。</p><p><strong>多工厂模式</strong>的工厂抽象类，抽象方法中已经<strong>不再需要传递相关参数</strong>了， 因为每一个具体的工厂都已经非常明确自己的职责。但也给<strong>可扩展性</strong>和<strong>可维护性</strong>带来了一定的影响。</p><p><img src="../../../../images/设计模式/多个工厂类类图.png" alt="多个工厂类类图"></p><p>多工厂模式的抽象工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Human <span class="title">createHuman</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>黑色人种的创建工厂实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackHumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>黄色人种的创建工厂实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YellowHumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>白色人种的创建工厂实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteHumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Human whiteHuman = (<span class="keyword">new</span> WhiteHumanFactory()).createHuman();</span><br><span class="line">whiteHuman.getColor();</span><br><span class="line">whiteHuman.talk();</span><br><span class="line">Human blackHuman = (<span class="keyword">new</span> BlackHumanFactory()).createHuman();</span><br><span class="line">blackHuman.getColor();</span><br><span class="line">blackHuman.talk();</span><br><span class="line">Human yellowHuman = (<span class="keyword">new</span> YellowHumanFactory()).createHuman();</span><br><span class="line">yellowHuman.getColor();</span><br><span class="line">yellowHuman.talk();</span><br></pre></td></tr></table></figure><p>在复杂的应用中一般采用多工厂的方法， 然后再增加一个协调类， 避免调用者与各个子工厂交流， 协调类的作用是封装子工厂类， 对高层模块提供统一的访问接口。</p><h4 id="替代单例模式"><a href="#替代单例模式" class="headerlink" title="替代单例模式"></a>替代单例模式</h4><p>通过获得类构造器， 然后设置访问权限， 生成一个对象， 然后提供外部访问， 保证内存中的对象唯一。 通过工厂方法模式创建了一个单例对象， 该框架可以继续扩展， 在一个项目中可以产生一个<strong>单例构造器</strong>， 所有需要产生单例的类都遵循一定的规则 ， 然后通过扩展该框架。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cl= Class.forName(Singleton.class.getName());</span><br><span class="line">            <span class="comment">// 获得无参构造</span></span><br><span class="line">            Constructor constructor = cl.getDeclaredConstructor();</span><br><span class="line">            <span class="comment">// 设置无参构造是可访问的</span></span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 产生一个实例对象</span></span><br><span class="line">            singleton = (Singleton)constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h4><p>一个对象被消费完后，并不立即释放，工厂类保持其初始状态，等待再次被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Human&gt; humanMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Human <span class="title">createHuman</span><span class="params">(String type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Human human;</span><br><span class="line">        <span class="keyword">if</span> (humanMap.containsKey(type)) &#123;</span><br><span class="line">            human = humanMap.get(type);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (type.equals(<span class="string">"BlackHuman"</span>)) &#123;</span><br><span class="line">                human = <span class="keyword">new</span> BlackHuman();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"WhiteHuman"</span>)) &#123;</span><br><span class="line">                human = <span class="keyword">new</span> WhiteHuman();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                human = <span class="keyword">new</span> YellowHuman();</span><br><span class="line">            &#125;</span><br><span class="line">            humanMap.put(type, human);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> human;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟加载框架是可扩展的， 例如限制某一个产品类的最大实例化数量， 可以通过判断Map中已有的对象数量来实现，还可以用在<strong>对象初始化比较复杂</strong>的情况下， 例如<strong>硬件访问</strong>， 涉及多方面的交互， 则可以通过延迟加载降低对象的<strong>产生和销毁</strong>带来的<strong>复杂性</strong>。</p><hr><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>抽象工厂模式</strong>是一种比较常用的模式，为创建一组<strong>相关</strong>或<strong>相互依赖</strong>的对象提供一个接口， 且<strong>无须指定它们</strong><br><strong>的具体类</strong>。 当一个对象族有相同的约束时可以使用抽象工厂模式。</p><p>优点<strong>封装性</strong>，产品的具体实现细节高层模块不需要关心；产品族内的约束为<strong>非公开</strong>状态。缺点<strong>产品族扩展非常困难</strong>，严重违反开闭原则。</p><p><img src="../../../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="抽象工厂模式类图"></p><p><strong>抽象工厂模式</strong>是<strong>工厂方法模式</strong>的<strong>升级版</strong>， 在有多个业务品种、 业务分类时， 通过抽象工厂模式产生需要的对象是一种非常好的解决方式。</p><p>人种接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人种有三个抽象类， 负责人种的抽象属性定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBlackHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractWhiteHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractYellowHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个抽象类都有两个实现类， 分别实现公共的最细节、 最具体的事物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleYellowHuman</span> <span class="keyword">extends</span> <span class="title">AbstractYellowHuman</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄种女人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaleYellowHuman</span> <span class="keyword">extends</span> <span class="title">AbstractYellowHuman</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄种男人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>制造人类的抽象工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Human <span class="title">createYellowHuman</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Human <span class="title">createWhiteHuman</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Human <span class="title">createBlackHuman</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>制造男人和女人的具体工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleFactory</span> <span class="keyword">implements</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createYellowHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FemaleYellowHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createWhiteHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FemaleWhiteHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createBlackHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FemaleBlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaleFactory</span> <span class="keyword">implements</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createYellowHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleYellowHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createWhiteHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleWhiteHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createBlackHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleBlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HumanFactory maleHumanFactory = <span class="keyword">new</span> MaleFactory();</span><br><span class="line">HumanFactory femaleHumanFactory = <span class="keyword">new</span> FemaleFactory();</span><br><span class="line">Human maleYellowHuman = maleHumanFactory.createYellowHuman();</span><br><span class="line">Human femaleYellowHuman = femaleHumanFactory.createYellowHuman();</span><br><span class="line">femaleYellowHuman.getColor();</span><br><span class="line">femaleYellowHuman.talk();</span><br><span class="line">femaleYellowHuman.getSex();</span><br><span class="line">maleYellowHuman.getColor();</span><br><span class="line">maleYellowHuman.talk();</span><br><span class="line">maleYellowHuman.getSex();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工厂方法模式&quot;&gt;&lt;a href=&quot;#工厂方法模式&quot; class=&quot;headerlink&quot; title=&quot;工厂方法模式&quot;&gt;&lt;/a&gt;工厂方法模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;工厂方法模式&lt;/strong&gt;使用的频率非常高 ，用于创建对象的接口， 让&lt;strong&gt;子
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，工厂方法模式，抽象工厂模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>锁优化</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/锁优化/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2020-10-30T06:43:58.459Z</updated>
    
    <content type="html"><![CDATA[<p><strong>高效并发</strong>是从<code>JDK1.5</code>到<code>JDK1.6</code>的一个重要改进，<code>HotSpot</code>虚拟机为了<strong>在线程之间更高效地共享数据</strong>，以及<strong>解决竞争问题</strong>，从而<strong>提高程序的执行效率</strong>在该版本上花费了大量精力去<strong>实现各种锁优化技术</strong>，如<strong>适应性自旋</strong>、<strong>锁消除</strong>、<strong>锁粗化</strong>、<strong>轻量级锁</strong>和<strong>偏向锁</strong>等。</p><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p><strong>互斥同步</strong>对<strong>性能最大的影响</strong>是<strong>阻塞的实现</strong>，<strong>挂起线程</strong>和<strong>恢复线程</strong>的操作都需要转入<strong>内核态</strong>中完成，这会给操作系统的并发性能带来很大的压力。在许多应用上，<strong>共享数据的锁定状态只会持续很短一段时间</strong>，为了这段时间去<strong>挂起</strong>和<strong>恢复</strong>线程<strong>并不值得</strong>。</p><p>两个或以上的线程同时并行执行，可以让后面请求锁的那个线程<strong>不放弃处理器执行时间</strong>，而是<strong>执行一个忙循环</strong>，也就是所谓的<strong>自旋</strong>，看看<strong>持有锁</strong>的线程<strong>是否会很快就释放锁</strong>，这项技术就是所谓的<strong>自旋锁</strong>。</p><p><strong>自旋锁</strong>在<code>JDK1.4.2</code>中引入但<strong>默认关闭</strong>，使用<code>-XX:UseSpinning</code>参数开启，<strong><code>JDK1.6</code>默认开启</strong>自旋锁。自旋等待不能代替阻塞，自旋等待本身虽然避免了线程切换的开销，但<strong>还是要占用处理器时间</strong>，若锁被占用的时间<strong>很短</strong>，<strong>自旋等待的效果会非常好</strong>，若锁被占用的时间<strong>很长</strong>，自旋等待的线程只会白白消耗处理器资源，<strong>反而带来性能上的浪费</strong>。</p><p><strong>自旋等待的时间</strong>是有一定的<strong>限度</strong>，若自旋<strong>超过了限定的次数</strong>仍然<strong>没有成功获得锁</strong>，就<strong>使用传统的方式挂起线程</strong>。<strong>自旋次数默认为<code>10</code>次</strong>，可使用参数<strong><code>-XX:PreBlockSpin</code></strong>来更改。</p><p><code>JDK1.6</code>引入了<strong>自适应的自旋锁</strong>，自适应意味着<strong>自旋</strong>的<strong>时间不再固定</strong>，而是由<strong>前一次</strong>在<strong>同一个锁上</strong>的<strong>自旋时间</strong>及<strong>锁的拥有者的状态来</strong>决定。若在同一个锁对象上，<strong>上一次是通过自旋等待获得的锁</strong>，且持有锁的<strong>线程正在运行中</strong>，则虚拟机将<strong>认为这次自旋锁也很有可能再次成功</strong>，进而它将<strong>运行自旋等待持续相对更长的时间</strong>。且若对于某个锁，通过自旋的方式<strong>很少成功获得过锁</strong>，则在以后要获取该锁时将可能<strong>省略自旋过程</strong>，以<strong>避免浪费处理器资源</strong>。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁的消除是指虚拟机<strong>即时编译器</strong>在运行时，对一些<strong>代码上要求同步</strong>，但被检测到<strong>不可能</strong>存在<strong>共享数据竞争</strong>的锁进行消除。锁消除<strong>主要</strong>判定<strong>依据</strong>来源于<strong>逃逸分析</strong>的数据支持，若判断在一段代码中，<strong>堆</strong>上所有数据都<strong>不会逃逸</strong>出去从而被其他线程访问到，即可以将其当做栈上数据对待，认为其是私有的，即可进行锁消除。</p><p>Java中有许多同步措施并不是程序员自己加入的，且同步代码在Java中是普遍存在的。例如最简单的String字符串的相加，由于String是不可变的类，在<code>JDK1.5</code>后将转化为<code>StringBuilder</code>对象的连续<code>append</code>操作，而每个<code>append</code>方法中都有一个同步块。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上总是推荐将<strong>同步块</strong>的<strong>作用范围</strong>限制得<strong>尽可能小</strong>，即只在<strong>共享数据</strong>的实际作用域中才进行同步，是为了使得需要同步得操作数量尽可能小，当存在竞争时，等待锁的线程也能<strong>尽可能快的拿到锁</strong>。</p><p>但若一系列<strong>连续操作</strong>都对<strong>同一个对象反复加锁和解锁</strong>，甚至<strong>加锁操作</strong>是出现在<strong>循环体</strong>中，即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><p>如连续的<code>StringBuilder</code>的<code>append</code>方法，若虚拟机检查到有这样<strong>一串零碎的操作都对同一个对象加锁</strong>，将会把加锁同步得范围<strong>粗化到整个操作序列的外部</strong>。连续的<code>StringBuilder</code>的<code>append</code>操作会扩展到第一个<code>append</code>操作之前直到最后一个<code>append</code>操作之后，这样加一次锁即可。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>传统</strong>的锁机制成为<strong>重量级锁</strong>，<strong>轻量级</strong>是相对于使用<strong>操作系统互斥量</strong>来实现的<strong>传统锁</strong>而言的，是<code>JDK1.6</code>加入的新型锁机制。轻量级锁<strong>并不是</strong>用来<strong>代替</strong>重量级锁的，其本意是在<strong>没有多线程竞争</strong>的前提下，<strong>减少重量级锁</strong>使操作系统互斥量产生的性能消耗。</p><p><strong><a href="../../VM/堆中对象分配&amp;布局&amp;访问#对象的内存布局">对象头</a></strong>中用于存储对象自身的<strong>运行时数据</strong>信息是实现<strong>轻量级锁</strong>和<strong>偏向锁</strong>的关键，官方称为<code>Mark Word</code>。对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，<code>Mark Word</code>被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><p>在<code>32</code>位<code>HotSpot</code>虚拟机中， 对象<strong>未被锁定</strong>的状态下，<code>Mark Word</code>的<strong><code>32</code>比特</strong>空间里的<strong><code>25</code>比特</strong>将用于存储<strong>对象哈希码</strong>， <strong><code>4</code>比特</strong>用于存储对象<strong>分代年龄</strong>， <strong><code>2</code>比特</strong>用于存储<strong>锁标志位</strong>， <strong><code>1</code>比特</strong>固定为<strong><code>0</code></strong>表示<strong>未进入偏向模式</strong>。 对象除了未被锁定的正常状态外， 还有<strong>轻量级锁定</strong>、 <strong>重量级锁定</strong>、 <strong><code>GC</code>标记</strong>、 <strong>可偏向</strong>等几种不同状态 。</p><p><img src="../../../../../images/Java/HotSpot虚拟机对象头Mark Word.png" alt="HotSpot虚拟机对象头Mark Word"></p><p>代码<strong>即将进入同步块</strong>时， 若<strong>锁标志位</strong>为<strong><code>01</code>状态</strong>即同步对象没有被锁定 ， 虚拟机首先将在<strong>当前线程</strong>的<strong>栈帧</strong>中建立一个名为<strong><code>Lock Record</code>锁记录</strong> 的空间， 用于存储锁对象目前的<strong><code>Mark Word</code>的拷贝</strong>，官方将该拷贝称为<strong><code>Displaced Mark Word</code></strong> 。</p><p><img src="../../../../../images/Java/轻量级锁CAS操作之前堆栈与对象的状态.png" alt="轻量级锁CAS操作之前堆栈与对象的状态"></p><p>虚拟机将使用<strong><code>CAS</code>操作</strong>尝试把对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。 若更新成功， 即代表该线程拥有了该对象的锁， 且对象<code>Mark Word</code>的<strong>锁标志位</strong>将转变为<strong><code>00</code></strong>， 表示此对象处于轻量级锁定状态。此时<strong>线程堆栈</strong>与<strong>对象头</strong>的状态如下：</p><p><img src="../../../../../images/Java/轻量级锁CAS操作之后堆栈与对象的状态.png" alt="轻量级锁CAS操作之后堆栈与对象的状态"></p><p>若更新失败， 意味着<strong>至少</strong>存在一条线程与当前线程<strong>竞争</strong>获取该对象的<strong>锁</strong>。 虚拟机首先会检查对象的<code>Mark Word</code>是否指向<strong>当前线程的栈帧</strong>， <strong>若是</strong>则说明当<strong>前线程</strong>已经<strong>拥有</strong>了<strong>该对象的锁</strong>， 则直接进入同步块， 否则说明该锁对象已经被其他线程抢占。 若出现<strong>两条以上</strong>的线程争用<strong>同一个锁</strong>， 则<strong>轻量级锁不再有效</strong>， <strong>必须要膨胀为重量级锁</strong>， <strong>锁标志</strong>的状态值变为<strong><code>10</code></strong>， 此时<code>Mark Word</code>中存储的就是指向<strong>重量级锁</strong>（互斥量） 的<strong>指针</strong>， 等待锁的线程也必须进入阻塞状态。 </p><p><strong>轻量级锁解锁过程</strong>也同样是<strong>通过<code>CAS</code>操作</strong>来进行， 若对象的<code>Mark Word</code>仍然指向线程的锁记录， 则用<strong><code>CAS</code>操作</strong>把对象当前的<code>Mark Word</code>和<strong>线程中复制的<code>Displaced Mark Word</code>替换回来</strong>。 若能<strong>成功替换</strong>， 则整个<strong>同步过程顺利完成</strong>； 若<strong>替换失败</strong>， 则说明有<strong>其他线程尝试过获取该锁</strong>， 就要在<strong>释放锁的同时， 唤醒被挂起的线程</strong>。</p><p><strong>轻量级锁</strong>能<strong>提升</strong>程序<strong>同步性能</strong>的<strong>依据</strong>：对于<strong>绝大部分的锁</strong>， 在<strong>整个同步周期内都不存在竞争</strong>，这一经验法则。若没有竞争， <strong>轻量级锁</strong>便通过<strong><code>CAS</code>操作</strong>成功<strong>避免了使用互斥量</strong>的开销； 但如果确实<strong>存在锁竞争</strong>， 除了互斥量的本身开销外， 还<strong>额外发生了<code>CAS</code>操作</strong>的开销。 因此在<strong>有竞争</strong>的情况下，<strong>轻量级锁反而会比传统的重量级锁更慢</strong> 。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>偏向锁</strong>是<code>JDK1.6</code>引入的一项<strong>锁优化措施</strong>， 其<strong>目的</strong>是<strong>消除</strong>数据在<strong>无竞争</strong>情况下的<strong>同步原语</strong>，进一步提高程序的运行性能。 若说<strong>轻量级锁</strong>是在<strong>无竞争</strong>的情况下使用<strong><code>CAS</code>操作</strong>去<strong>消除同步</strong>使用的<strong>互斥量</strong>， <strong>偏向锁</strong>就是在<strong>无竞争</strong>的情况下把<strong>整个同步都消除掉</strong>。</p><p>偏向锁的意思是<strong>锁会偏向于第一个获得它的线程</strong>， 若在接下来的执行过程中， 该锁<strong>一直没有被其他的线程获取</strong>， 则持有<strong>偏向锁</strong>的线程将<strong>永远不需要再进行同步</strong>。</p><p>若虚拟机启用了<strong>偏向锁</strong>， 则当锁对象第一次被线程获取时， 虚拟机将把对象头中的<strong>标志位</strong>设置为<strong><code>01</code></strong>、 把<strong>偏向模式设置为<code>1</code></strong>， 表示进入<strong>偏向模式</strong>。 同时使用<strong><code>CAS</code></strong>操作把获取到该锁的<strong>线程的<code>ID</code></strong>记录在对象的<code>Mark Word</code>中。 若<strong><code>CAS</code></strong>操作成功， <strong>持有偏向锁的线程</strong>以后每次进入<strong>该锁相关的同步块</strong>时， 虚拟机<strong>都可以不再进行任何同步操作</strong> 。偏向锁启用参数<strong><code>-XX：+UseBiasedLocking</code></strong>。</p><p>一旦出现另外一个线程去<strong>尝试获取该锁</strong>， <strong>偏向模式立即结束</strong>。 根据锁对象目前<strong>是否处于被锁定的状态决定是否撤销偏向</strong> ， 撤销后<strong>标志位恢复到未锁定</strong>或<strong>轻量级锁定</strong>的状态， 后续的同步操作按照<strong>轻量级锁</strong>执行。</p><p><img src="../../../../../images/Java/偏向锁、 轻量级锁的状态转化及对象Mark Word的关系.png" alt="偏向锁、 轻量级锁的状态转化及对象Mark Word的关系 "></p><p>当对象进入<strong>偏向状态</strong>时， <code>Mark Word</code>大部分的空间（23个比特） 都用于存储<strong>持有锁的线程<code>ID</code></strong>了， 这部分空间占用了原有<strong>存储对象哈希码</strong>的位置 。</p><p><code>Java</code>中对象如果计算过<strong>哈希码</strong>， 就应该一直保持该值不变 ，否则很多依赖对象哈希码的<code>API</code>都可能存在出错风险。 而作为绝大多数对象哈希码来源的<strong><code>Object::hashCode()</code></strong>方法， 返回的是<strong>对象的一致性哈希码</strong>， 该值是能<strong>强制保证不变</strong>的， 它通过在<strong>对象头中存储计算结果</strong>来保证第一次计算之后， <strong>再次调用该方法取到的哈希码值永远不会再发生改变</strong>。 因此当一个对象<strong>已经计算过一致性哈希码</strong>后， 则<strong>再也无法进入偏向锁状态</strong>了； 而当一个对象当前<strong>正处于偏向锁状态</strong>， 又收到<strong>需要计算</strong>其<strong>一致性哈希码</strong>请求时， 其<strong>偏向状态会被立即撤销</strong>， 且<strong>锁会膨胀为重量级锁</strong>。 在重量级锁的实现中， <strong>对象头指向了重量级锁的位置</strong>， 代表重量级锁的<strong><code>ObjectMonitor</code></strong>类里有字段可以记录<strong>非加锁状态下</strong>的<code>Mark Word</code>， 其中自然可以存储<strong>原来的哈希码</strong>。</p><p><strong>偏向锁</strong>可以<strong>提高带有同步但无竞争</strong>的程序性能， 但同样是一个带有<strong>效益权衡</strong>性质的优化，也就是说它并非总是对程序运行有利。 若程序中大多数锁都总是被多个不同的线程访问， 偏向模式则是多余的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;高效并发&lt;/strong&gt;是从&lt;code&gt;JDK1.5&lt;/code&gt;到&lt;code&gt;JDK1.6&lt;/code&gt;的一个重要改进，&lt;code&gt;HotSpot&lt;/code&gt;虚拟机为了&lt;strong&gt;在线程之间更高效地共享数据&lt;/strong&gt;，以及&lt;strong&gt;解
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="多线程，Thread" scheme="https://yaoyinglong.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8CThread/"/>
    
  </entry>
  
  <entry>
    <title>序列化</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/序列化/</id>
    <published>2020-10-26T16:00:00.000Z</published>
    <updated>2020-10-26T09:13:21.749Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="序列化" scheme="https://yaoyinglong.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>注解实现及应用</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/注解实现及应用/</id>
    <published>2020-10-25T16:00:00.000Z</published>
    <updated>2020-10-26T09:12:04.368Z</updated>
    
    <content type="html"><![CDATA[<p>注解一种<strong>标记式</strong>高耦合的配置方式，<code>Java</code>注解是从<code>JDK1.5</code>引入的。<strong>注解</strong>用于为Java代码提供<strong>元数据</strong>。作为元数据注解<strong>不直接影响</strong>代码执行。注解的本质就是一个<code>Annotation</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解本身就是<code>Annotation</code>接口的子接口，注解中其实可以有属性和方法，但接口中属性和方法都是<code>static fianl</code>的，对于注解没有意义，而<strong>定义接口的方法就相当于注解的属性</strong>，也就是为什么说注解只有成员变量，其实其就是接口的方法，也就是为什么成员变量会有括号。</p><p>注解属性类型可以有一下几种类型：</p><ul><li>基本数据类型</li><li>String</li><li>枚举类型</li><li>注解类型</li><li>Class类型</li><li>以上类型的一维数组类型</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>作用于注解的注解，<code>JDK</code>提供的元注解有<strong><code>@Retention</code></strong>、<strong><code>@Target</code></strong>、<strong><code>@Documented</code></strong>、<strong><code>@Inherited</code></strong>以及<code>JDK8</code>新增的<strong><code>@Repeatable</code></strong>五种。</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>表示注解存在阶段是保留在<strong>源码</strong>（编译期），<strong>字节码</strong>（类加载）或者<strong>运行期</strong>（<code>JVM</code>中运行），在<strong><code>@Retention</code></strong>注解中使用枚举<strong><code>RetentionPolicy</code></strong>来表示注解的<strong>生命周期</strong>。</p><ul><li><p><strong><code>@Retention(RetentionPolicy.SOURCE)</code></strong>，注解仅存在于<strong>源码</strong>中，在<strong><code>class</code>字节码文件中不包含</strong>。</p></li><li><p><strong><code>@Retention(RetentionPolicy.CLASS)</code></strong>， <strong>默认</strong>的保留策略，注解会在class字节码文件中存在，但<strong>运行时无法获得</strong>。</p></li><li><p><strong><code>@Retention(RetentionPolicy.RUNTIME)</code></strong>， 注解会在class字节码文件中存在，在<strong>运行时可以通过反射获取</strong>。</p></li></ul><p>若自定义注解，自定义注解如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现我们目的，所以自定义注解中肯定是使用 <strong><code>@Retention(RetentionPolicy.RUNTIME)</code></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>表示<strong>注解的作用目标</strong>，作用范围可以是<strong>类</strong>、<strong>方法</strong>、<strong>方法参数</strong>等，通过枚举类<strong><code>ElementType</code></strong>表达作用类型。</p><ul><li><p><strong><code>@Target(ElementType.TYPE)</code></strong> 作用<strong>接口</strong>、<strong>类</strong>、<strong>枚举</strong>、<strong>注解</strong></p></li><li><p><strong><code>@Target(ElementType.FIELD)</code></strong> 作用<strong>属性字段</strong>、<strong>枚举的常量</strong></p></li><li><p><strong><code>@Target(ElementType.METHOD)</code></strong> 作用<strong>方法</strong></p></li><li><p><strong><code>@Target(ElementType.PARAMETER)</code></strong> 作用<strong>方法参数</strong></p></li><li><p><strong><code>@Target(ElementType.CONSTRUCTOR)</code></strong> 作用<strong>构造函数</strong></p></li><li><p><strong><code>@Target(ElementType.LOCAL_VARIABLE)</code></strong>作用<strong>局部变量</strong></p></li><li><p><strong><code>@Target(ElementType.ANNOTATION_TYPE)</code></strong>作用于<strong>注解</strong>（<code>@Retention</code>注解中就使用该属性）</p></li><li><p><strong><code>@Target(ElementType.PACKAGE)</code></strong> 作用于<strong>包</strong></p></li><li><p><strong><code>@Target(ElementType.TYPE_PARAMETER)</code></strong> 作用于类型<strong>泛型</strong>，即泛型方法、泛型类、泛型接口 （<code>JDK8</code>加入）</p></li><li><p><strong><code>@Target(ElementType.TYPE_USE)</code></strong> 类型使用，可以<strong>用于标注任意类型除了 <code>class</code></strong> （<code>JDK8</code>加入）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>其作用是能够将注解中的元素包含到 <code>Javadoc</code> 中去。</p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>被<code>@Inherited</code>注解了的<strong>注解</strong>修饰了一个父类，若其子类没有被其他注解修饰，则其子类也继承了父类的注解。</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>被该元注解修饰的注解可以<strong>同时作用一个对象多次</strong>，但是每次作用注解又可以代表不同的含义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value = ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Prople &#123;</span><br><span class="line">    Game[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Prople.class)</span><br><span class="line"><span class="meta">@Target</span>(value = ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Game &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayGame</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Game</span>(value = <span class="string">"LOL"</span>)</span><br><span class="line">    <span class="meta">@Game</span>(value = <span class="string">"PUBG"</span>)</span><br><span class="line">    <span class="meta">@Game</span>(value = <span class="string">"NFS"</span>)</span><br><span class="line">    <span class="meta">@Game</span>(value = <span class="string">"Dirt4"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><p>注解的属性与类中定义的变量有异曲同工之处，注解中的变量都是成员变量，并且注解中是<strong>没有方法</strong>的，<strong>只有成员变量</strong>，<strong>变量名就是使用注解括号中对应的参数名</strong>，变量返回值就是使用注解括号中对应参数类型。</p><p><code>@Repeatable</code>注解中的变量则类型则是对应<code>Annotation</code>（接口）的泛型<code>Class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span></span><br><span class="line"><span class="comment">     * repeatable annotation type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the containing annotation type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK内置注解"><a href="#JDK内置注解" class="headerlink" title="JDK内置注解"></a>JDK内置注解</h3><p><code>JDK</code>预定义了<strong><code>@Override</code></strong>、<strong><code>@Deprecated</code></strong>、<strong><code>@SuppressWarnings</code></strong>三种注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>若注解有<strong>多个属性</strong>，给属性赋值时使用<strong>逗号隔开</strong>分别赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value = ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InvokeListener &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "baseService"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> <span class="keyword">default</span> 25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@InvokeListener</span>(name = <span class="string">"taskService"</span>, weight = <span class="number">50</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskServiceImpl</span> <span class="keyword">implements</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@FieldListener</span>(value = <span class="string">"baseTask"</span>)</span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自定义注解后在使用时通常需要获取注解的属性，需要通过反射的方式获取。获取类注解属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;TaskServiceImpl&gt; taskServiceClass = TaskServiceImpl.class;</span><br><span class="line"><span class="keyword">boolean</span> annotationPresent = taskServiceClass.isAnnotationPresent(InvokeListener.class);</span><br><span class="line"><span class="keyword">if</span> (annotationPresent) &#123;</span><br><span class="line">    InvokeListener annotation = taskServiceClass.getAnnotation(InvokeListener.class);</span><br><span class="line">    System.out.println(annotation.name());</span><br><span class="line">    System.out.println(annotation.weight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取方法注解属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Method play = PlayGame.class.getDeclaredMethod(<span class="string">"play"</span>);</span><br><span class="line"><span class="keyword">if</span> (play != <span class="keyword">null</span>) &#123;</span><br><span class="line">    People annotation = play.getAnnotation(People.class);</span><br><span class="line">    Game[] value = annotation.value();</span><br><span class="line">    <span class="keyword">for</span> (Game game : value) &#123;</span><br><span class="line">        System.out.println(game.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取属性注解属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;TaskServiceImpl&gt; taskServiceClass = TaskServiceImpl.class;</span><br><span class="line">Field field = taskServiceClass.getDeclaredField(<span class="string">"taskName"</span>);</span><br><span class="line"><span class="keyword">boolean</span> annotationPresent = field.isAnnotationPresent(FieldListener.class);</span><br><span class="line"><span class="keyword">if</span> (annotationPresent) &#123;</span><br><span class="line">    FieldListener annotation = field.getAnnotation(FieldListener.class);</span><br><span class="line">    System.out.println(annotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring中使用自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerConfig</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; beanMap = applicationContext.getBeansWithAnnotation(InvokeListener.class);</span><br><span class="line">        <span class="keyword">for</span> (Object bean : beanMap.values()) &#123;</span><br><span class="line">            Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                FieldListener fieldListener = field.getAnnotation(FieldListener.class);</span><br><span class="line">                <span class="keyword">if</span> (fieldListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(fieldListener.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Method[] methods = bean.getClass().getMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                MethodListener methodListener = method.getAnnotation(MethodListener.class);</span><br><span class="line">                <span class="keyword">if</span> (methodListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(methodListener.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注解一种&lt;strong&gt;标记式&lt;/strong&gt;高耦合的配置方式，&lt;code&gt;Java&lt;/code&gt;注解是从&lt;code&gt;JDK1.5&lt;/code&gt;引入的。&lt;strong&gt;注解&lt;/strong&gt;用于为Java代码提供&lt;strong&gt;元数据&lt;/strong&gt;。作为元数据注解&lt;s
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="注解" scheme="https://yaoyinglong.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized总结</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Synchronized%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Synchronized总结/</id>
    <published>2020-10-20T16:00:00.000Z</published>
    <updated>2020-11-12T02:13:37.789Z</updated>
    
    <content type="html"><![CDATA[<p><code>synchronized</code>是<code>Java</code>中解决并发问题的一种最常用最简单的方法 ，它可以确保线程<strong>互斥</strong>的访问同步代码，保证方法或者代码块在运行时，<strong>同一时刻只有一个方法</strong>可以进入到<strong>临界区</strong>，同时它还可以保证<strong>共享变量</strong>的内存<strong>可见性</strong>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>虚拟机支持<strong>方法级的同步</strong>和<strong>方法内部一段指令序列的同步</strong>，两种同步都使用<strong>管程<code>Monitor</code>来支持</strong>的。</p><p><strong>方法级的同步是隐式的，无须通过字节码指令来控制</strong>，它<strong>实现在方法调用</strong>和<strong>返回操作</strong>之中。虚拟机可以从<strong>方法常量池</strong>的<strong>方法结构中</strong>的<strong><code>ACC_SYNCHRONIZED</code>访问标志</strong>得知方法<strong>是否声明为同步方法</strong>。当方法调用时，调用的指令将会<strong>检查方法的<code>ACC_SYNCHRONIZED</code>访问标志</strong>是否被设置，若被设置，执行线程就要求<strong>先成功持有管程<code>Monitor</code></strong>，然后才能执行方法，最后当方法执行完成，<strong>无论是否正常完成都释放管程Monitor</strong>，方法执行期间，执行线程持有了<strong>管程<code>Monitor</code></strong>，其他任何线程都无法再获得同一个<strong>管程<code>Monitor</code></strong>。若同步方法<strong>执行期间抛出异常</strong>，且方法<strong>内部无法处理异常</strong>，同步方法所持有的<strong>管程<code>Monitor</code></strong>将在<strong>异常抛到同步方法外时自动释放</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Synchronized"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后的具体信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2// Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3// String Synchronized</span><br><span class="line">         5: invokevirtual #4// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>同步一段指令集序列</strong>通常是通过<strong><code>synchronized</code>语句块</strong>来完成，<strong>虚拟机的指令集使用<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持<code>synchronized</code>关键字的语义，正确实现<code>synchronized</code>关键字</strong>需要<strong><code>Javac</code>编译器</strong>和<strong><code>Java</code>虚拟机</strong>共同协作支持，编译器必须保证方法通过任何方式完成，方法中调用过的<strong>每条<code>monitorenter</code>指令</strong>都必须执行其<strong>对应的<code>monitorexit</code>指令</strong>，<strong>无论该方法是否正常结束</strong>。</p><p><strong>为了保证方法异常完成时<code>monitorenter</code>和<code>monitorexit</code>指令能正确配对执行，编译器会自动产生一个异常处理器，且声明可处理的所有异常，来执行<code>monitorexit</code>指令</strong>。</p><p><code>monitorenter</code>和<code>monitorexit</code>这两个字节码<strong>都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象</strong>。若<strong><code>synchronized</code></strong>明确指定了对象参数，那就是这个对象的<code>reference</code>，若没有明确指定，就根据<strong>synchronized</strong>修饰的是<strong>实例方法</strong>还是<strong>类方法</strong>，则取对应的<strong>对象实例</strong>或<strong>Class对象</strong>来作为锁对象。</p><p>虚拟机规范要求，执行<strong><code>monitorenter</code></strong>指令时，首先尝试获取对象的锁，若对象<strong>没有被锁定</strong>或当前线程<strong>已经拥有这个对象的锁</strong>，将<strong>锁的计数器加一</strong>，执行<strong><code>monitorexit</code></strong>指令时将<strong>锁计数器减一</strong>，当<strong>计数器为零时锁被释放</strong>。若<strong>获取对象锁失败，当前线程阻塞等待</strong>，直到对象锁被另一个线程释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Synchronized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后的具体信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter</span><br><span class="line">         4: getstatic     #2// Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3// String Synchronized</span><br><span class="line">         9: invokevirtual #4// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: monitorexit</span><br><span class="line">        <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">        <span class="number">17</span>: astore_2</span><br><span class="line">        <span class="number">18</span>: aload_1</span><br><span class="line">        <span class="number">19</span>: monitorexit</span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: athrow</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong><code>synchronized</code></strong>同步块对<strong>同一线程是可重入的</strong>，不会将自己死锁，但是是<strong>不可中断</strong>的。同步块在已进入的线程执行完成之前，会阻塞后面其他线程的进入。<code>Java</code>线程是<strong>映射到操作系统原生线程</strong>上的，阻塞或唤醒线程都需要操作系统帮忙，需要从<strong>用户状态</strong>转换到<strong>核心态</strong>中，因此转态<strong>转换需要耗费很多处理器时间</strong>。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>Java</code>中使用<code>synchronized</code>可使用在<strong>代码块</strong>和<strong>方法</strong>中，<code>synchronized</code>用的位置不同锁得对象就不同。</p><table><thead><tr><th>分类</th><th>被锁对象</th><th>实例</th></tr></thead><tbody><tr><td>实例方法</td><td>类得实例对象</td><td><code>public synchronized void sync1() {}</code></td></tr><tr><td>静态方法</td><td>类对象</td><td><code>public static synchronized void sync2() {}</code></td></tr><tr><td>实例对象</td><td>类得实例对象</td><td><code>synchronized (this) {}</code></td></tr><tr><td>class对象</td><td>类对象</td><td><code>synchronized (SynchronizedDemo.class) {}</code></td></tr><tr><td>任意实例对象Object</td><td>实例对象Object</td><td><code>String lock = &quot;&quot;; synchronized (lock) {}</code></td></tr></tbody></table><p>当一个线程访问<strong>某对象</strong>的<strong><code>synchronized</code>方法</strong>或者<strong><code>synchronized</code>代码块</strong>时，其他线程对<strong>该对象</strong>的该<strong><code>synchronized</code>方法</strong>或者<strong><code>synchronized</code>代码块</strong>的访问将被阻塞；其他线程<strong>仍可以访问</strong>该对象的<strong>非同步</strong>代码块；其他线程对<strong>该对象</strong>的<strong>其他</strong>的<strong><code>synchronized</code>方法</strong>或者<strong><code>synchronized</code>代码块</strong>的访问<strong>将被阻塞</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo instance = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(instance, <span class="string">"thread1"</span>);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(instance, <span class="string">"thread2"</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    <span class="keyword">while</span> (thread1.isAlive() || thread2.isAlive()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下，可以很明显的看出run方法里的代码是顺序执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am thread1</span><br><span class="line">thread1 运行结束</span><br><span class="line">I am thread2</span><br><span class="line">thread2 运行结束</span><br></pre></td></tr></table></figure><p>如下写法运行结果一样，除了使用this对象作为锁，也可以定义一个专门的锁对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以定义多个锁对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am lock1 "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" lock1部分运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am lock2 "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" lock2部分运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下，可以看出run方法里的代码是时被执行的。当<code>thread1</code>释放掉<code>lock1</code>的锁时，<code>thread2</code>即可获得<code>lock1</code>的锁，所以<code>thread2</code>的<code>lock1</code>中的同步代码块可以与<code>thread1</code>的<code>lock2</code>中的同步代码块并行执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I am lock1 thread1</span><br><span class="line">thread1 lock1部分运行结束</span><br><span class="line">I am lock2 thread1</span><br><span class="line">I am lock1 thread2</span><br><span class="line">thread1 lock2部分运行结束</span><br><span class="line">thread2 lock1部分运行结束</span><br><span class="line">I am lock2 thread2</span><br><span class="line">thread2 lock2部分运行结束</span><br></pre></td></tr></table></figure><h5 id="方法锁"><a href="#方法锁" class="headerlink" title="方法锁"></a>方法锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法锁："</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法锁：thread1</span><br><span class="line">thread1运行结束</span><br><span class="line">方法锁：thread2</span><br><span class="line">thread2运行结束</span><br></pre></td></tr></table></figure><h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h5><p><code>Java</code>类可能有多个对象，但只有一个<code>Class</code>对象，而类锁的锁对象就是该类的<code>Class</code>对象，类锁有两种形式：将<strong><code>synchronized</code>加在<code>static</code>方法</strong>上和<strong><code>synchronized(*.class)</code>代码块</strong>。</p><p><strong><code>synchronized</code>加在<code>static</code>方法</strong>上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassStatic4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态方法锁："</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedClassStatic4 instance1 = <span class="keyword">new</span> SynchronizedClassStatic4();</span><br><span class="line">        SynchronizedClassStatic4 instance2 = <span class="keyword">new</span> SynchronizedClassStatic4();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1, <span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2, <span class="string">"thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">while</span> (thread1.isAlive() || thread2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">静态方法锁：thread2</span><br><span class="line">thread2运行结束</span><br><span class="line">静态方法锁：thread1</span><br><span class="line">thread1运行结束</span><br></pre></td></tr></table></figure><p><strong><code>synchronized(*.class)</code>代码块</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassClass5</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedClassClass5.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"类锁同步代码块形式："</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedClassClass5 instance1 = <span class="keyword">new</span> SynchronizedClassClass5();</span><br><span class="line">        SynchronizedClassClass5 instance2 = <span class="keyword">new</span> SynchronizedClassClass5();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1, <span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2, <span class="string">"thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">while</span> (thread1.isAlive() || thread2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类锁同步代码块形式：thread1</span><br><span class="line">thread1运行结束</span><br><span class="line">类锁同步代码块形式：thread2</span><br><span class="line">thread2运行结束</span><br></pre></td></tr></table></figure><p>多线程访问<strong><code>synchronized</code></strong>同步方法常见的<strong><code>7</code>种</strong>情况：</p><ul><li>两个线程同时访问<strong>一个对象的同步方法</strong>：阻塞</li><li>两个线程访问的是<strong>两个对象的同步方法</strong>：非阻塞</li><li>两个线程访问的是<code>synchronized</code>的<strong>静态方法</strong>：阻塞</li><li><strong>同时</strong>访问<strong>同步方法</strong>和<strong>非同步方法</strong>：非阻塞</li><li>访问<strong>同一对象</strong>的<strong>不同</strong>的<strong>普通同步方法</strong>：阻塞</li><li>同时访问<strong>静态<code>synchronized</code></strong>和<strong>非静态<code>synchronized</code>方法</strong>：非阻塞</li><li>方法抛出<strong>异常</strong>后，<strong>会释放锁</strong></li></ul><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>同一个方法可重入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">        method(a + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的方法可重入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"methodA"</span>);</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"methodB"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的类可重入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"methodB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> <span class="keyword">extends</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass methodB"</span>);</span><br><span class="line">        <span class="keyword">super</span>.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是&lt;code&gt;Java&lt;/code&gt;中解决并发问题的一种最常用最简单的方法 ，它可以确保线程&lt;strong&gt;互斥&lt;/strong&gt;的访问同步代码，保证方法或者代码块在运行时，&lt;strong&gt;同一时刻只有一个方法&lt;/stron
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Synchronized" scheme="https://yaoyinglong.github.io/tags/Synchronized/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java与线程</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Java%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Java与线程/</id>
    <published>2020-10-20T16:00:00.000Z</published>
    <updated>2020-10-21T02:18:38.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>线程是<strong><code>CPU</code>调度</strong>的<strong>基本单位</strong>，是比进程更轻量级的<strong>调度执行单位</strong>，线程可以把进程的<strong>资源分配</strong>和<strong>执行调度</strong>分开，各个线程既可以共享进程资源（内存地址、文件<code>I/O</code>），又可以独立调度。</p><p>主流操作系统都提供了线程实现，<code>Java</code>提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行<code>start()</code>且还未结束的<code>Thread</code>类的实例代表一个线程。且<code>Thread</code>类所有关键方法都被声明为<code>Native</code>。在<code>Java</code>中<code>Native</code>方法意味着该方法没有使用或无法使用平台无关的手段实现，也可能为了执行效率而使用<code>Native</code>方法，通常最高效的手段是平台相关的手段。</p><p>实现线程主要有<code>3</code>种方式：<strong>使用内核线程实现</strong>、<strong>使用用户线程实现</strong>、<strong>使用用户线程加轻量级进程混合实现</strong></p><h5 id="使用内核实现"><a href="#使用内核实现" class="headerlink" title="使用内核实现"></a>使用内核实现</h5><p><strong><code>KTL</code>内核线程</strong>是直接由操作系统<strong>内核直接支持的线程</strong>，由<strong>内核</strong>来完成线程切换，内核通过<strong>操作调度器</strong>对线程进行调度，并负责将线程的任务<strong>映射到各个处理器上</strong>。每个内核线程可视为内核的一个<strong>分身</strong>。</p><p>程序<strong>一般不会</strong>使用<strong>内核线程</strong>，而是去使用内核线程的一种高级接口<strong>轻量级进程<code>LWP</code></strong>。<strong>轻量级进程</strong>就是通常意义上所说的<strong>线程</strong>，<strong>每个轻量级进程都由一个内核线程支持</strong>，这种关系称为<strong>一对一线程模型</strong>。</p><p><img src="../../../../../images/Java/轻量级进程与内核线程之间11的关系.jpg" alt="轻量级进程与内核线程之间1:1的关系"></p><p><strong>每个轻量级进程</strong>都成为一个<strong>独立的调度单元</strong>，但轻量级进程<strong>具有局限性</strong>，由于是基于内核线程实现的，故<strong>各种线程操作</strong>都需要进行<strong>系统调用</strong>。而<strong>系统调用的代价相对较高</strong>，需要在<strong>用户态</strong>和<strong>内核态</strong>中<strong>来回切换</strong>。每个轻量级进程都需要一个内核线程支持，因此<strong>轻量级进程要消耗一定的内核资源</strong>（如内核线程的栈空间），因此一个<strong>系统支持轻量级进程的数量是有限的</strong>。</p><h5 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h5><p><strong>广义</strong>上讲一个线程只要<strong>不是内核线程</strong>，就可以认为是用户线程，因此<strong>轻量级进程也属于用户线程</strong>，但轻量级进程始终是建立在内核之上的，许多操作系统都要进行<strong>系统调用</strong>，<strong>效率会受限</strong>。</p><p><strong>狭义</strong>上讲<strong>用户线程</strong>指的是<strong>完全建立在用户空间的线程库上</strong>，系统内核不能感知线程存在的实现。<strong>用户线程的建立、同步、销毁和调度完全在用户态中完成</strong>，不需要内核帮助。若程序实现得当，这种<strong>线程不需要切换到内核态</strong>，因此操作可以非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种<strong>进程</strong>与<strong>用户线程</strong>之间的<code>1：N</code>的关系称为<strong>一对多的线程模型</strong>。</p><p><img src="../../../../../images/Java/进程与用户线程之间1比N的关系.jpg" alt></p><p>用户线程<strong>优势在于不需要系统内核支援</strong>，<strong>劣势在于没有系统内核支援</strong>，<strong>所有线程操作都需要使用用户程序自己处理</strong>。由于操作系统只把处理器资源分配到进程，诸如<strong>阻塞处理</strong>、<strong>多处理器系统将线程映射到其他处理器上</strong>这类为题解决起来异常困难，甚至不可能完成。现在使用用户线程的程序越来越少了，Java曾经使用过用户线程但最终放弃了。</p><h5 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h5><p>还可以将<strong>内核线程</strong>与<strong>用户线程</strong>一起使用，在这种混合实现下，<strong>既存在用户线程，也存在轻量级进程</strong>。</p><p><img src="../../../../../images/Java/用户线程与轻量级进程间的N比M的关系.jpg" alt="用户线程与轻量级进程间的N:M的关系"></p><p>用户线程还是完全建立在用户空间中，因此<strong>用户线程</strong>的<strong>创建</strong>、<strong>切换</strong>、<strong>析构</strong>等操作依然廉价，且<strong>支持大规模的用户线程并发</strong>。操作系统提供的<strong>轻量级进程</strong>作为<strong>用户线程</strong>和<strong>内核线程</strong>之间的<strong>桥梁</strong>，通过轻量级进程使用内核提供的<strong>线程调度功能</strong>及<strong>处理器映射</strong>，且<strong>用户线程的系统调用要通过轻量级进程来完成</strong>，大大<strong>降低</strong>了整个<strong>进程被完全阻塞</strong>的风险。这种混合模式中，<strong>用户线程</strong>与<strong>轻量级进程</strong>的<strong>数量比是不固定的</strong>。</p><h5 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h5><p><code>JDK1.2</code>之前是基于<strong>用户线程</strong>实现的，<code>JDK1.2</code>中线程模型<strong>替换为基于操作系统原生线程模型</strong>来实现。<code>Sun JDK</code>的<code>Windows</code>版与<code>Linux</code>版都是使用<strong>一对一的线程模型</strong>实现的，<strong>一条<code>Java</code>线程就映射到一条轻量级进程</strong>中。</p><p>由于<code>Solaris</code>平台中操作系统的线程特性可同时支持<strong>一对一</strong>和<strong>多对多</strong>的线程模型。因此<code>Solaris</code>版的<code>JDK</code>中对应提供了两个平台专有的虚拟机参数<strong><code>-XX:+UseLWPSynchronization</code></strong>和<strong><code>-XX:UseBoundThreads</code></strong>来明确指定虚拟机使用哪种线程模型。</p><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p><strong>线程调度是指操作系统为线程分配处理器使用权的过程</strong>，主要有<strong>协同式线程调度</strong>和<strong>抢占式线程调度</strong>两种调度方式。<strong><code>Java</code>使用的是抢占式线程调度</strong>。</p><p>使用协同式调度的多线程系统，线程的<strong>执行时间</strong>由线程<strong>本身来控制</strong>，线程把自己的工作执行完后，要<strong>主动通知系统切换到另一个线程上</strong>。<strong>优点</strong>是<strong>实现简单</strong>，<strong>切换操作对线程自己是可知的</strong>，<strong>没有线程同步问题</strong>。<strong>缺点</strong>是线程<strong>执行时间不可控</strong>。</p><p>使用抢占式调度的多线程系统，<strong>线程将由系统来分配执行时间</strong>，线程的切换<strong>不由线程本身来决定</strong>，<code>Thread.yield()</code>可以让出执行时间，但线程没办法主动获取执行时间。<strong>优点</strong>线程<strong>执行时间可控</strong>，不会产生由一个线程导致整个进程阻塞。</p><p>虽然Java线程调度是由系统自动来完成，但可通过设置线程优先级来给系统建议给某些线程多分配或少分配一点执行时间。Java中一共设置了<code>10</code>个级别的线程<strong>优先级</strong>，两个线程<strong>同时处于<code>Ready</code>状态</strong>时，<strong>优先级越高</strong>的线程<strong>越容易被系统选择执行</strong>。</p><p>但<strong>线程优先级并不靠谱</strong>，因为Java线程是映射到系统原生线程上来实现的，<strong>最终线程调度还是取决于操作系统</strong>，虽然很多系统都提供线程优先级的概念，但并<strong>不一定</strong>能与Java线程优先级一一对应，且优先级可能被系统自动改变。</p><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java定义了五种线程状态，在任意时间点，一个线程只能有且只有其中一种状态。</p><ul><li><strong>新建（<code>New</code>）</strong>：创建后未启动的线程处于该状态</li><li><strong>运行（<code>Runable</code>）</strong>：包括了操作系统线程状态中的<code>Running</code>和<code>Ready</code>，处于次状态的线程有可能正在执行，也可能在等待<code>CPU</code>为他分配执行时间。</li><li><strong>无限期等待（<code>Waiting</code>）</strong>：该状态下线程不会被CPU分配执行时间，它们要等待被其他线程显式地唤醒。产生：<ul><li>没有设置<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>没有设置<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.park()</code>方法</li></ul></li><li><strong>限期等待（<code>Timed Waiting</code>）</strong>：不会被CPU分配执行时间，无需等待被其他线程显式唤醒，在一定时间之后会由系统自动唤醒。产生：<ul><li>Thread.sleep()方法</li><li>设置了Timeout参数的<code>Object.wait()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.parkNanos()</code>方法</li><li><code>LockSupport.parkUntil()</code>方法</li></ul></li><li><strong>阻塞（<code>Blocked</code>）</strong>：等待获取到一个排他锁，该事件将在另一个线程放弃这个锁时发生；</li><li><strong>结束（<code>Terminated</code>）</strong>：线程已结束执行。</li></ul><p><img src="../../../../../images/Java/线程状态转换关系.png" alt="线程状态转换关系"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程的实现&quot;&gt;&lt;a href=&quot;#线程的实现&quot; class=&quot;headerlink&quot; title=&quot;线程的实现&quot;&gt;&lt;/a&gt;线程的实现&lt;/h3&gt;&lt;p&gt;线程是&lt;strong&gt;&lt;code&gt;CPU&lt;/code&gt;调度&lt;/strong&gt;的&lt;strong&gt;基本单位&lt;/stron
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis总结</title>
    <link href="https://yaoyinglong.github.io/Blog/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/中间件/Redis总结/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-20T02:18:01.122Z</updated>
    
    <content type="html"><![CDATA[<p><code>redis</code>的速度非常的快，<strong>单机</strong>的<code>redis</code>就可以支撑<strong>每秒<code>10</code>几万的并发</strong>，相对于<code>mysql</code>来说，性能是<code>mysql</code>的几十倍。速度快的原因主要有几点：</p><ol><li><strong>完全基于内存操作</strong></li><li><strong>C语言实现</strong>，<strong>优化过的数据结构</strong>，基于几种基础的数据结构，<code>redis</code>做了大量的优化，性能极高</li><li><strong>使用单线程，无上下文的切换成本</strong></li><li>基于<strong>非阻塞的<code>IO</code>多路复用机制</strong></li></ol><p>虽然<code>6.0</code>后改用多线程，但并非是完全摒弃单线程，<code>redis</code>还是使用<strong>单线程模型来处理客户端的请求</strong>，只是使用<strong>多线程来处理数据的读写和协议解析</strong>，因为<code>redis</code>的<strong>性能瓶颈</strong>在于<strong>网络<code>IO</code></strong>而非CPU，使用多线程能提升<code>IO</code>读写的效率，从而整体提高<code>redis</code>的性能，<strong>执行命令还是使用单线程</strong>。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>字符串</strong>：<code>redis</code>没有直接使用C语言传统的字符串表示，而是自己实现的叫做<strong>简单动态字符串<code>SDS</code>的抽象类型</strong>。C语言的字符串<strong>不记录自身的长度信息</strong>，而<code>SDS</code>则<strong>保存了长度信息</strong>，这样将获取字符串长度的时间由<code>O(N)</code>降低到了<code>O(1)</code>，同时可以<strong>避免缓冲区溢出</strong>和<strong>减少修改字符串长度</strong>时所需的<strong>内存重分配次数</strong>。</p><p><strong>链表<code>linkedlist</code></strong>：是一个<strong>双向无环链表结构</strong>，很多<strong>发布订阅</strong>、<strong>慢查询</strong>、<strong>监视器</strong>功能都是使用到了链表来实现，每个链表的节点由一个<strong><code>listNode</code>结构</strong>来表示，每个节点都有指向<strong>前置节点</strong>和<strong>后置节点</strong>的指针，<strong>表头节点的前置和后置节点都指向<code>NULL</code></strong>。</p><p><strong>字典<code>hashtable</code></strong>：用于保存<strong>键值对</strong>的抽象数据结构，<code>redis</code>使用<code>hash</code>表作为底层实现，<strong>每个字典带有两个<code>hash</code>表</strong>，供<strong>平时使用</strong>和<code>rehash</code>时使用，<code>hash</code>表使用<strong>链地址法</strong>来<strong>解决键冲突</strong>，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对<code>hash</code>表进行扩容或者缩容的时候，为了服务的可用性，<strong><code>rehash</code>的过程不是一次性完成的而是渐进式的</strong>。</p><p><strong>跳跃表<code>skiplist</code></strong>：<strong>有序集合的底层实现之一</strong>，<code>redis</code>中实现<strong>有序集合键</strong>和<strong>集群节点的内部结构</strong>中都是使用跳跃表。<code>redis</code>跳跃表由<code>zskiplist</code>和<code>zskiplistNode</code>组成，<code>zskiplist</code>用于保存<strong>跳跃表信息</strong>（表头、表尾节点、长度等），<code>zskiplistNode</code>用于表示<strong>表跳跃节点</strong>，每个跳跃表的<strong>层高</strong>都是<code>1-32</code>的<strong>随机数</strong>，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，<strong>节点按照分值大小排序</strong>，如果<strong>分值相同，则按照成员对象的大小排序</strong>。</p><p><strong>整数集合<code>intset</code></strong>：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</p><p><strong>压缩列表<code>ziplist</code></strong>：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</p><p>基于基础的数据结构，<code>redis</code>封装了自己的对象系统，包含<strong>字符串对象<code>string</code></strong>、<strong>列表对象<code>list</code></strong>、<strong>哈希对象<code>hash</code></strong>、<strong>集合对象<code>set</code></strong>、<strong>有序集合对象<code>zset</code></strong>，每种对象都用到了<strong>至少一种基础的数据结构</strong>。</p><p><code>redis</code>通过<code>encoding</code>属性设置对象的编码形式来提升灵活性和效率，基于不同的场景<code>redis</code>会自动做出优化。不同对象的编码如下：</p><ol><li>字符串对象<code>string</code>：<code>int</code>整数、<code>embstr</code>编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：<code>ziplist</code>、<code>linkedlist</code></li><li>哈希对象<code>hash</code>：<code>ziplist</code>、<code>hashtable</code></li><li>集合对象<code>set</code>：<code>intset</code>、<code>hashtable</code></li><li>有序集合对象<code>zset</code>：<code>ziplist</code>、<code>skiplist</code></li></ol><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>当查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。</p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。</p><h5 id="定期-惰性都没有删除过期的key"><a href="#定期-惰性都没有删除过期的key" class="headerlink" title="定期+惰性都没有删除过期的key"></a>定期+惰性都没有删除过期的key</h5><p>每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存无法被删除，这时候就会走到<code>redis</code>的<strong>内存淘汰机制</strong>。</p><ul><li><strong><code>volatile-lru</code></strong>：从已设置过期时间的key中，移出<strong>最近最少使用</strong>的key进行淘汰</li><li><strong><code>volatile-ttl</code></strong>：从已设置过期时间的key中，移出<strong>将要过期</strong>的key</li><li><strong><code>volatile-random</code></strong>：从已设置过期时间的key中，<strong>随机</strong>选择key淘汰</li><li><strong><code>allkeys-lru</code></strong>：从key中选择最近<strong>最少使用</strong>的进行淘汰</li><li><strong><code>allkeys-random</code></strong>：从key中<strong>随机</strong>选择key进行淘汰</li><li><strong><code>noeviction</code></strong>：当<strong>内存达到阈值</strong>的时候，<strong>新写入操作报错</strong></li></ul><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><code>RDB</code></h5><p><code>RDB</code>持久化<strong>可手动执行</strong>也<strong>可根据配置定期执行</strong>，它的作用是<strong>将某个时间点上的数据库状态保存到<code>RDB</code>文件中</strong>，<code>RDB</code>文件是一个<strong>压缩的二进制文件</strong>，<strong>通过它可以还原某个时刻数据库的状态</strong>。由于<code>RDB</code>文件是保存在硬盘上的，所以即使<code>redis</code>崩溃或者退出，只要<code>RDB</code>文件存在，就可以用它来恢复还原数据库的状态。</p><p>可以通过<code>SAVE</code>或者<code>BGSAVE</code>来生成<code>RDB</code>文件。<strong><code>SAVE</code>命令会阻塞<code>redis</code>进程</strong>，直到<code>RDB</code>文件生成完毕，在进程<strong>阻塞期间，<code>redis</code>不能处理任何命令请求</strong>，显然不合适。</p><p><code>BGSAVE</code>则是会<code>fork</code>出一个子进程，然后<strong>由子进程去负责生成<code>RDB</code>文件</strong>，父进程还可以继续处理命令请求，不会阻塞进程。</p><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><code>AOF</code></h5><p><code>AOF</code>是通过保存<code>redis</code>服务器所<strong>执行的写命令来记录数据库状态的</strong>，<code>AOF</code>通过<strong>追加</strong>、<strong>写入</strong>、<strong>同步</strong>三个步骤来实现持久化机制。</p><p>当<code>AOF</code>持久化处于<strong>激活状态</strong>，服务器<strong>执行完写命令之后</strong>，写命令将会<strong>被追加<code>append</code>到<code>aof_buf</code>缓冲区的末尾</strong>；</p><p>在服务器<strong>每结束一个事件循环之前</strong>，将调用<code>flushAppendOnlyFile</code>函数决定是否要将<code>aof_buf</code>的内容保存到<code>AOF</code>文件中，可以通过配置<code>appendfsync</code>来决定。</p><ul><li><code>always</code>：<code>aof_buf</code>内容写入并同步到<code>AOF</code>文件</li><li><code>everysec</code>：将<code>aof_buf</code>中内容写入到<code>AOF</code>文件，如果上次同步<code>AOF</code>文件时间距离现在超过1秒，则再次对<code>AOF</code>文件进行同步</li><li><code>no</code>：将<code>aof_buf</code>内容写入<code>AOF</code>文件，但是并不对<code>AOF</code>文件进行同步，同步时间由操作系统决定</li></ul><p>默认选项是<code>everysec</code>，因为<code>always</code>来说虽然最安全（只会丢失一次事件循环的写命令），但是<strong>性能较差</strong>，而<code>everysec</code>模式只不过会可能丢失1秒钟的数据，而no模式的效率和<code>everysec</code>相仿，但是会丢失上次同步<code>AOF</code>文件之后的所有写命令数据。</p><h3 id="热KEY"><a href="#热KEY" class="headerlink" title="热KEY"></a>热KEY</h3><p>突然有几十万的请求访问<code>redis</code>上的某个特定<code>key</code>，这样会造成<strong>流量过于集中</strong>，<strong>达到物理网卡上限</strong>，从而导致这台<code>redis</code>的服务器宕机引发雪崩。解决方案：</p><ul><li>提前把<strong>热<code>key</code>打散到不同的服务器</strong>，降低压力</li><li>加入<strong>二级缓存</strong>，<strong>提前加载热<code>key</code>数据到内存中</strong>，如果<code>redis</code>宕机，走内存查询</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上。解决方案：</p><ul><li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了</li><li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在缓存中的数据，每次请求都会打到DB。可以通过<strong>加一层布隆过滤器</strong>。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃。解决方案：</p><ul><li>针对不同<code>key</code>设置不同的过期时间，避免同时过期</li><li>限流，如果<code>redis</code>宕机，可以限流，避免同时刻大量请求打崩DB</li><li>二级缓存，同热<code>key</code>的方案。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;redis&lt;/code&gt;的速度非常的快，&lt;strong&gt;单机&lt;/strong&gt;的&lt;code&gt;redis&lt;/code&gt;就可以支撑&lt;strong&gt;每秒&lt;code&gt;10&lt;/code&gt;几万的并发&lt;/strong&gt;，相对于&lt;code&gt;mysql&lt;/code&gt;来说，性能是&lt;
      
    
    </summary>
    
      <category term="中间件" scheme="https://yaoyinglong.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Redis" scheme="https://yaoyinglong.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
