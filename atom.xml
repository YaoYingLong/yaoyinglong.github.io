<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YingLong</title>
  
  <subtitle>虽奔放不羁，但也自我束缚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoyinglong.github.io/"/>
  <updated>2020-07-29T14:02:58.845Z</updated>
  <id>https://yaoyinglong.github.io/</id>
  
  <author>
    <name>YaoYingLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/平衡二叉树/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2020-07-29T14:02:58.845Z</updated>
    
    <content type="html"><![CDATA[<p>平衡二叉树是一种特殊的<strong>二叉排序树</strong>，<strong>每个</strong>节点<strong>左子树</strong>和<strong>右子树</strong>高度差<strong>至多等于<code>1</code></strong>。</p><p>将二叉树上节点<strong>左子树深度</strong>减去<strong>右子树深度</strong>的值称为<strong>平衡因子<code>BF</code></strong>，平衡二叉树上<strong>所有节点的平衡因子</strong>只可能是<strong>1，-1，0</strong>。</p><p>距离<strong>插入节点最近</strong>且<strong>平衡因子绝对值大于1</strong>的节点<strong>为根的子树</strong>，称为<strong>最小不平衡子树</strong>。</p><p>构建平衡二叉树时，每插入一个节点时，<strong>先检查是否因插入而破坏树的平衡性</strong>，若是则<strong>找出最小不平衡树</strong>，在<strong>保持二叉排序树特性的前提下</strong>，调整最小不平衡子树中各个节点之间的链接关系，<strong>进行相应的旋转</strong>，使之成为新的平衡子树。</p><ul><li><strong>右旋</strong>：最小不平衡子树的BF和它的子树BF符号相同且最小不平衡子树的BF大于0</li><li><strong>左旋</strong>：最小不平衡子树的BF和它的子树BF符号相同且最小不平衡子树的BF小于零</li><li><strong>左右旋</strong>：最小不平衡子树的BF与它的子树的BF符号相反时且最小不平衡子树的BF大于0时，需要对节点先进行一次向左旋使得符号相同后，在向右旋转一次完成平衡操作。</li><li><strong>右左旋</strong>：最小不平衡子树的BF与它的子树的BF符号相反时且最小不平衡子树的BF小于0时，需要对节点先进行一次向右旋转使得符号相同时，在向左旋转一次完成平衡操作。</li></ul><h3 id="平衡二叉树判定"><a href="#平衡二叉树判定" class="headerlink" title="平衡二叉树判定"></a>平衡二叉树判定</h3><p>对二叉树做<strong>后序遍历</strong>，从底至顶返回子树深度，若判定某子树不是平衡树则 直接向上返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recur(treeNode) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftDepth = recur(treeNode.leftNode);</span><br><span class="line">    <span class="keyword">if</span> (leftDepth == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rightDepth = recur(treeNode.rightNode);</span><br><span class="line">    <span class="keyword">if</span> (rightDepth == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(leftDepth - rightDepth) &lt; <span class="number">2</span> ? Math.max(leftDepth, rightDepth) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平衡二叉树是一种特殊的&lt;strong&gt;二叉排序树&lt;/strong&gt;，&lt;strong&gt;每个&lt;/strong&gt;节点&lt;strong&gt;左子树&lt;/strong&gt;和&lt;strong&gt;右子树&lt;/strong&gt;高度差&lt;strong&gt;至多等于&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;。&lt;/
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://yaoyinglong.github.io/tags/%E6%A0%91/"/>
    
      <category term="AVL" scheme="https://yaoyinglong.github.io/tags/AVL/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/二叉搜索树/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2020-07-30T09:18:15.773Z</updated>
    
    <content type="html"><![CDATA[<p>左子树上所有节点的值均小于根节点的值，而右子树上所有结点的值均大于根节点的值。<strong>插入的序列越接近有序，生成的二叉搜索树就越像一个链表</strong>，为了避免二叉搜索树变成链表，故引入了<strong>平衡二叉树</strong>，即让树的结构看起来尽量均匀，左右子树的节点数尽量一样多。</p><p>生成平衡二叉树时，先按照生成二叉搜索树的方法构造二叉树，再根据插入的导致二叉树不平衡的节点位置进行调整，有<strong><code>LL</code>左旋</strong>、<strong><code>RR</code>右旋</strong>、<strong><code>LR</code>先左旋后右旋</strong>、<strong><code>RL</code>先右旋后左旋</strong>四种调整方式。</p><h3 id="将树转换成链表"><a href="#将树转换成链表" class="headerlink" title="将树转换成链表"></a>将树转换成链表</h3><p><code>cursor</code>只是做一个引用传递，不断的将节点的<code>right</code>节点更新，然后将当前游标置为新节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode cursor;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    cursor = ans;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> ans.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">    node.left = <span class="keyword">null</span>;</span><br><span class="line">    cursor.right = node;</span><br><span class="line">    cursor = node;</span><br><span class="line">    inorder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;左子树上所有节点的值均小于根节点的值，而右子树上所有结点的值均大于根节点的值。&lt;strong&gt;插入的序列越接近有序，生成的二叉搜索树就越像一个链表&lt;/strong&gt;，为了避免二叉搜索树变成链表，故引入了&lt;strong&gt;平衡二叉树&lt;/strong&gt;，即让树的结构看起来尽量均匀
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://yaoyinglong.github.io/tags/%E6%A0%91/"/>
    
      <category term="AVL" scheme="https://yaoyinglong.github.io/tags/AVL/"/>
    
  </entry>
  
  <entry>
    <title>面试准备大纲</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/%E5%A4%A7%E7%BA%B2/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/大纲/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2020-07-26T09:45:19.919Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul><li><code>AOP</code></li><li><code>IOC</code></li><li>源码</li><li><code>SpringBoot</code></li><li><code>SpringCloud</code></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>常见面试笔试内容</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>树（前序遍历、中序遍历、后序遍历、层序遍历）</li><li>图（广度优先遍历BFS、深度优先遍历DFS）</li><li><code>leetcode</code>题（<strong>前期每周5道，中期每周10道，后期每周15道</strong>）</li><li>常见排序总结</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>6大基本原则（<strong>一周</strong>）</li><li>23种设计模式（<strong>一周5个</strong>）</li><li>设计模式对比</li></ul><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ul><li><code>JVM</code></li><li>源码</li><li>多线程</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul><li><code>RabbitMQ</code></li><li>常见面试笔试内容</li></ul><h3 id="Reids"><a href="#Reids" class="headerlink" title="Reids"></a>Reids</h3><ul><li>常见面试笔试内容</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>常用命令</li></ul><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><ul><li>常见面试笔试内容</li></ul><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><ul><li>常见面试笔试内容</li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AOP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IOC&lt;/code&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>设计基本原则</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/设计基本原则/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2020-07-27T12:42:01.121Z</updated>
    
    <content type="html"><![CDATA[<p>6大设计基本原则：<strong>单一职责原则</strong>、<strong>里氏替换原则</strong>、<strong>依赖倒置原则</strong>、<strong>接口隔离原则</strong>、<strong>迪米特法则</strong>、<strong>开闭原则</strong></p><h3 id="单一职责原则SRP"><a href="#单一职责原则SRP" class="headerlink" title="单一职责原则SRP"></a>单一职责原则SRP</h3><p>​    单一职责原则提出了一个编写程序的标准，用<strong>职责</strong>或<strong>变化原因</strong>来衡量接口或类设计得是否优良，但职责和变化原因都是不可度量得，因项目和环境而异。单一职责适用于<strong>接口、类、方法</strong>。</p><p><strong>定义</strong>：应该<strong>有且仅有一个原因引起类的变更</strong>。</p><p><strong>优点</strong>：<strong>类复杂性降低</strong>，实现<strong>职责清晰明确</strong>；<strong>可读性高</strong>；<strong>可维护性高</strong>；<strong>变更引起的风险低</strong>；</p><h3 id="里氏替换原则LSP"><a href="#里氏替换原则LSP" class="headerlink" title="里氏替换原则LSP"></a>里氏替换原则LSP</h3><p><strong>定义</strong>：<strong>每一个类型为<code>S</code>的对象<code>s</code>，都有类型为<code>T</code>的对象<code>t</code>，使得以<code>T</code>定义的所有程序<code>P</code>在所有的对象<code>s</code>都代替成<code>t</code>时，程序<code>P</code>的行为无变化，则类型<code>S</code>时类型<code>T</code>的子类；所有引用基类的地方必须能透明的使用其子类的对象。</strong></p><ul><li><strong>子类必须完全实现父类的方法</strong>：若子类<strong>不能完全实现父类方法</strong>，或某些方法在子类种已<strong>发生畸变</strong>，建议断开父子继承关系。</li><li><strong>子类可以有自己的个性</strong>：子类出现的地方父类未必能出现</li><li><strong>覆盖或实现父类方法时输入参数可以被放大</strong></li><li><strong>覆写或实现父类的方法时输出结果可以被缩小</strong></li></ul><p>在类中调用其他类时<strong>务必使用父类或接口</strong>，否则即是违背<code>LSP</code>原则。</p><h3 id="依赖倒置原则DPI"><a href="#依赖倒置原则DPI" class="headerlink" title="依赖倒置原则DPI"></a>依赖倒置原则DPI</h3><p>​    采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。可以通过依赖倒置原则涉及的接口或抽象类对实现类进行约束，可减少需求变化引起的工作量剧增的情况，可让维护人员轻松地扩展和维护，<strong>是实现开闭原则的总要途径</strong>。TDD测试驱动开发模式就是依赖倒置原则的最高级应用。</p><p><strong>定义</strong>：<strong>高层模块不应该依赖底层模块两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象</strong>；</p><p>表现：模块间依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生；接口和抽象类不依赖于实现类；实现类依赖接口或抽象类；</p><p>依赖的三种写法：</p><ul><li>构造函数传递依赖对象，也叫构造函数注入</li><li>Setter方法传递依赖对象，也叫Setter依赖注入</li><li>接口声明依赖对象，也叫接口注入</li></ul><p>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。</p><ul><li>每个类尽量都有接口或抽象类，或抽象类和接口两者都具备</li><li>变量的表面类型尽量是接口或抽象类</li><li>任何类都不应该从具体类派生</li><li>尽量不要覆写基类的方法</li><li>结合里氏替换原则使用</li></ul><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>定义：客户端不应该依赖它不需要的接口；类间的依赖关系应该建立在最小的接口上。建立单一的接口，不要建立臃肿庞大的接口；</p><ul><li>接口尽量小</li><li>接口要高内聚：提高接口、类、模块的处理能力，减少对外的交互</li><li>定制服务，单独为一个个体提供优良的服务</li><li>接口设计要有限度</li></ul><p><strong>根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</strong>接口和类尽量使用原子接口或原子类来组装。</p><ul><li>一个接口只服务玉一个子模块或业务</li><li>通过业务逻辑压缩接口中的public方法</li><li>已经被污染的接口，尽量去修改，若变更风险较大，则采用适配器模式进行转化处理</li><li>了解环境，拒绝盲从</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;6大设计基本原则：&lt;strong&gt;单一职责原则&lt;/strong&gt;、&lt;strong&gt;里氏替换原则&lt;/strong&gt;、&lt;strong&gt;依赖倒置原则&lt;/strong&gt;、&lt;strong&gt;接口隔离原则&lt;/strong&gt;、&lt;strong&gt;迪米特法则&lt;/strong&gt;、&lt;strong&gt;开
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HBase依赖冲突</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/HBase%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/常见问题/HBase依赖冲突/</id>
    <published>2020-07-05T16:00:00.000Z</published>
    <updated>2020-07-13T11:40:15.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>连接代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">hbaseConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    org.apache.hadoop.conf.Configuration conf = HBaseConfiguration.create();</span><br><span class="line">    conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    conf.set(<span class="string">"hbase.zookeeper.property.clientPort"</span>, <span class="string">"2181"</span>);</span><br><span class="line">    conf.set(<span class="string">"zookeeper.znode.parent"</span>, <span class="string">"/hbase-unsecure"</span>);</span><br><span class="line">    Connection connection = ConnectionFactory.createConnection(conf);</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String tableName, String familyName, String columnName, String qualifier)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TableName name = TableName.valueOf(tableName);</span><br><span class="line">    Table table = hbaseConnection.getTable(name);</span><br><span class="line">    Get get = <span class="keyword">new</span> Get(qualifier.getBytes());</span><br><span class="line">    get.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(columnName));</span><br><span class="line">    Result rs = table.get(get);</span><br><span class="line">    <span class="keyword">return</span> Bytes.toString(rs.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hive依赖包冲突"><a href="#hive依赖包冲突" class="headerlink" title="hive依赖包冲突"></a>hive依赖包冲突</h3><p>在项目中同时存在<code>hive</code>和<code>hbase</code>时，<code>hive</code>中引用的<code>guava</code>与<code>hbase</code>中引用的<code>guava</code>版本冲突，从而导致执行<code>hbase</code>查询时报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.hadoop.hbase.DoNotRetryIOException: java.lang.IllegalAccessError: tried to access method com.google.common.base.Stopwatch.&lt;init&gt;()V from <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">hadoop</span>.<span class="title">hbase</span>.<span class="title">zookeeper</span>.<span class="title">MetaTableLocator</span></span></span><br></pre></td></tr></table></figure><p><code>Stopwatch</code>在<code>google</code>的<code>guava</code>包下，<code>hbase1.1.2</code>只在<code>guava12-16</code>下能正常运行。<code>guava17</code>开始，出现以上异常。尝试着将<code>guava</code>版本降低，后启动项目后报如下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">An attempt was made to call the method com.google.common.base.Splitter.splitToList(Ljava/lang/CharSequence;)Ljava/lang/List; but it does not exist. Its class, com.google.common.base.Splitter, is available from the following locations:</span><br><span class="line">jar:file:/mvnRespo/org/apache/hive/hive-exec/<span class="number">1.2</span>.1/hive-exec-<span class="number">1.2</span>.1.jar!/com/google/common/base/Splitter.class</span><br><span class="line">    jar:file:/mvnRespo/com/google/guava/guava/<span class="number">16.0</span>/guava-<span class="number">16.0</span>.jar!/com/google/common/base/Splitter.class</span><br></pre></td></tr></table></figure><p>由此可见<code>hive</code>必须依赖高版本的<code>guava</code>才行，然后就尝试着将hbase的依赖版本升级到<code>1.3.0</code>，问题得到了解决。</p><h3 id="tablestore依赖包冲突"><a href="#tablestore依赖包冲突" class="headerlink" title="tablestore依赖包冲突"></a>tablestore依赖包冲突</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(value = <span class="string">"$&#123;aliyun.endpoint:http&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String endPoint;</span><br><span class="line"><span class="meta">@Value</span>(value = <span class="string">"$&#123;aliyun.accessKeyId:test&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String accessKeyId;</span><br><span class="line"><span class="meta">@Value</span>(value = <span class="string">"$&#123;aliyun.accessSecret:test&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String accessSecret;</span><br><span class="line"><span class="meta">@Value</span>(value = <span class="string">"$&#123;aliyun.instanceName:test&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String instanceName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SyncClient syncClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    syncClient = <span class="keyword">new</span> SyncClient(endPoint, accessKeyId, accessSecret, instanceName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String key, String value, String tableName, String columnName)</span> </span>&#123;</span><br><span class="line">    PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();</span><br><span class="line">    primaryKeyBuilder.addPrimaryKeyColumn(key, PrimaryKeyValue.fromString(value));</span><br><span class="line">    PrimaryKey primaryKey = primaryKeyBuilder.build();</span><br><span class="line">    GetRowRequest request = <span class="keyword">new</span> GetRowRequest();</span><br><span class="line">    SingleRowQueryCriteria singleRowQueryCriteria = <span class="keyword">new</span> SingleRowQueryCriteria(tableName, primaryKey);</span><br><span class="line">    singleRowQueryCriteria.setMaxVersions(<span class="number">1</span>);</span><br><span class="line">    request.setRowQueryCriteria(singleRowQueryCriteria);</span><br><span class="line">    GetRowResponse response = syncClient.getRow(request);</span><br><span class="line">    Row row = response.getRow();</span><br><span class="line">    <span class="keyword">return</span> row.getLatestColumn(columnName).getValue().asString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目中同时存在<code>tablestore</code>和<code>hbase</code>时，<code>tablestore</code>中引用的<code>protobuf</code>版本<code>2.4.1</code>与<code>hbase</code>中引用的<code>protobuf</code>版本<code>2.5.0</code>版本冲突，从而导致执行<code>hbase</code>查询时报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.VerifyError: <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">hadoop</span>.<span class="title">hbase</span>.<span class="title">protofuf</span>.<span class="title">generated</span>.<span class="title">ClientProtos</span>$<span class="title">Result</span> <span class="title">overrides</span> <span class="title">final</span> <span class="title">method</span> <span class="title">getUnknownFields</span>.()<span class="title">Lcom</span>/<span class="title">google</span>/<span class="title">protobuf</span>/<span class="title">UnknownFieldSet</span></span>;</span><br></pre></td></tr></table></figure><p>首先想到的是引入高版本的<code>protobuf</code>。但是引入高版本的<code>protobuf</code>后查询阿里的彩虹表tablestore时会报另外的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsupportedOperationException: This is supposed to be overridden by subclasses.</span><br></pre></td></tr></table></figure><p>尝试着将<code>hbase</code>的版本升高到<code>2.2.0</code>，然后发现问题解决了，然后继续查看了一下<code>protobuf</code>依赖冲突版本，发现多了一个<code>hbase-shaded-protobuf</code>,原来在该版本中使用了<code>hbase-shaded</code> , 用来更改<code>hbase</code>中的一些报名，解决<code>protobuf</code>的冲突问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;远程连接&quot;&gt;&lt;a href=&quot;#远程连接&quot; class=&quot;headerlink&quot; title=&quot;远程连接&quot;&gt;&lt;/a&gt;远程连接&lt;/h3&gt;&lt;p&gt;maven依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="常见问题" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="HBase" scheme="https://yaoyinglong.github.io/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>Maven编译后文件损坏</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Maven%E7%BC%96%E8%AF%91%E5%90%8E%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/常见问题/Maven编译后文件损坏/</id>
    <published>2020-07-05T16:00:00.000Z</published>
    <updated>2020-07-13T11:40:15.371Z</updated>
    
    <content type="html"><![CDATA[<p>在一般Maven项目中的<code>build</code>标签下通常会有如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application-test.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上的配置本身是没有问题的，但在某些需要需要将一些文件存放在项目中直接提供下载时，以上配置就回有问题，如果是将文件放到<code>resources</code>目录下，由于<code>filtering</code>设置为<code>true</code>，开启了过滤，会用指定的参数替换<code>directory</code>下的文件中的参数(<code>eg. ${name}</code>)。从而导致文件可能会损坏。</p><p>若配置文件需要传参数将<code>filtering</code>设置为<code>false</code>显然是不行的。使用<code>exclude</code>排除想下载的文件打包时都不会将文件打到<code>jar</code>包中，显然也是不行的。然后尝试做了如下调整，但并没有生效：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application-test.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>src/main/resources/download<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/download<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终只能将下载的文件单独放到其他目录，然后做如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application-test.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>download<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一般Maven项目中的&lt;code&gt;build&lt;/code&gt;标签下通常会有如下配置：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="常见问题" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="Maven" scheme="https://yaoyinglong.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Go基础</title>
    <link href="https://yaoyinglong.github.io/Blog/Go/Go%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/Go/Go基础/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2020-07-27T11:36:21.998Z</updated>
    
    <content type="html"><![CDATA[<p><code>Go</code>语言是<strong>静态类型</strong>语言，<strong>所有的内存在 <code>Go</code> 中都是经过初始化的</strong>，当一个变量被声明之后，<strong>系统自动赋予它该类型的零值</strong>：<code>int</code> 为 <code>0</code>，<code>float</code> 为 <code>0.0</code>，<code>bool</code> 为 <code>false</code>，<code>string</code> 为<strong>空字符串</strong>，<strong>指针</strong>为 <code>nil</code> 等。</p><p>只有两个<strong>相同类型</strong>的值才可以进行比较，如果值的类型是<strong>接口</strong>（<code>interface</code>），那么它们也必须都实现了<strong>相同的接口</strong>。<code>&amp;&amp;</code>的优先级比<code>||</code>高（&amp;&amp; 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高）。</p><p><strong>变量</strong>、<strong>函数</strong>、<strong>常量</strong>名称如果<strong>首字母大写</strong>，则表示它<strong>可被其它的包访问</strong>；如果首字母小写，则表示它只能在本包中使用。</p><p><code>nil</code> 不是关键字或保留字且不能比较。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Go语言的基本类型有：</p><ul><li><code>bool</code></li><li><code>string</code></li><li><code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code></li><li><code>uint</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>（只有在底层编程时才需要）</li><li><code>byte</code> （<code>uint8</code> 的别名）</li><li><code>rune</code> （<code>int32</code> 的别名 代表一个 <code>Unicode</code> 码点）</li><li><code>float32</code>、<code>float64</code></li><li><code>complex64</code>、<code>complex128</code></li></ul><p>尽管在某些特定的运行环境下 <code>int</code>、<code>uint</code> 和 <code>uintptr</code> 的大小可能相等，但是它们依然是不同的类型，在需要把 <code>int</code> 类型当做 <code>int32</code> 类型使用的时候必须显示的对类型进行转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> num1, num2, num3 = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> num1, num2, num3 = <span class="number">1</span>, <span class="string">"2"</span>, <span class="number">3.5</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    num1 <span class="keyword">int</span></span><br><span class="line">    num2 <span class="keyword">string</span></span><br><span class="line">    num3 <span class="keyword">float64</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    num1 = <span class="number">1</span></span><br><span class="line">    num2 = <span class="string">"2"</span></span><br><span class="line">    num3 = <span class="number">3.5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Go是一门<strong>静态类型</strong>语言，每个变量都有一个在编译时就确定的静态类型。虽然<code>a</code>和<code>b</code>的的基本类型相同，但静态类型不同，无类型转换的情况下<strong>无法相互赋值</strong>。虽然在运行时中，接口变量存储的值也许会变，但接口变量的类型是不会变的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b MyInt</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Go语言常用容器有<strong>数组</strong>，<strong>切片</strong>，<code>Map</code>，<code>List</code>。map和切片是不可以用<code>==</code>直接被比较的。</p><p>数组的长度必须是<strong>常量表达式</strong>，若数组长度的位置出现<code>...</code>省略号，则表示数组的长度是根据<strong>初始化值的个数</strong>来计算。数组的长度是数组类型的一个组成部分，若两个数组<strong>类型相同</strong>（包括数组的<strong>长度</strong>，数组中<strong>元素的类型</strong>），可直接通过较运算符<code>==</code>和<code>!=</code>来判断两个数组是否相等，<strong>不能比较两个类型不同的数组，且不能相互赋值</strong>，否则程序将无法完成编译。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numArr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,&#125;</span><br><span class="line">strArr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;</span><br><span class="line"></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">10</span>, <span class="number">3</span>:<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>切片</strong>（<code>slice</code>）是对数组的一个<strong>连续片段的引用</strong>，所以切片是一个引用类型，终止索引标识的项不包括在切片内。切片的内部结构包含<strong>地址</strong>、<strong>大小</strong>和<strong>容量</strong>，切片一般<strong>用于快速地操作一块数据集合</strong>。切片在扩容时，<strong>容量的扩展规律是按容量的 <code>2</code> 倍数进行扩充</strong>。在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次。<code>make</code>函数创建切片时若只指定长度，则切片的长度和容量相等，<strong>不允许创建长度大于容量的切片</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,&#125;</span><br><span class="line">slice := arr[:]</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">slice := arr[<span class="number">1</span>:]</span><br><span class="line">slice := arr[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;...)</span><br><span class="line">slice = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;, slice...)</span><br><span class="line"></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">slice = <span class="built_in">append</span>(slice[:<span class="number">2</span>], <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>&#125;, slice[<span class="number">2</span>:]...)...)</span><br><span class="line"></span><br><span class="line">sliceA := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sliceB := []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">copyCount := <span class="built_in">copy</span>(sliceA, sliceB)</span><br><span class="line"></span><br><span class="line">sliceB := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sliceA := []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">copyCount := <span class="built_in">copy</span>(sliceA, sliceB)</span><br><span class="line"><span class="comment">// 创建容量和长度都是100的切片</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">99</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>计算切片的<strong>长度</strong>和<strong>容量</strong>，若底层数组容量<code>k</code>的切片<code>slice[i:j]</code>，长度为<code>j-i</code>，容量为<code>k-i</code>。也可以通过第三个索引来控制新切片的容量。若底层数组容量<code>k</code>的切片<code>slice[i:j:s]</code>，长度为<code>j-i</code>，容量为<code>s-i</code>，<code>s&lt;=K</code>。</p><p><code>map</code> 是引用类型，<strong>可动态增长</strong>，未初始化的 <code>map</code> 的值是 <code>nil</code>，使用函数 <code>len()</code> 可以获取 <code>map</code> 中 <code>pair</code> 的数目。<code>map</code>不能使用<code>cap()</code>函数。定义map时可现实指定容量，当 map 增长到容量上限的时候，如果再增加新的 key-value，map 的大小会自动加 <code>1</code>。map可以存函数。<code>map</code>是<strong>无序</strong>的。<strong>切片</strong>、<strong>函数</strong>以及<strong>包含切片的结构类型</strong>由于<strong>具有引用语意</strong>不能作为<code>map</code>的键。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapLit = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> mapLit <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapLit = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">mapLit := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>&#125;</span><br><span class="line">mapLit[<span class="number">3</span>] = <span class="string">"c"</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> mapLit &#123;</span><br><span class="line">    fmt.Println(<span class="string">"key value:"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(mapLit, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">mapLit := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"hello"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">"world"</span>: <span class="number">200</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value, isExist := mapLit[<span class="string">"hello"</span>]；isExist：</span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, value)</span><br><span class="line"></span><br><span class="line">skill := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="string">"fire"</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"chicken fire"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">f, ok := skill[<span class="string">"fire"</span>]</span><br></pre></td></tr></table></figure><p>列表是一种<strong>非连续</strong>的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lit := list.New()</span><br><span class="line">lit.PushBack(<span class="string">"AA"</span>)</span><br><span class="line">lit.PushFront(<span class="string">"BB"</span>)</span><br><span class="line">element := lit.PushFront(<span class="string">"CC"</span>)</span><br><span class="line">lit.InsertBefore(<span class="string">"DD"</span>, element)</span><br><span class="line"><span class="keyword">for</span> i := lit.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">   fmt.Println(<span class="string">"lit value:"</span>, i.Value)</span><br><span class="line">&#125;</span><br><span class="line">lit.Remove(element)</span><br></pre></td></tr></table></figure><p>Go语言线程安全的<code>sync.Map</code>，<code>Range</code>返回为<code>false</code>时将不再往下遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> syncMap sync.Map</span><br><span class="line">syncMap.Store(<span class="number">1</span>, <span class="string">"a"</span>)</span><br><span class="line">syncMap.Store(<span class="number">2</span>, <span class="string">"b"</span>)</span><br><span class="line">value, ok := syncMap.Load(<span class="number">2</span>)</span><br><span class="line">syncMap.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"key, value"</span>, key, value)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>Go 语言常用流程控制有 <code>if</code> 和 <code>for</code>，而 <code>switch</code> 和 <code>goto</code> 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><p><code>if-else</code>分支结构，可结合<code>goto</code>使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> index := <span class="number">12</span>; index &gt; <span class="number">10</span> &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index := <span class="number">10</span>; index == <span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">goto</span> onExit</span><br><span class="line">&#125;</span><br><span class="line">onExit:</span><br><span class="line">fmt.Println(<span class="string">"exit"</span>)</span><br></pre></td></tr></table></figure><p><code>go</code>中只有<code>for</code>循环结构，不支持 <code>while</code> 和 <code>do-while</code> 结构；for range 可以遍历<strong>数组</strong>、<strong>切片</strong>、<strong>字符串</strong>、<code>map</code> 及<strong>通道</strong>（<code>channel</code>）；其中用到的<code>range</code> 返回的是每个<strong>元素的副本</strong>，而不是直接返回对该元素的引用。字符串的遍历是一个个<code>rune</code> 字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">JLoop:</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> JLoop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> index &lt; <span class="number">10</span> &#123;</span><br><span class="line">    index++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str := <span class="string">"12456789"</span></span><br><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Println(<span class="string">"pos, char:"</span>, pos, char)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    channel &lt;- <span class="number">3</span></span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> value := <span class="keyword">range</span> channel &#123;</span><br><span class="line">    fmt.Println(<span class="string">"channel value:"</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code>表达式不需要为<strong>常量</strong>，甚至不需要为<strong>整数</strong>，<code>case</code> 按照从上到下的顺序进行求值，直到找到匹配的项，若<code>switch</code> 没有表达式，则对 <code>true</code> 进行匹配。<code>fallthrough</code>会紧接着执行下一个 <code>case</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"kk"</span></span><br><span class="line"><span class="keyword">switch</span> str &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"hello"</span>, <span class="string">"kk"</span>:</span><br><span class="line">    fmt.Println(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">    fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := <span class="number">11</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r &gt; <span class="number">10</span> &amp;&amp; r &lt; <span class="number">20</span>:</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>Go</code> 语言支持<strong>普通函数</strong>、<strong>匿名函数</strong>和<strong>闭包</strong>。函数间传递变量总是以<strong>值得方式传递</strong>，数组传递会完整复制并传递给函数，最好只传入指向数组的指针。函数间传递切片和<code>map</code>，<strong>只会复制切片和<code>map</code>本身，不会涉及底层数据</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   a = <span class="number">1</span></span><br><span class="line">   b = <span class="number">2</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := funcA()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := funcB()</span><br><span class="line">f := funcB</span><br><span class="line">a, b := f()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">string</span>, c <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"a1"</span>, <span class="string">"b2"</span>, <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">a, b, c := funcC()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcD</span><span class="params">(arr []<span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">      f(value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">funcD([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"this value:"</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数变量</span></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">f</span> = <span class="title">funcA</span></span></span><br><span class="line"><span class="function"><span class="title">a</span>, <span class="title">b</span> := <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 匿名函数</span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"inner func:"</span>, data)</span><br><span class="line">&#125;(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"inner func:"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">500</span>)</span><br></pre></td></tr></table></figure><p><strong>闭包</strong>是引用了<strong>自由变量</strong>的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除。被捕获到闭包中的变量让闭包本身拥有了记忆效应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accumulate</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      value++</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">accumulator := accumulate(<span class="number">1</span>)</span><br><span class="line">fmt.Println(accumulator()) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(accumulator()) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>可变参数和任意类型的可以变参数，用 <code>interface{}</code> 传递<strong>任意类型</strong>数据，<strong>可变参数</strong>变量是一个<strong>包含所有参数的切片</strong>，如果要将这个含有可变参数的变量传递给下一个可变参数函数，可以在传递时给可变参数变量后面添加<code>...</code>，这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notFixedParam</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notFixedParamV2</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">      <span class="keyword">switch</span> arg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">int64</span>:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notFixedParam(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">notFixedParamV2(<span class="string">"kk"</span>, <span class="number">1</span>, <span class="number">234</span>, <span class="string">"hello"</span>, <span class="number">3.14</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawPrint</span><span class="params">(rawList ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, raw := <span class="keyword">range</span> rawList &#123;</span><br><span class="line">fmt.Println(raw)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(slist ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">rawPrint(slist...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defer</code> 语句会将其后面跟随的语句进行<strong>延迟处理</strong>，在 <code>defer</code> 归属的函数<strong>即将返回</strong>时，将延迟处理的语句<strong>按 <code>defer</code> 的逆序进行执行</strong>。类似<code>java</code>的<code>finally</code>语句块。可与宕机<code>panic</code> 一起使用，宕机前会优先执行<code>defer</code>。提供<code>recover</code> 用于宕机恢复，且仅在延迟函数 <code>defer</code> 中有效。正常的执行过程中，调用 <code>recover</code> 会返回 <code>nil</code> 并且没有其他任何效果，调用 <code>recover</code> 可以捕获到 <code>panic</code> 的输入值，并且恢复正常的执行。<code>recover</code> 的宕机恢复机制就对应其他语言中的 <code>try/catch</code> 机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"宕机后要做的事情"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"宕机"</span>)</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p><strong>结构体</strong>的定义只是一种<strong>内存布局的描述</strong>，只有当结构体实例化时，才会真正地分配内存。使用<code>new</code>或<code>&amp;</code>构造的类型实例的类型是<strong>类型的指针</strong>。<code>Go</code>语言的<strong>类型</strong>或<strong>结构体没有构造函数</strong>的功能.</p><p>使用<code>.</code>来访问结构体的<strong>成员变量</strong>，访问结构体指针的成员变量时可以继续使用<code>.</code>，Go使用了语法糖（Syntactic sugar）技术，将 <code>ins.Name</code> 形式转换为 <code>(*ins).Name</code>；对结构体进行<code>&amp;</code>取地址操作时，视为对该类型进行一次 new 的实例化操作；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">R, G, B <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color := <span class="built_in">new</span>(Color)</span><br><span class="line">(*color).R = <span class="number">12</span></span><br><span class="line">color.G = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">color := &amp;Color&#123;&#125;</span><br><span class="line">(*color).R = <span class="number">12</span></span><br><span class="line">color.G = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Command <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name    <span class="keyword">string</span></span><br><span class="line">   Var     *<span class="keyword">int</span></span><br><span class="line">   Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">version := <span class="number">1</span></span><br><span class="line"><span class="comment">// 使用键值对填充结构体</span></span><br><span class="line">cmd := &amp;Command&#123;</span><br><span class="line">    Name:    <span class="string">"version"</span>,</span><br><span class="line">    Var:     &amp;version,</span><br><span class="line">    Comment: <span class="string">"show version"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"cmd, Name, Var, Comment:"</span>, *cmd, cmd.Name, *cmd.Var, cmd.Comment)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用多个值的列表初始化结构体</span></span><br><span class="line">cmd := Command&#123;</span><br><span class="line">    <span class="string">"version"</span>,</span><br><span class="line">    &amp;version,</span><br><span class="line">    <span class="string">"show version"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"cmd, Name, Var, Comment:"</span>, cmd, cmd.Name, *cmd.Var, cmd.Comment)</span><br></pre></td></tr></table></figure><p><strong>匿名结构体</strong>没有类型名称，无须通过 <code>type</code> 关键字定义就可以直接使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name    <span class="keyword">string</span></span><br><span class="line">   Var     *<span class="keyword">int</span></span><br><span class="line">   Comment <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">   <span class="string">"version"</span>,</span><br><span class="line">   &amp;version,</span><br><span class="line">   <span class="string">"show version"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMsg</span> <span class="params">(msg *<span class="keyword">struct</span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">id <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">data <span class="keyword">string</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"msg"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">    data <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="number">1024</span>,</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">&#125;</span><br><span class="line">printMsg(msg)</span><br></pre></td></tr></table></figure><p>结构体可以包含一个或多个<strong>匿名</strong>（或<strong>内嵌</strong>）字段，没有显式的名字，只有字段的类型，<strong>此时类型也就是字段的名</strong>。在一个结构体中<strong>对于每一种数据类型只能有一个匿名字段</strong>。结构体可以包含内嵌结构体，内嵌结构体甚至可以来自其他包。</p><p>结构体实例访问<strong>任意一级</strong>的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> innerS <span class="keyword">struct</span> &#123;</span><br><span class="line">   in1 <span class="keyword">int</span></span><br><span class="line">   in2 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> outerS <span class="keyword">struct</span> &#123;</span><br><span class="line">   b <span class="keyword">int</span></span><br><span class="line">   c <span class="keyword">float32</span></span><br><span class="line">   in1 <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">int</span></span><br><span class="line">   innerS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer := <span class="built_in">new</span>(outerS)</span><br><span class="line">outer.b = <span class="number">6</span></span><br><span class="line">outer.c = <span class="number">7.5</span></span><br><span class="line">outer.<span class="keyword">int</span> = <span class="number">60</span></span><br><span class="line">outer.in1 = <span class="number">20</span></span><br><span class="line">outer.innerS.in1 = <span class="number">5</span></span><br><span class="line">outer.in2 = <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"outer1 :"</span>, *outer)</span><br><span class="line">outer2 := outerS&#123;<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">20</span>, <span class="number">60</span>, innerS&#123;<span class="number">5</span>, <span class="number">10</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="string">"outer2 :"</span>, outer2)</span><br></pre></td></tr></table></figure><p>结构体标签是对结构体字段的额外信息标签，由<strong>一个或多个键值对</strong>组成；键与值使用<strong>冒号</strong>分隔，值用<strong>双引号</strong>括起来；键值对之间使<strong>用一个空格分隔</strong>。标签内容是<strong>静态的</strong>，无须实例化结构体，可以通过<strong>反射</strong>从结构体中获取标签内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ins <span class="keyword">struct</span> &#123;</span><br><span class="line">   in1 <span class="keyword">int</span> <span class="string">`key1:"value1" key2:"value2"`</span></span><br><span class="line">   in2 <span class="keyword">int</span> <span class="string">`key1:"value1" key2:"value2"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeOfIns := reflect.TypeOf(Ins&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> catType, ok := typeOfIns.FieldByName(<span class="string">"in2"</span>); ok &#123;</span><br><span class="line">    fmt.Println(catType.Tag.Get(<span class="string">"key1"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法能给用户定义的类型添加新的行为，实际上也是函数，仅仅是在申明时，在关键字<code>func</code>和方法名间增加了一个参数，该参数称为<strong>接收者</strong>（<strong>值接收者</strong>、<strong>指针接收者</strong>），<strong>有接收者为方法，无接收者为函数</strong>。值接收者调用时会使用这个值的副本来执行，如下所示<code>changeEmailV2</code>方法是无效的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cusUser <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *cusUser)</span> <span class="title">changeEmailV1</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">u.email = email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u cusUser)</span> <span class="title">changeEmailV2</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">u.email = email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>若要创建一个新值，该类型的方法使用值接收者，若要修改当前值，使用指针接收者。</strong></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><code>Go</code>无类和继承的概念，<code>Go</code>语言的接口在命名时，一般会在单词后面添加 <code>er</code>；当方法名首字母大写时，且该接口类型名首字母也大写时，该方法可被接口所在的包之外的代码访问。</p><p>接口被实现必须满足，<strong>接口的方法与实现接口的类型方法格式一致，接口中所有方法均被现实</strong>。类型和接口之间有一对多和多对一的关系。一个类型可以同时实现多个接口，一个接口的方法，不一定需要由一个类型完全实现。</p><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。只要<strong>接口的所有方法被实现</strong>，则这个接口中的所有嵌套接口的方法均可以被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">   WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">   CanWriter() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">   WriterClose() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FileWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NetWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">   FileWriter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *FileWriter)</span> <span class="title">WriteData</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"WriteData:"</span>, data)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *FileWriter)</span> <span class="title">WriterClose</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"FileWriter Close"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *NetWriter)</span> <span class="title">CanWriter</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"CanWrite"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileWriter := <span class="built_in">new</span>(FileWriter)</span><br><span class="line">fileWriter.WriterClose()</span><br><span class="line">fileWriter.WriteData(<span class="string">"FileWriter"</span>)</span><br><span class="line"></span><br><span class="line">netWriter := <span class="built_in">new</span>(NetWriter)</span><br><span class="line">netWriter.WriterClose()</span><br><span class="line">netWriter.WriteData(<span class="string">"NetWriter"</span>)</span><br><span class="line">netWriter.CanWriter()</span><br><span class="line"></span><br><span class="line">f := <span class="built_in">new</span>(NetWriter)</span><br><span class="line"><span class="keyword">var</span> writer DataWriter</span><br><span class="line">writer = f</span><br><span class="line">writer.WriteData(<span class="string">"NetWriter2"</span>)</span><br><span class="line">writer.CanWriter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writer DataWriter = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">writer = f</span><br><span class="line">writer.WriteData(<span class="string">"NetWriter3"</span>)</span><br><span class="line">writer.CanWriter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writeCloser DataWriteCloser = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">writeCloser.WriterClose()</span><br><span class="line">writeCloser.WriteData(<span class="string">"writeCloser"</span>)</span><br><span class="line">writeCloser.CanWriter()</span><br></pre></td></tr></table></figure><p>将接口转换为其他接口，若不写<code>ok</code>接收是否为实现该类型，若<code>rw</code>没有完全实现接口，将触发宕机。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writeCloser DataWriteCloser = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">rw, ok := writeCloser.(Closer)</span><br><span class="line">fmt.Println(ok, <span class="string">";"</span>, rw.WriterClose())</span><br></pre></td></tr></table></figure><p>将接口转换为其他类型时，接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writeCloser DataWriteCloser = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">rw, ok := writeCloser.(*NetWriter)</span><br><span class="line">fmt.Println(ok, <span class="string">";"</span>, rw.WriterClose(), rw.WriteData(<span class="string">"*NetWriter"</span>), rw.CanWriter())</span><br></pre></td></tr></table></figure><p>接口在底层的实现有<code>type</code> 和 <code>data</code>两个部分。显式地将 <code>nil</code> 赋值给接口时，接口的 <code>type</code> 和 <code>data</code> 都将为 <code>nil</code>，此时接口与 nil 值判断是相等的。将带有类型的 <code>nil</code> 赋值给接口时，只有 <code>data</code> 为 <code>nil</code>，而<code>type</code> 不为 <code>nil</code>，此时接口与 <code>nil</code> 判断将不相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> insImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ins *insImpl)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"hi"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStringer</span><span class="params">()</span> <span class="title">fmt</span>.<span class="title">Stringer</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> ins *insImpl = <span class="literal">nil</span></span><br><span class="line">   <span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">fmt.Println(GetStringer() == <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> ins *insImpl = <span class="literal">nil</span></span><br><span class="line">fmt.Println(ins == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>Go的<strong>源码复用</strong>建立在<strong>包<code>package</code></strong>的基础上，入口 <code>main()</code> 函数所在的包（<code>package</code>）叫 <code>main</code>。包与文件夹一一对应，一般包的名称就是其源文件所在目录的名称，所有与包相关的操作，必须依赖于<strong>工作目录<code>GOPATH</code></strong>。包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是<strong>包在引用时一般使用全路径引用</strong>。</p><p>包的习惯用法：</p><ul><li>包名一般小写，使用简短且有意义的名称。</li><li>包名一般和所在目录同名，也可不同，包名中不能包含<code>-</code>等特殊符号。</li><li>包一般使用域名作为目录名称，能保证包名的唯一性。</li><li>包名为 <code>main</code> 的包为应用程序的入口包，编译不包含 <code>main</code> 包的源码文件时不会得到可执行文件。</li><li>一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。</li></ul><p>包的引用路径分为<strong>全路径导入</strong>和<strong>相对路径导入</strong>。可以自定义别名引用包；也可用<code>.</code>省略引用格式，相当于把 包直接合并到当前程序中，在使用 包内的方法是可以不用加前缀直接引用；若只执行包初始化的 <code>init</code> 函数，不使用包内部的数据可使用匿名引用格式；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全路径导入：源码位于GOPATH/src/lab/test目录下</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"lab/test"</span></span><br><span class="line"><span class="comment">// 相对路径导入：源码位GOPATH/src/lab/a目录下</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../a"</span></span><br><span class="line"><span class="comment">// 自定义别名引用包</span></span><br><span class="line"><span class="keyword">import</span> F <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 省略引用格式</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 匿名引用格式</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"fmt"</span></span><br></pre></td></tr></table></figure><p>一个包可有多个 <code>init</code> 函数，包加载时会执行全部 <code>init</code> 函数，但<strong>不能保证执行顺序</strong>；包<strong>不能出现环形引用</strong>；包<strong>允许重复引用</strong>；包初始化程序从 <code>main</code> 函数引用的包开始，<strong>逐级查找</strong>包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图；编译器会将<strong>有向无环图</strong>转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化；单个包的初始化<strong>先初始化常量，然后是全局变量，最后执行包的 <code>init</code> 函数</strong>。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p><code>Go</code> 的并发通过 <code>goroutine</code>特性完成。<code>goroutine</code> 类似于<strong>线程</strong>，但是可根据需要创建多个 <code>goroutine</code> 并发工作。<code>goroutine</code> 是由 <strong><code>Go</code> 运行时调度完成</strong>，而<strong>线程是由操作系统调度完成</strong>。</p><p><code>Go</code> 提供 <code>channel</code>在多个 <code>goroutine</code> 间进行通信，<code>channel</code>是<strong>类型相关</strong>的<strong>语言级别</strong>得<code>goroutine</code>间的<strong>进程内</strong>的通信方式。必须使用 <code>make</code> 创建 <code>channel</code>；可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="number">1</span> &#125;()</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="string">"hi"</span> &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Equip <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> *Equip)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- &amp;Equip&#123;a: <span class="number">1</span>, b: <span class="number">2</span>&#125; &#125;()</span><br></pre></td></tr></table></figure><p>通道使用<code>&lt;-</code>操作符<strong>发送</strong>和<strong>接收</strong>数据；把数据往通道中发送时，若接收方一直<strong>未接收</strong>，发送操作将<strong>持续阻塞</strong>；通道的收发操作在<strong>不同的两个 <code>goroutine</code> 间进行</strong>；接收将<strong>持续阻塞</strong>直到发送方发送数据；每次接收<strong>一个</strong>元素；<strong>被关闭的通道</strong>不会被置为 <code>nil</code>。对已经关闭的通道进行发送，将会触发宕机。从<strong>已关闭</strong>的通道<strong>接收数据</strong>或者正在接收数据时，将会接收到通道<strong>类型的零值</strong>，然后<strong>停止阻塞并返回</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞接收数据</span></span><br><span class="line">data := &lt;-ch</span><br><span class="line"><span class="comment">// 非阻塞接收数据，可能造成高CPU占用，很少使用，若ok未false表示通道ch已关闭</span></span><br><span class="line">data, ok := &lt;-ch</span><br><span class="line"><span class="comment">// 接收任意数据，忽略接收数据</span></span><br><span class="line">&lt;- ch</span><br><span class="line"><span class="comment">// 声明一个只能发送的通道类型</span></span><br><span class="line"><span class="keyword">var</span> chSendOnly = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 声明一个只能接收的通道类型</span></span><br><span class="line"><span class="keyword">var</span> chRecvOnly = <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 关闭通道</span></span><br><span class="line"><span class="built_in">close</span>(chSendOnly)</span><br><span class="line"><span class="comment">// 带缓冲的通道，缓冲通道被填满时，发送数据时发生阻塞，带缓冲通道为空时，接收数据时发生阻塞</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>协程有<strong>独立的栈空间</strong>，<strong>共享堆空间</strong>，调度由用户自己控制，本质上类似于用户级线程，这些用户级线程的调度也是自己实现的。<strong>一个线程上可以跑多个协程，协程是轻量级的线程</strong>。</p><p>使用 <code>go</code> 关键字创建 <code>goroutine</code> 时，被调用函数的<strong>返回值会被忽略</strong>。若要在 <code>goroutine</code> 中返回数据，通过通道把数据从 <code>goroutine</code> 中作为返回值传出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(param1, param2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"param3, param4:"</span>, param1, param2)</span><br><span class="line">&#125;(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><code>Go</code>未为<code>channel</code>专门设置超时处理机制，但可通过<code>select</code>来设置超时。select用法与switch很类似，但select中只要其中一个<code>case</code>已经完成，程序就会继续往下执行，而不会考虑其他<code>case</code>情况，且每个<code>case</code>语句里必须是一个<code>IO</code>操作，<code>select</code>是按顺序<strong>从头至尾</strong>评估。若无语句可执行，则执行<code>default</code>语句，否则被阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num := &lt;-ch:</span><br><span class="line">    fmt.Println(<span class="string">"num:"</span>, num)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">    quit &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Go</code>的<code>sync</code>包中提供互斥锁<code>sync.Mutex</code>和读写互斥锁<code>sync.RWMutex</code>。同时提供了等待组<code>sync.WaitGroup</code>进行多个任务的<strong>同步</strong>，每个 <code>sync.WaitGroup</code> 值在内部维护着一个计数，保证在并发环境中完成指定数量的任务，若<code>WaitGroup</code>的值大于0，<code>Wait</code>方法就会被阻塞。同时提供原子访问<code>atomic</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw sync.Mutex</span><br><span class="line">rw.Lock()</span><br><span class="line"><span class="keyword">defer</span> rw.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rw sync.RWMutex</span><br><span class="line">rw.RLock()</span><br><span class="line"><span class="keyword">defer</span> rw.RUnlock()</span><br><span class="line">rw.Lock()</span><br><span class="line"><span class="keyword">defer</span> rw.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done() </span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">atomic.AddInt32(&amp;counter, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 安全的写整型值</span></span><br><span class="line">atomic.StoreInt64(&amp;counter, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 安全的读整型值</span></span><br><span class="line">atomic.LoadInt64(&amp;counter)</span><br></pre></td></tr></table></figure><p>死锁发生条件：</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不剥夺条件</li><li>环路等待</li></ul><p>解决办法：</p><ul><li>并发范文多个表，约定访问顺序</li><li>同一事物中，尽可能一次锁定获取所需资源</li><li>容易死锁业务场景，尝试升级锁颗粒度</li><li>采用分布式事务锁或乐观锁</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><code>reflect</code> 包定义了两个重要的类型 <code>Type</code> 和 <code>Value</code> <strong>任意接口值</strong>在反射中都可以理解为由 <code>reflect.Type</code> 和 <code>reflect.Value</code> 两部分组成；提供了<code>reflect.TypeOf</code> 和<code>reflect.ValueOf</code> 两个函数来获取任意对象的 <code>Value</code> 和 <code>Type</code>。</p><p>反射中分<strong>类型<code>Type</code></strong>和<strong>种类<code>Kind</code></strong>，当需要区分一个<strong>大品种</strong>的类型时用<code>Kind</code>，<code>Kind</code>方法描述的是<strong>基础类型</strong>；如需统一判断类型中的指针时。而Type是指<strong>系统原生数据类型</strong>，以及<strong>使用<code>type</code>关键字定义的类型</strong>。通过 <code>reflect.Elem()</code> 方法<strong>获取该指针指向的元素类型</strong>。<code>Elem</code>方法能够<strong>对指针进行解引用</strong>，然后将结果存储到<strong>反射 Value 类型对象</strong>  中。</p><p>反射可以将<strong>接口类型变量</strong>转换为<strong>反射类型对象</strong>，反射可以将<strong>反射类型对象</strong>转换为<strong>接口类型变量</strong>，若要修改<strong>反射类型对象</strong>其<strong>值必须是可写的</strong>。可通过 <code>CanSet</code> 方法检查<code>reflect.Value</code>类型变量的<strong>可写性</strong>。对于<strong>不具有可写性</strong>的 <code>Value</code> 类型变量，调用 <code>Set</code> 方法会<strong>报错</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">    B <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := &amp;T&#123;&#125;</span><br><span class="line">typeOfT := reflect.TypeOf(t)</span><br><span class="line"><span class="comment">// Name: ,Kind:ptr</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, typeOfT.Name(), <span class="string">"kind:"</span>, typeOfT.Kind())</span><br><span class="line"><span class="comment">// 通过 reflect.Elem() 方法获取这个指针指向的元素类型</span></span><br><span class="line">typeOfT = typeOfT.Elem()</span><br><span class="line"><span class="comment">// Name: T,Kind: struct</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, typeOfT.Name(), <span class="string">"kind:"</span>, typeOfT.Kind())</span><br><span class="line">typeOfT.Field(<span class="number">0</span>).SetInt(<span class="number">99</span>)</span><br><span class="line">typeOfT.Field(<span class="number">1</span>).SetString(<span class="string">"Sunset Strip"</span>)</span><br><span class="line"></span><br><span class="line">t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</span><br><span class="line">typeOfA := reflect.TypeOf(t)</span><br><span class="line"><span class="comment">// Name: T,Kind: struct</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, typeOfA.Name(), <span class="string">"kind:"</span>, typeOfA.Kind())</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">7</span></span><br><span class="line">tof := reflect.TypeOf(x)</span><br><span class="line"><span class="comment">// Name: MyInt,Kind: int</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, tof.Name(), <span class="string">"kind:"</span>, tof.Kind())</span><br><span class="line">vof := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 不能是int</span></span><br><span class="line">ref := vof.Interface().(MyInt)</span><br><span class="line">fmt.Println(<span class="string">"can set:"</span>, vof.CanSet()) <span class="comment">// false</span></span><br><span class="line">vof2 := reflect.ValueOf(&amp;x)</span><br><span class="line">fmt.Println(<span class="string">"can set:"</span>, vof2.CanSet()) <span class="comment">// false</span></span><br><span class="line">vof3 := vof2.Elem()</span><br><span class="line">fmt.Println(<span class="string">"can set:"</span>, vof3.CanSet()) <span class="comment">// true</span></span><br><span class="line">vof3.SetInt(<span class="number">25</span>)</span><br><span class="line">fmt.Println(<span class="string">"ref:"</span>, vof3)  <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p><code>Map</code>、<code>Slice</code>、<code>Chan</code> 属于<strong>引用类型</strong>，使用起来<strong>类似于指针</strong>，但是在种类常量定义中仍然属于<strong>独立的种类Kind</strong>，不属于 <code>Ptr</code>。所有通过<code>reflect.ValueOf(x)</code> 返回的<code>reflect.Value</code>都<strong>不可以取地址</strong>，通过<strong>指针</strong>间接地获取的<code>reflect.Value</code>都可以取地址，即使开始的是一个不可取地址的<code>Value</code>。当<strong><code>reflect.Value</code>不可寻址</strong>时，使用 <code>Addr()</code> 方法也<strong>无法取到值的地址</strong>。</p><p>已知<code>reflect.Type</code>时，可动态地创建这个类型的实例，实例的类型为<strong>指针</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">typeOfA := reflect.TypeOf(a)</span><br><span class="line">aIns := reflect.New(typeOfA)</span><br><span class="line"><span class="comment">// name: *int, kind: ptr</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, aIns.Type(), <span class="string">"kind:"</span>, aIns.Kind())</span><br></pre></td></tr></table></figure><p>使用反射调用函数时，需将参数使<strong>用反射值对象的切片<code>[]reflect.Value</code>构造后传入<code>Call()</code>方法中</strong>，调用完成时，函数的<strong>返回值</strong>通过<code>[]reflect.Value</code>返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">funcVal := reflect.ValueOf(<span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b</span><br><span class="line">&#125;)</span><br><span class="line">paramList := []reflect.Value&#123;reflect.ValueOf(<span class="number">10</span>), reflect.ValueOf(<span class="number">24</span>)&#125;</span><br><span class="line">retList := funcVal.Call(paramList)</span><br><span class="line">fmt.Println(<span class="string">"result:"</span>, retList[<span class="number">0</span>].Int())</span><br></pre></td></tr></table></figure><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><ul><li>测试用例文件<strong>不会参与正常源码的编译</strong>，<strong>不会被包含到可执行文件中</strong>；</li><li>测试用例的文件名必须以<code>_test.go</code>结尾；</li><li>需要使用 <code>import</code> 导入 <code>testing</code> 包；</li><li>测试函数的名称要以<code>Test</code>或<code>Benchmark</code>开头，后面可以跟任意字母组成的字符串，但第一个字母必须大写，例如 TestAbc()，一个测试用例文件中可以包含多个测试函数；</li><li>单元测试则以<code>(t *testing.T)</code>作为参数，性能测试以<code>(t *testing.B)</code>做为参数；</li><li>测试用例文件使用<code>go test</code>命令来执行，源码中不需要 main() 函数作为入口，所有以<code>_test.go</code>结尾的源码文件内以<code>Test</code>开头的函数都会自动执行。</li></ul><h3 id="SetFinalizer"><a href="#SetFinalizer" class="headerlink" title="SetFinalizer"></a>SetFinalizer</h3><p><code>Go</code>语言自带垃圾回收机制，<code>GC</code> 是自动进行的，可以使用 <code>runtime.GC()</code> 函数手动 <code>GC</code>。</p><p><code>finalizer</code>（<strong>终止器</strong>）是通过 <strong>runtime.SetFinalizer</strong> 来设置与对象关联的一个函数，若某对象定义了 <code>finalizer</code>，当它被 <code>GC</code> 时候，该<code>finalizer</code> 将被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFinalizer</span><span class="params">(x, f <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p>参数<code>x</code> 必须是一个指向通过 <code>new</code> 申请的对象的<strong>指针</strong>，或者通过对复合字面值取址得到的<strong>指针</strong>，参数 <code>f</code> 必须是一个<strong>函数</strong>。<code>SetFinalizer</code> 函数将 <code>x</code> 的终止器设置为 <code>f</code>，当垃圾收集器发现 <code>x</code> 不能再直接或间接访问时，则清理 <code>x</code> 并调用 <code>f(x)</code>，终止器会在 <code>x</code> 不能直接或间接访问后的<strong>任意时间</strong>被调用执行，<strong>不保证终止器会在程序退出前执行</strong>，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。<code>*x</code> 的大小为 <code>0</code> 字节，也不保证终止器会执行。也可以使用<code>SetFinalizer(x, nil)</code>来清理绑定到 <code>x</code> 上的终止器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Road <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRoad</span><span class="params">(r *Road)</span></span> &#123;</span><br><span class="line">   log.Println(<span class="string">"road:"</span>, *r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entry</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> rd = Road(<span class="number">999</span>)</span><br><span class="line">   r := &amp;rd</span><br><span class="line">   runtime.SetFinalizer(r, findRoad)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    runtime.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Go&lt;/code&gt;语言是&lt;strong&gt;静态类型&lt;/strong&gt;语言，&lt;strong&gt;所有的内存在 &lt;code&gt;Go&lt;/code&gt; 中都是经过初始化的&lt;/strong&gt;，当一个变量被声明之后，&lt;strong&gt;系统自动赋予它该类型的零值&lt;/strong&gt;：&lt;co
      
    
    </summary>
    
      <category term="Go" scheme="https://yaoyinglong.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://yaoyinglong.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>亲密关系</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/亲密关系/</id>
    <published>2020-06-26T16:00:00.000Z</published>
    <updated>2020-06-27T03:33:30.709Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候问题不能解决，是因为我们在非常有限的知识来源中寻找答案，却不懂得运用我们的想象力和直觉来突破问题的框架。</p><ul><li>要解决问题，必须先跳脱问题的框架</li><li>所有问题，其实都是经过伪装的礼物和宝贵的经验</li><li>你所看到的每件事，都是你内心世界的投影</li><li>每个人都有能力为自己生活中遇到的事百分百负责</li><li>自由并非来自答案，而是来自问题</li><li>没有什么问题是大道爱无法解决的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多时候问题不能解决，是因为我们在非常有限的知识来源中寻找答案，却不懂得运用我们的想象力和直觉来突破问题的框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要解决问题，必须先跳脱问题的框架&lt;/li&gt;
&lt;li&gt;所有问题，其实都是经过伪装的礼物和宝贵的经验&lt;/li&gt;
&lt;li&gt;你所看到的每件事，
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>情商</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E6%83%85%E5%95%86/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/情商/</id>
    <published>2020-06-24T16:00:00.000Z</published>
    <updated>2020-06-25T11:53:04.756Z</updated>
    
    <content type="html"><![CDATA[<p>提高情商是把<strong>不可控情绪</strong>的部分变为<strong>可控制情绪</strong>，从而<strong>增强理解他人</strong>及<strong>与他人相处</strong>的能力。</p><h3 id="低情商特点"><a href="#低情商特点" class="headerlink" title="低情商特点"></a>低情商特点</h3><ul><li><p>说话做事时<strong>无意识</strong>顾及别人的感受</p></li><li><p><strong>下意识</strong>地推卸责任、散发负面情绪</p></li><li>感知力差，<strong>收不到</strong>他人的情绪反馈</li><li><strong>缺乏</strong>安全感，渴望得到他人的关注</li><li>惯性泼冷水，<strong>没有</strong>赞美他人的天性</li></ul><h5 id="情商五要素"><a href="#情商五要素" class="headerlink" title="情商五要素"></a>情商五要素</h5><ul><li>了解自我</li><li>自我情绪</li><li>自我激励</li><li>识别他人情绪</li></ul><p>情商即是<strong>认识自己</strong>也是<strong>认识他人</strong>，认识自己包括<strong>自我定位</strong>、<strong>自我管理</strong>、<strong>自我激励</strong>；认识他人包括洞<strong>察情绪</strong>、<strong>同理心</strong>、<strong>学会沟通</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提高情商是把&lt;strong&gt;不可控情绪&lt;/strong&gt;的部分变为&lt;strong&gt;可控制情绪&lt;/strong&gt;，从而&lt;strong&gt;增强理解他人&lt;/strong&gt;及&lt;strong&gt;与他人相处&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;h3 id=&quot;低情商特点&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>树基础</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/树基础/</id>
    <published>2020-06-21T16:00:00.000Z</published>
    <updated>2020-07-30T02:40:31.772Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>每个节点有<strong>零个</strong>或<strong>多个</strong>子节点；</li><li>没有父节点的节点称为<strong>根节点</strong>；</li><li>每个<strong>非根节点</strong>有且<strong>仅有一个</strong>父节点；</li><li>除了根节点以外，<strong>每个子节点都可分为多个不相交的子树</strong>；</li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度，<strong>二叉树的度为2</strong>；</li><li><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度；</li><li><strong>叶节点或终端节点</strong>：度为零的节点；</li><li><strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li><strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li><li><strong>兄弟节点</strong>：具有<strong>相同父节点</strong>的节点互称为兄弟节点；</li><li><strong>节点的层次</strong>：从根开始定义起，<strong>根为第<code>1</code>层</strong>，根的子节点为第2层，以此类推；</li><li><strong>树的高度或深度</strong>：树中节点的<strong>最大层次</strong>；</li><li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li><li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li><li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li><li><strong>森林</strong>：由<code>m（m&gt;=0）</code>棵互不相交的树的集合称为森林；</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><strong>无序树</strong>：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为<strong>自由树</strong>；</li><li><strong>有序树</strong>：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul><li><strong>二叉树</strong>：每个节点最多含有两个子树的树称为二叉树；<ul><li><strong>完全二叉树</strong>：对于一颗二叉树，假设其深度为<code>d(d&gt;1)</code>。除了第<code>d</code>层外，其它各层的节点数目均已达最大值，且第<code>d</code>层所有节点<strong>从左向右连续地紧密排列</strong>，这样的二叉树被称为完全二叉树，其中<strong>满二叉树</strong>的定义是所有叶节点都在最底层的完全二叉树;</li><li><strong>平衡二叉树</strong>（<code>AVL</code>树，<strong>红黑树</strong>是该树的一种）：<strong>当且仅当任何节点的两棵子树的高度差不大于1</strong>的二叉树，<code>SGI</code>/<code>STL</code>的<code>set</code>/<code>map</code>底层都是用<strong>红黑树</strong>实现的；</li><li><strong>排序二叉树</strong>（<strong>二叉查找树</strong>（英语：<code>Binary Search Tree</code>），也称<strong>二叉搜索树</strong>、<strong>有序二叉树</strong>）；</li></ul></li><li><strong>霍夫曼树</strong>（用于信息编码）：<strong>带权路径最短的二叉树</strong>称为哈夫曼树或<strong>最优二叉树</strong>；</li><li><strong>B树</strong>：一种<strong>对读写操作进行优化的自平衡的二叉查找树</strong>，能够保持数据有序，拥有多余两个子树。</li></ul></li></ul><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>​    二叉树的遍历分为<strong>广度优先遍历</strong>和<strong>深度优先遍历</strong>，广度优先遍历又叫<strong>层序遍历</strong>，从上往下每一层<strong>从左到右</strong>依次访问节点；深度优先遍历可细分为<strong>先序遍历</strong>、<strong>中序遍历</strong>、<strong>后续遍历</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    TreeNode leftNode;</span><br><span class="line">    TreeNode rightNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p>对任一子树，先访问根，然后遍历其左子树，最后遍历其右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(treeNode);</span><br><span class="line">    preorder(treeNode.leftNode);</span><br><span class="line">    preorder(treeNode.rightNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode tree = stack.pop();</span><br><span class="line">        System.out.println(tree);</span><br><span class="line">        <span class="keyword">if</span> (tree.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tree.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tree.leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>对任一子树，先遍历其左子树，然后访问根，最后遍历其右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(treeNode.leftNode);</span><br><span class="line">    System.out.println(treeNode);</span><br><span class="line">    inorder(treeNode.rightNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode currentNode = root;</span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="keyword">null</span> &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(currentNode);</span><br><span class="line">            currentNode = currentNode.leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode = stack.pop();</span><br><span class="line">        System.out.print(currentNode);</span><br><span class="line">        currentNode = currentNode.rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backorder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    backorder(treeNode.leftNode);</span><br><span class="line">    backorder(treeNode.rightNode);</span><br><span class="line">    System.out.println(treeNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backOrderDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode currentNode = root;</span><br><span class="line">        TreeNode rightNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span> &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(currentNode);</span><br><span class="line">                currentNode = currentNode.leftNode;</span><br><span class="line">            &#125;</span><br><span class="line">            currentNode = stack.pop();</span><br><span class="line">            <span class="keyword">while</span> (currentNode.rightNode == <span class="keyword">null</span> || currentNode.rightNode == rightNode) &#123;</span><br><span class="line">                System.out.print(currentNode);</span><br><span class="line">                rightNode = currentNode;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                currentNode = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(currentNode);</span><br><span class="line">            currentNode = currentNode.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="层序遍历-广度优先遍历"><a href="#层序遍历-广度优先遍历" class="headerlink" title="层序遍历|广度优先遍历"></a>层序遍历|广度优先遍历</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode tree = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (tree.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(tree.leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(tree.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">        lists.add(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>计算二叉树的深度可以通过后序遍历和层序遍历计算二叉树的深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.leftNode), maxDepth(root.rightNode)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        maxDepth++;</span><br><span class="line">        <span class="keyword">int</span> len = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            TreeNode treeNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (treeNode.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(treeNode.leftNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(treeNode.rightNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> diameter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameter</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> diameter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = depth(treeNode.leftNode);</span><br><span class="line">    <span class="keyword">int</span> right = depth(treeNode.rightNode);</span><br><span class="line">    diameter = Math.max(left + right, diameter);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="镜像二叉树转换"><a href="#镜像二叉树转换" class="headerlink" title="镜像二叉树转换"></a>镜像二叉树转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode tmp = root.left;</span><br><span class="line">    root.left = mirrorTree(root.right);</span><br><span class="line">    root.right = mirrorTree(tmp);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode treeNode = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(treeNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(treeNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tmp = treeNode.left;</span><br><span class="line">        treeNode.left = treeNode.right;</span><br><span class="line">        treeNode.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称二叉树判断"><a href="#对称二叉树判断" class="headerlink" title="对称二叉树判断"></a>对称二叉树判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span> || p.val != q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个节点有&lt;strong&gt;零个&lt;/strong&gt;或&lt;strong&gt;多个&lt;/strong&gt;子节点；&lt;/li&gt;
&lt;li&gt;没有父节点的
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://yaoyinglong.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/图/</id>
    <published>2020-06-21T16:00:00.000Z</published>
    <updated>2020-07-13T11:40:15.372Z</updated>
    
    <content type="html"><![CDATA[<p>​    图可分为<strong>有向图</strong>和<strong>无向图</strong>，一般用<code>G=(V,E)</code>来表示图，<code>V</code>表示顶点，<code>E</code>表示通过图的边，常用<strong>邻接矩阵</strong>或者<strong>邻接表</strong>来描述一副图。图的遍历算法，根据访问节点的顺序，可分为<strong>广度优先搜索</strong>（<code>BFS</code>：Breadth First Search）和<strong>深度优先搜索</strong>（<code>DFS</code>：）</p><h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><p>​    广度优先搜索在进一步遍历图中顶点之前，<strong>先访问当前顶点的所有邻接结点</strong>。</p><ol><li>首先选择一个顶点作为起始结点</li><li>将起始结点放入队列中</li><li>从队列首部选出一个顶点，并找出所有与之邻接的结点，将找到的邻接结点放入队列尾部</li><li>按照同样的方法处理队列中的下一个结点</li></ol><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>​    深度优先搜索在搜索过程中访问某个顶点后，需要<strong>递归</strong>地访问此顶点的<strong>所有未访问过的相邻顶点</strong>，<code>DFS</code>在<strong>环监测</strong>和<strong>拓扑排序</strong>中都有不错的应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    图可分为&lt;strong&gt;有向图&lt;/strong&gt;和&lt;strong&gt;无向图&lt;/strong&gt;，一般用&lt;code&gt;G=(V,E)&lt;/code&gt;来表示图，&lt;code&gt;V&lt;/code&gt;表示顶点，&lt;code&gt;E&lt;/code&gt;表示通过图的边，常用&lt;strong&gt;邻接矩阵&lt;/s
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>幽默感</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E5%B9%BD%E9%BB%98%E6%84%9F/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/幽默感/</id>
    <published>2020-06-20T16:00:00.000Z</published>
    <updated>2020-06-21T13:03:03.447Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring常面问题</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/Spring%E5%B8%B8%E9%9D%A2%E9%97%AE%E9%A2%98/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/Spring常面问题/</id>
    <published>2020-06-18T16:00:00.000Z</published>
    <updated>2020-06-22T14:47:52.478Z</updated>
    
    <content type="html"><![CDATA[<p>1、Spring Boot、Spring MVC、Spring之间的区别？（Spring Boot本质是什么？）</p><p>2、Spring Boot Starter是什么？</p><p>3、如何自定义Spring Boot Starter？（如何扩展Spring Boot）</p><p>4、Spring Boot的自动装配原理是什么？（源码分析哦）</p><p>5、Spring Boot的启动流程是什么？</p><p>6、有没有看过Spring Boot源码？你觉得最神奇的地方是什么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、Spring Boot、Spring MVC、Spring之间的区别？（Spring Boot本质是什么？）&lt;/p&gt;
&lt;p&gt;2、Spring Boot Starter是什么？&lt;/p&gt;
&lt;p&gt;3、如何自定义Spring Boot Starter？（如何扩展Spring B
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库常面问题</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E9%9D%A2%E9%97%AE%E9%A2%98/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/数据库常面问题/</id>
    <published>2020-06-18T16:00:00.000Z</published>
    <updated>2020-06-22T14:47:52.478Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>Excel文件数据抽取</title>
    <link href="https://yaoyinglong.github.io/Blog/Python/Excel%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%8A%BD%E5%8F%96/"/>
    <id>https://yaoyinglong.github.io/Blog/Python/Excel文件数据抽取/</id>
    <published>2020-06-18T16:00:00.000Z</published>
    <updated>2020-06-22T14:47:52.488Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅仅是对Excel中的数据进行了简单的读取抽出并统一输出到指定的地方，在读取老版本xls文件的时候可能会出现编码的问题导致文件读取失败：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: <span class="string">'utf-16-le'</span> codec can<span class="string">'t decode byte 0x40 in position 104: truncated data</span></span><br></pre></td></tr></table></figure></p><p>可以通过对报错的源码<code>unpack_unicode</code>代码进行<code>try-except</code>并将其赋值为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    strg = unpack_unicode(data, <span class="number">0</span>, lenlen=<span class="number">2</span>) </span><br><span class="line"><span class="keyword">except</span>: </span><br><span class="line">    strg = <span class="string">""</span></span><br></pre></td></tr></table></figure><p>以下代码仅仅是遍历指定目录下的所有文件，之所以多写一重判断循环文件，是为了将第一层的文件夹名称生成一个新的<code>sheet</code>，第一级文件夹下的所有文件的数据都统计到当前文件夹名称所对应的<code>sheet</code>中，且对实际情况进行了简单的数据过滤和处理，在此仅仅是存储一个简单的模板，后续有其他的需求可在该模板上持续修改优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_value</span><span class="params">(basePath)</span>:</span></span><br><span class="line">    fileDirs = os.listdir(basePath)</span><br><span class="line">    dataAllValue = pd.DataFrame()</span><br><span class="line">    <span class="keyword">for</span> fileDir <span class="keyword">in</span> fileDirs:</span><br><span class="line">        childFile = os.path.join(<span class="string">'%s%s%s'</span> % (basePath, <span class="string">"\\"</span>, fileDir))</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(childFile):</span><br><span class="line">            <span class="keyword">if</span> fileDir.endswith(<span class="string">"xls"</span>) <span class="keyword">or</span> fileDir.endswith(<span class="string">"xlsx"</span>) <span class="keyword">or</span> fileDir.endswith(<span class="string">"XLS"</span>) <span class="keyword">or</span> fileDir.endswith(<span class="string">"XLSX"</span>):</span><br><span class="line">                colunm_count, sheetDataFrameValue = read_excel(childFile)</span><br><span class="line">                <span class="keyword">if</span> sheetDataFrameValue.empty:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> colunm_count == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dataAllValue = dataAllValue.append(sheetDataFrameValue)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(childFile):</span><br><span class="line">            childDataFrameValue = find_value(childFile)</span><br><span class="line">            dataAllValue = dataAllValue.append(childDataFrameValue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataAllValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span><span class="params">(childFile)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        FileObj = xlrd.open_workbook(childFile)  <span class="comment"># 打开处理的excel文件</span></span><br><span class="line">        sheetNames = FileObj.sheet_names()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"有问题的文件："</span>, childFile)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, pd.DataFrame()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> sheetName <span class="keyword">in</span> sheetNames:</span><br><span class="line">        sheet = FileObj.sheets()[i]  <span class="comment"># 获取第一个工作表</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        row_count = sheet.nrows  <span class="comment"># 行数</span></span><br><span class="line">        colunm_count = <span class="number">0</span></span><br><span class="line">        sheetDataFrameValue = pd.DataFrame()</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> range(<span class="number">2</span>, row_count):</span><br><span class="line">            row_values = [cell_value_clear(cell_value) <span class="keyword">for</span> cell_value <span class="keyword">in</span> sheet.row_values(element)]</span><br><span class="line">            <span class="keyword">for</span> keyValue <span class="keyword">in</span> keyValues:</span><br><span class="line">                <span class="keyword">if</span> keyValue.lower() <span class="keyword">in</span> row_values:</span><br><span class="line">                    findCon = sheet.row_values(element)</span><br><span class="line">                    not_empty = [i <span class="keyword">for</span> i <span class="keyword">in</span> findCon <span class="keyword">if</span> i != <span class="string">''</span>]</span><br><span class="line">                    <span class="keyword">if</span> len(not_empty) &lt; <span class="number">3</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    columnDf = pd.DataFrame(findCon)</span><br><span class="line">                    columnDf.rename(columns=&#123;<span class="number">0</span>: colunm_count&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">                    <span class="keyword">if</span> sheetDataFrameValue.empty:</span><br><span class="line">                        sheetDataFrameValue = columnDf.join(sheetDataFrameValue)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        sheetDataFrameValue = sheetDataFrameValue.join(columnDf)</span><br><span class="line">                    colunm_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> colunm_count, sheetDataFrameValue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cell_value_clear</span><span class="params">(cell_value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cell_value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> str(cell_value).replace(<span class="string">" "</span>, <span class="string">""</span>).lower()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_excel_xlsx</span><span class="params">(dataFrameValue1, sheetName, excelName)</span>:</span></span><br><span class="line">    newExcel = pd.DataFrame(dataFrameValue1)</span><br><span class="line">    writer = pd.ExcelWriter(excelName, engine=<span class="string">'openpyxl'</span>)</span><br><span class="line">    is_file_exists = os.path.exists(excelName)  <span class="comment"># 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> is_file_exists <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        book = openpyxl.load_workbook(writer.path)</span><br><span class="line">        writer.book = book</span><br><span class="line">        newExcel.to_excel(excel_writer=writer, sheet_name=sheetName, encoding=<span class="string">"utf-8"</span>, index=<span class="literal">False</span>)</span><br><span class="line">        writer.save()</span><br><span class="line">        writer.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        newExcel.to_excel(excel_writer=writer, sheet_name=sheetName, encoding=<span class="string">"utf-8"</span>, index=<span class="literal">False</span>)</span><br><span class="line">        writer.save()</span><br><span class="line">        writer.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(basePath)</span>:</span></span><br><span class="line">    pathDirs = os.listdir(basePath)</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> pathDirs:</span><br><span class="line">        provinceDataPath = os.path.join(<span class="string">'%s%s%s'</span> % (basePath, <span class="string">"\\"</span>, path))</span><br><span class="line">        print(provinceDataPath)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(provinceDataPath):</span><br><span class="line">            dataAllValue = find_value(provinceDataPath)</span><br><span class="line">            print(dataAllValue)</span><br><span class="line">            <span class="keyword">if</span> dataAllValue.empty:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            write_excel_xlsx(dataAllValue, path, excelName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 文件路径</span></span><br><span class="line">    basePath = <span class="string">r"F:\data"</span></span><br><span class="line">    keyValues = [<span class="string">"指标1"</span>, <span class="string">"指标2"</span>, <span class="string">"指标3"</span>, <span class="string">"指标4"</span>]</span><br><span class="line">    excelName = <span class="string">'F:\抽取数据\数据统计总览.xlsx'</span>  <span class="comment"># 文件保存的路径</span></span><br><span class="line">    run(basePath)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅仅是对Excel中的数据进行了简单的读取抽出并统一输出到指定的地方，在读取老版本xls文件的时候可能会出现编码的问题导致文件读取失败：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="Python" scheme="https://yaoyinglong.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://yaoyinglong.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>和女孩子相处</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E5%92%8C%E5%A5%B3%E5%AD%A9%E5%AD%90%E7%9B%B8%E5%A4%84/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/和女孩子相处/</id>
    <published>2020-05-25T16:00:00.000Z</published>
    <updated>2020-06-21T15:02:12.219Z</updated>
    
    <content type="html"><![CDATA[<p><strong>多问对方的意见或建议，尽量给选项，或者让她推荐</strong></p><p><strong>认真你就输了</strong></p><p>菜单，歌单，账单</p><h3 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h3><ul><li>分享音乐</li></ul><h3 id="自建"><a href="#自建" class="headerlink" title="自建"></a>自建</h3><ul><li>培养自己的决断力和勇气，别总是回答：随便、都可以、都挺好等</li><li>尽量体现自己的爱心，让自己有更多的爱心和耐心，控制脾气和情绪。</li><li>提升自己的吸引力、让对方获得更多的舒适感、让对方投资更多</li></ul><h3 id="禁忌"><a href="#禁忌" class="headerlink" title="禁忌"></a>禁忌</h3><ul><li>聊天时不要抱着解决问题的思维</li><li>约会中不能没有主见</li><li>没有话题不要强聊，适可而止</li><li>别每天都是磨磨唧唧的，动不动先情绪爆表，遇事女生还没怎么样，就先焦虑的不行</li><li>尽量多的拿主意，别总是成为跟随着</li><li>犹豫不决，磨磨唧唧，反复纠结的，不是一个有魅力男人的行为</li><li>谨慎的和对方发生争吵，避免自己的负面情绪，尽量让自己不那么邋遢，控制发生关系的频率，婚前减少同居维系新鲜感</li></ul><h3 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h3><ul><li>猫咖</li><li>电玩城</li><li>射箭馆</li><li>逛宜家</li><li>湖边喂鱼</li><li>水族馆</li><li>看电影（私人影院）</li><li>VR</li><li>唱歌</li><li>逛公园（浣花溪公园）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;多问对方的意见或建议，尽量给选项，或者让她推荐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;认真你就输了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;菜单，歌单，账单&lt;/p&gt;
&lt;h3 id=&quot;话题&quot;&gt;&lt;a href=&quot;#话题&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>后悔药</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E5%90%8E%E6%82%94%E8%8D%AF/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/后悔药/</id>
    <published>2020-05-25T16:00:00.000Z</published>
    <updated>2020-06-21T15:28:52.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="挽回心态"><a href="#挽回心态" class="headerlink" title="挽回心态"></a>挽回心态</h3><p>​    没有一个好的挽回心态，任何技巧都等于零，挽回是一个长期的过程，是一次真正的<strong>自我成长</strong>和<strong>救赎</strong>，是不是自己确实掌握了经营好感情的能力、是不是已经真正的获得了成长、是不是你们之间的根本问题已经得到了解决、是不是他真的重新爱上你了、是不是以后你们真的能好好的在一起了；</p><h5 id="心态建设"><a href="#心态建设" class="headerlink" title="心态建设"></a>心态建设</h5><ul><li><strong>最重要的一点</strong>控制你的挽回需求感，难度越大的任务，<strong>动机因素反而越敏感</strong></li><li>避免过度自责</li><li><strong>稳住心态。 不要手贱</strong></li><li><strong>转移注意力 不要把全部心思放在挽回上 那样只会让自己更苦逼。 充实自己的生活 提升自己。</strong></li><li><strong>反撇</strong>：<strong>前期阶段进行讨好策略（是的你没看错），然后突然后撤表示放弃，从而激发起对方损失厌恶的心理，变被动为主动，变低位为高位</strong></li></ul><h5 id="思维重塑"><a href="#思维重塑" class="headerlink" title="思维重塑"></a>思维重塑</h5><h5 id="打破思维墙"><a href="#打破思维墙" class="headerlink" title="打破思维墙"></a>打破思维墙</h5><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;挽回心态&quot;&gt;&lt;a href=&quot;#挽回心态&quot; class=&quot;headerlink&quot; title=&quot;挽回心态&quot;&gt;&lt;/a&gt;挽回心态&lt;/h3&gt;&lt;p&gt;​    没有一个好的挽回心态，任何技巧都等于零，挽回是一个长期的过程，是一次真正的&lt;strong&gt;自我成长&lt;/strong
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>自度</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E8%87%AA%E5%BA%A6/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/自度/</id>
    <published>2020-05-25T16:00:00.000Z</published>
    <updated>2020-06-27T03:33:27.419Z</updated>
    
    <content type="html"><![CDATA[<p>人生不如意事常八九，不爱了或者爱而不得才是人生常态</p><p>人在道理面前，总以为自己明白了，但是只有被真正教训过才会知道明白，就像之前我被天气教育那样，把伞放家里下班的时候下雨，把伞放公司上班的时候下雨，最终我买了两把伞。<br>以前我总以为真诚相待才是相处的根本，被教训过才发现，并不是这样，人与人是不同的，你认知里的真诚在别人眼里或许是污言秽语恶意中伤。</p><p>总是在第一经历某种痛苦或者说苦难的时候，是最煎熬的，也才会学会不要轻易的寄托</p><p>人总是在逆境中快速成长，才会对人生有所感悟</p><p>我是一个平凡孤独平凡且无趣的人，没有伟大的梦想，尽量热爱生活</p><p>渐渐的就发现没有什么特别热爱的东西了</p><p>其实我觉得人生最好的状态就是无欲无求，对任何事都不抱什么什么特别的期待</p><p>其实有一群经常一起玩的好朋友是真的很幸福。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人生不如意事常八九，不爱了或者爱而不得才是人生常态&lt;/p&gt;
&lt;p&gt;人在道理面前，总以为自己明白了，但是只有被真正教训过才会知道明白，就像之前我被天气教育那样，把伞放家里下班的时候下雨，把伞放公司上班的时候下雨，最终我买了两把伞。&lt;br&gt;以前我总以为真诚相待才是相处的根本，被
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>有关于你</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E6%9C%89%E5%85%B3%E4%BA%8E%E4%BD%A0/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/有关于你/</id>
    <published>2020-05-25T16:00:00.000Z</published>
    <updated>2020-06-25T10:46:47.867Z</updated>
    
    <content type="html"><![CDATA[<p>​    我知道我们性格不是很合，但是我会尽我最大可能改变自己，之前我们的每一次的不愉快，我都有用心努力的记下来然后调整我自己，一点一点的去让我能和你相处得更好，我知道在和你相处得时候很多时候，表现的没有主见，但我也不是真的没有主见，只是对在意的人什么都可以接受，什么都可以妥协，最后一次吃饭你叫我点菜，我是想点我喜欢的，但是我在考虑我点的是不是你喜欢的，所以犹豫了很久。和你相处的每一个小细节，我都尽量在用心的记下来，犯过的错，我都会尽量不犯。当时你穿的开叉的裙子，然而我并没有意识到，靠窗会走光的问题，但是你说了后我在心里想，我下次和你一起的时候一定要首先注意这些。我一直想的是我会用心慢慢的去了解你，然后慢慢改变我自己，我是一个很容易向自己在意的人妥协，即使当时即使当时不能立马妥协，但也会慢慢妥协。我一直在努力的让自己变得更好，但是你没有给我足够的时间就放弃我了。</p><p>​    这段时间看了一些书及一些知乎上的文章，没有谈过恋爱的我过于直男，以前真的不觉得自己很直，一直觉得自己是一个很敏感很细心的人，以为很多事情都知道该怎么做，但其实我错了，我连最根本的和女孩子相处应该多征求女孩子的意见和建议都没有搞明白，而且比较贪婪，想要更多跟你相处在一起，以便跟你相处在一起索取更多快乐，没有意识到顾及你的感受。然后对比与你相处的点点滴滴，犯了好多好多致命的错误，难怪你会觉得和我相处很累，可能我都还没有学会该如何好好的去爱一个人，在爱情方面太幼稚了，不能很好的把控自己的情绪和心态，让你和我相处累觉不爱。这段时间一直不断的想起我说的那些的话，对待你的一些不恰当的地方，总觉得自己的沟通力太差了，明明是很在意很喜欢的，却总是在不经意间伤害。刚开始的时候，汪鑫把你们的聊天给我看了一些，知道你有多么为我考虑，对我多么好，我真的好感动，从来没有一个人对我这么好过，觉得遇见你我好幸运。我想我一定要把我所有的好所有的温柔都给你，当时就在跟汪鑫讲，要尽我最大的努力不让你在我这受到伤害，但是却没有做到。</p><p>​    时间过去了这么久了，但我感觉仿佛还是昨天，坐在电脑旁的时候总是不由自主的想起你坐在我旁边的情景，在每一处你停留的地方经过总是不受控制的想起，你当时每一个细微的表情和动作。厨房里你调特制拌酱的场景、厕所的镜子中你整理你新刘海的样子、客厅里玩游戏时你捧着脸笑的样子、一起肩并肩从小区到我上班必经的三叉路口，每次上下班经过的时候总会不由自主的忘一眼，仿佛还能看见当时我在路灯下和你等车冲你的车屁股挥手道别是的画面、一起去北门买菜买烟、第一次牵你的手的感觉、在乒乓球台那一块停留的画面、还有你的拥抱，一遍又一遍越刻越深。有些人总是等到失去后，才追悔莫及，才懂得珍惜。</p><p>​      刚开始以为自己不会那么难受，但是我错了，我以为我可能还没有喜欢你到很深的程度，但是这么长一段时间过去了，对你的感觉不仅仅没有变淡反而越来越强烈，只是没有像刚开始在表面针扎的那么剧烈了，而是向内心深处扎根了越扎越深，有时痛得难以入眠。其实我是一个优柔寡断人，5月13号当天和你说了那些装作满不在乎故作洒脱的狠话后，都没有坚强到正常下班，然后接下来的两周害怕极了一个人独处，因为总是不断的回想起有关于你的一切，虽然我们总共算起来也只是见过四次面，从4月11号第一次见面到5月10号最后一次见面，时间也只有短短的一个月，但是我总是会不由自主的想起你出现在我视线里的所有画面，每天上班下班都会经过第一次你过来找我一起走过的那条路，脑海里都会浮现出你我们一起散步的情景，深夜滴滴载着你回去的背影，心中总是隐隐作痛。我尝试着去忘记，各种方式去转移注意力，但是刚刚还一点点的时候，又被撕开，如此往复。原来你在我心中已经占据了如此总要的分量，这段时间我的天空失去了颜色，做什么事情总会觉得没什么意义。</p><p>​    我以为时间的磨盘会抚平我心中的沟壑，但是这段时间我总是在闲下来的时候，不由自主的想起你，在夜深人静的时候想起你，在早晨一醒来还没睁开眼睛是第一个念头想到的也是你，所以总是忍不住去一遍又一遍的打开网易云音乐看看你最近听什么歌，然后一遍又一遍的听，有时候你好多天都没有更新，每次打开都有些小失落。一遍又一遍点开你朋友圈看看你有没有更新动态，我很少去看与你的聊天记录，害怕自己受不了而奔溃，实在是扛不住了，又会忍不住去翻看，然后又是长时间的自闭，或者通过微信去骚扰你。但每次找你心中有千言万语但却又不知道该说些什么好，而每次找你，隔着屏幕也能感觉到你不是很想理睬我，我也只敢每次简单强聊几句，但是也略微满足。</p><p>​    回想起第一次见面时的场景，对于你这个陌生人，而且在汪鑫说要将你介绍给我认识的前提下，我有点不自然，可能是源于我从小认识和接触的女性极少的缘故，所以第一次见面我表现的对你不理不睬满不在乎，其实总是在偷偷注意，在吃火锅的时候感觉你都没咋吃，然后又去上了一趟厕所，包括你要过苏苏手中的烟，问是什么牌子，然后KTV唱歌的时候偷偷关注你唱歌时的模样，然后后面的时候你出去了好多次，有一次时间还比较长，我还以为你走了呢，然后后面的时候你问我脖子上戴的是什么，让我有点小高兴，但还是故作冷漠和平静，第一次对你的印象感觉你是一个很文静斯文的人，而且说话也比较直爽，是我很喜欢的类型。</p><p>​    但我以为仅此而已，然后在他们的怂恿下我加了你的微信，看到你头像的时候我笑了，更加觉得你是一个真实直爽的人，当时虽然没有聊两句，但是聊起来很舒服，没多少刻意，但是即使那一刻我依然认为应该不怎么会有后续，因为我是一个不自信不主动的人，以为和之前朋友介绍的人一样，只是刚加微信的时候能唠几句，然后就没有然后了；</p><p>​    但我没想到的是你居然主动找我，我高兴坏了。接下来的聊天是我从未有过的体验，那段时间几乎每天都会半夜不由自主的醒来，然后第一个念头就是你，然后久久难以平静下来再次入眠，那段时间毫不夸张的说真的是睡着都笑醒，你是我那段时间唯一的快乐源泉，跟你相处我是真的好开心，想要时时刻刻的靠近你。然后琪琪说我终于进入简单模式了，和你相处的时间，虽然很多时候只是隔着屏幕聊天，但是我能感受得到你总是很为我着想，很体贴，对我真的很好，我是一个很容易被感动的人，好多次想到你有点不由自主的泪光闪烁，然后将头仰起45度角，那时候我更加坚定不能伤害到你，但是最终我还是没有做到，至少说让你有时候很不开心。</p><p>​    第一次你过来找我的时候，我真的好开心好感动，不喜欢舟车劳顿的你，还这么远跑过来找我，和你玩游戏的时候我真的好开心，你好细心，其实当你说要给我买生日礼物的时候我就多少有点猜到你多半会买一把刀，但是没有想到你会买一个油壶，但是我又注意到你不是很喜欢油腻的食物，所以我那段时间也在尽量的想我应该做些什么不油腻又好吃的菜给你；最开心的是游戏结束后，他们说要走了，你说你留下来帮我洗碗，我还直男的赶你走，我因此懊恼了很久；下楼后我以为你也会马上走，结果你没有你说一起走一走，你不知道我有多开心，然后你还存了我的手机号码，那一天我真的好开心。</p><p>​    你第二次过来找我，是我最最最开心的了，你还给我买了小发糕，还和你一起做饭，饭后逛小区，在牵你手的那一刻我真的好开心你没有拒绝，感觉和你的亲密程度一下子拉近了好多。在看可娄的时候，你说的那句要吃鸭鸭，我是真的好喜欢，然后送出了我人生中的第一捧花，和第一次那么拥抱一个女孩，你真的好体贴，下楼等车的时候，有点冷你主动靠近我，帮我遮挡寒冷，那时候我冰冷很多年的心一瞬间熊熊燃烧了起来。但是现在想想我好后悔，如果我当时跟你告白是不是现在结局不一样了呢，真的很讨厌犹犹豫豫畏畏缩缩的自己。</p><p>​    然后接下来的接二连三的不愉快让我搓手不及，之前两次都是说的我周末去找你的，但是我没有明白你意思，你用你来找我换我用不找你，周末和他们去吃烧烤你没有来，我好失落，而且你也不让我去找你，这其实算是第一次和第二次不愉快的导火索，所以我总想着要去找你一次，才能对得起你大老远舟车劳顿过来找我，可能我有点大男子主义吧，我觉得我应该是主动去找你的那个人，因为感觉上是一直你在为我付出，我想我一定要比你付出的更多才对。然后第二次你又是用你来找我换我不用去找你，但是我还是没有明白你用意，所以又头铁了一把惹得你不开心。也是因为这个我没有坚定把车票退掉留下来和你一起过五一的原因，可能是我内心深处的一点点可笑的自尊和骄傲吧。然后我感觉五一回去后，感觉我们之间的距离一下就远了好多，这种反差让我很难受，所以怄气的我导致第三次不愉快。</p><p>​    其实在最后一次见面前的那次不愉快后，你说和我相处很累，我知道问题已经很严重了，那一次我感觉我仿佛真的要失去你了，晚上的时候我发了很多信息给你，那些信息是我哭着抱着恐惧的心理写下来的，我知道我有一些问题，那几天花得最多的时间是到知乎上去学习该怎么和女孩子相处，相处应该避免哪些，还买了几本书，准备好好学习学习，但是还没来得及……，你就放弃我了。我真的很气，为什么在我遇到你的时候，从来没有这么忙的工作，突然一下子特别忙，如果不是第一次自己头铁惹你生气，是不是不会有后面的几次不愉快，我多半也会毫不犹豫的把回家的票退掉留下来和你一起过五一，也不会出现最后一次的不愉快。一直在想要是多给我一点时间该多好。</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    我知道我们性格不是很合，但是我会尽我最大可能改变自己，之前我们的每一次的不愉快，我都有用心努力的记下来然后调整我自己，一点一点的去让我能和你相处得更好，我知道在和你相处得时候很多时候，表现的没有主见，但我也不是真的没有主见，只是对在意的人什么都可以接受，什么都可以
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>斐波那契</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/排序/斐波那契/</id>
    <published>2020-05-24T16:00:00.000Z</published>
    <updated>2020-05-26T05:46:49.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>比较两个相邻的元素，将值大或者小的的元素交换到一边。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>每进行一趟排序，下一趟排序就会少比较一次。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>若数据是顺序的，只需一趟即可完成排序，所需比较次数<code>C</code>和记录移动次数均<code>M</code>达到最小值，即<code>C = n -1；M = 0</code> ，所以冒泡排序的最好的时间复杂度为<code>O(n)</code></p><p>若数据是反序，则需要进行<code>n - 1</code>躺排序，且每趟排序需要<code>n - i</code>此比较（<code>0 &lt;  i &lt; n</code>）,且每次比较必须移动记录三次来达到交换记录位置，这时比较和移动次数均达到最大值，该种情况下冒泡排序得时间复杂度为<code>O(n^2)</code></p><p>综上所述冒泡排序得平均<strong>时间复杂度</strong>：<code>O(n^2)</code></p><p><strong>空间复杂度</strong>：<code>O(1)</code></p><p><strong>稳定性</strong>：<strong>稳定</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bubblerSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; arr.length &amp;&amp; flag; i++)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length - i; j &gt; i ; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j - <span class="number">1</span>] &gt; arr[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;比较两个相邻的元素，将值大或者小的的元素交换到一边。&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;header
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="算法，排序" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
