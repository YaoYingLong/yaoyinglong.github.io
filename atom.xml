<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YingLong</title>
  
  <subtitle>虽奔放不羁，但也自我束缚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoyinglong.github.io/"/>
  <updated>2020-08-25T08:44:58.102Z</updated>
  <id>https://yaoyinglong.github.io/</id>
  
  <author>
    <name>YaoYingLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式概览</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/设计模式概览/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-08-25T08:44:58.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p><code>23</code>种设计模式大体上可以分为三类：</p><ul><li><strong>创建型模式</strong>（<code>5</code>个）：对象实例化的模式，用于<strong>解耦对象的实例化过程</strong>；</li><li><strong>结构型模式</strong>（<code>7</code>个）：把类或对象结合在一起<strong>形成一个更大的结构</strong>；</li><li><strong>行为型模式</strong>（<code>11</code>个）：类和对象<strong>如何交互</strong>，及<strong>划分职责和算法</strong>；</li></ul><p><img src="../../../../images/设计模式/设计模式分类.png" alt="设计模式分类"></p><h3 id="各种模式的关键点"><a href="#各种模式的关键点" class="headerlink" title="各种模式的关键点"></a>各种模式的关键点</h3><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><p><strong>单例模式</strong>：某个类只能有一个实例，提供一个全局的访问点。</p><p><strong>简单工厂</strong>：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</p><p><strong>工厂方法</strong>：定义一个创建对象的接口，让子类决定实例化那个类。</p><p><strong>抽象工厂</strong>：创建相关或依赖对象的家族，而无需明确指定具体类。</p><p><strong>建造者模式</strong>：封装一个复杂对象的构建过程，并可以按步骤构造。</p><p><strong>原型模式</strong>：通过复制现有的实例来创建新的实例。</p><h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><p><strong>适配器模式</strong>：将一个类的方法接口转换成客户希望的另外一个接口。</p><p><strong>组合模式</strong>：将对象组合成树形结构以表示“”部分-整体“”的层次结构。</p><p><strong>装饰模式</strong>：动态的给对象添加新的功能。</p><p><strong>代理模式</strong>：为其他对象提供一个代理以便控制这个对象的访问。</p><p><strong>亨元模式</strong>：通过共享技术来有效的支持大量细粒度的对象。</p><p><strong>外观模式</strong>：对外提供一个统一的方法，来访问子系统中的一群接口。</p><p><strong>桥接模式</strong>：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</p><h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><p><strong>模板模式</strong>：定义一个算法结构，而将一些步骤延迟到子类实现。</p><p><strong>解释器模式</strong>：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</p><p><strong>策略模式</strong>：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</p><p><strong>状态模式</strong>：允许一个对象在其对象内部状态改变时改变它的行为。</p><p><strong>观察者模式</strong>：对象间的一对多的依赖关系。</p><p><strong>备忘录模式</strong>：在不破坏封装的前提下，保持对象的内部状态。</p><p><strong>中介者模式</strong>：用一个中介对象来封装一系列的对象交互。</p><p><strong>命令模式</strong>：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</p><p><strong>访问者模式</strong>：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</p><p><strong>责任链模式</strong>：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</p><p><strong>迭代器模式</strong>：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</p><h3 id="23种设计模式间的关系"><a href="#23种设计模式间的关系" class="headerlink" title="23种设计模式间的关系"></a>23种设计模式间的关系</h3><p><img src="../../../../images/设计模式/23种设计模式关系图.png" alt="23种设计模式关系图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设计模式分类&quot;&gt;&lt;a href=&quot;#设计模式分类&quot; class=&quot;headerlink&quot; title=&quot;设计模式分类&quot;&gt;&lt;/a&gt;设计模式分类&lt;/h3&gt;&lt;p&gt;&lt;code&gt;23&lt;/code&gt;种设计模式大体上可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/MySQL基础/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-08-25T09:25:46.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务基本特征ACID"><a href="#事务基本特征ACID" class="headerlink" title="事务基本特征ACID"></a>事务基本特征ACID</h3><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事务基本特征ACID&quot;&gt;&lt;a href=&quot;#事务基本特征ACID&quot; class=&quot;headerlink&quot; title=&quot;事务基本特征ACID&quot;&gt;&lt;/a&gt;事务基本特征ACID&lt;/h3&gt;&lt;h3 id=&quot;四种隔离级别&quot;&gt;&lt;a href=&quot;#四种隔离级别&quot; class=&quot;
      
    
    </summary>
    
      <category term="DB" scheme="https://yaoyinglong.github.io/categories/DB/"/>
    
    
      <category term="MySQL" scheme="https://yaoyinglong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JVM整体概览</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/JVM%E6%95%B4%E4%BD%93%E6%A6%82%E8%A7%88/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/JVM整体概览/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-08-25T10:18:18.327Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../images/JVM/JVM整体概览.png" alt="JVM整体概览"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../../../images/JVM/JVM整体概览.png&quot; alt=&quot;JVM整体概览&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://yaoyinglong.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring知识点</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/Spring/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/Spring/Spring知识点/</id>
    <published>2020-08-23T16:00:00.000Z</published>
    <updated>2020-08-24T12:54:23.929Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../images/Spring/Spring知识点概览.png" alt="Spring知识点概览"></p><p><img src="../../../../images/Spring/Spring知识点详情.png" alt="Spring知识点详情"></p><p><img src="../../../../images/Spring/Spring生命周期.png" alt="Spring生命周期"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../../../images/Spring/Spring知识点概览.png&quot; alt=&quot;Spring知识点概览&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../images/Spring/Spring知识点详情.png&quot; alt=&quot;
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>IoC容器</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/Spring/IoC%E5%AE%B9%E5%99%A8/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/Spring/IoC容器/</id>
    <published>2020-08-15T16:00:00.000Z</published>
    <updated>2020-08-18T14:02:41.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IoC容器概述"><a href="#IoC容器概述" class="headerlink" title="IoC容器概述"></a>IoC容器概述</h3><p><strong>依赖反转</strong>的概念：<strong>依赖对象的获得被反转了</strong>，基于该结论为控制反转创造了一个更好听的名字：<strong>依赖注入</strong>。依赖控制反转的实现方式有很多种，<code>Spring</code>中<code>IoC</code>容器是实现该模式的载体，它可以在<strong>对象生成</strong>或<strong>初始化</strong>时<strong>直接将数据注入到对象中</strong>，也可以通过将<strong>对象引用注入到对象数据域中</strong>的方式来注入对方法调用的依赖。这种<strong>依赖注入是可以递归的，对象被逐层注入</strong>。</p><p>应用控制反转后，当对象被创建时，由<strong>一个调用系统内的所有对象的外界实体将其所依赖的对象的引用传递给它</strong>，控制反转是关于<strong>一个对象如何获取它所依赖的对象的引用</strong>，<strong>反转指的是责任的反转</strong>。</p><p>通过使用<code>IoC</code>容器，对象的<strong>依赖关系的管理被反转了</strong>或者说是把<strong>资源的获取方式反转了</strong>，对象之间的相互依赖关系由<code>IoC</code>容器进行管理，并由<code>IoC</code>容器完成对象的注入。注入的主要实现方式有：<strong>接口注入</strong>、<strong><code>setter</code>注入</strong>、<strong>构造器注入</strong>。<code>Spring</code>中<code>setter</code>注入和构造器注入是主要的注入方式，使用<code>Spring</code>时<code>setter</code>注入是常见的注入方式。且<code>Spring</code>还提<strong>供了对特定依赖的检查</strong>。</p><p><code>Spring IoC</code>提供了一个基本的<code>JavaBean</code>容器，通过<code>IoC</code>容器管理依赖关系，并通过依赖注入和<code>AOP</code>切面增强了为<code>JavaBean</code>这样的<code>POJO</code>对象赋予事务管理、生命周期管理等基本功能。</p><h3 id="IoC容器的设计与实现"><a href="#IoC容器的设计与实现" class="headerlink" title="IoC容器的设计与实现"></a>IoC容器的设计与实现</h3><p><code>Spring IoC</code>容器的设计中，实现了<code>BeanFactory</code>接口的<strong>简单容器系列</strong>，该系列容器只实现了容器的<strong>最基本的功能</strong>；和<strong>容器的高级形态<code>ApplicationContext</code>应用上下文</strong>，两个主要的容器系列。<code>BeanFactory</code>是<code>IoC</code>容器具体实现的<strong>基本功能规范的设计表现</strong>。</p><p>对于使用者来说，可将<code>BeanFactory</code>和<code>ApplicationContext</code>看成容器的具体表现形式。通常所说的IoC容器实际上代表的是一系列功能各异的容器产品。Spring中有各种各样的<code>IoC</code>容器的实现。</p><p>在Spring提供的基本的<code>IoC</code>容器的接口定义和实现的基础上，Spring通过定义<code>BeanDefinition</code>来管理基本的Spring的应用中的<strong>各种对象以及它们之间的相互依赖关系</strong>。<strong><code>BeanDefinition</code>抽象了对Bean的定义</strong>，<strong>是让容器起作用的主要数据类型</strong>。对于<code>IoC</code>容器来说，<code>BeanDefinition</code>就是对<strong>依赖反转模式</strong>中管理的<strong>对象依赖关系的数据抽象</strong>，也是容器<strong>实现依赖反转功能的核心数据结构</strong>，<strong>依赖反转功能都是围绕对<code>BeanDefinition</code>的处理来完成</strong>的。</p><p><img src="../../../../../images/Spring/IoC容器接口设计图.png" alt="IoC容器接口设计图"></p><p><code>BeanFactory</code>接口定义了基本的<code>IoC</code>容器规范，从接口<code>BeanFactory</code>到<code>HierarchicalBeanFactory</code>再到<code>ConfigurableBeanFactory</code>是一条<strong>主要</strong>的<code>BeanFactory</code>设计路径。<code>HierarchicalBeanFactory</code>接口增加了<code>getParentBeanFactory()</code>的接口功能，使<code>BeanFactory</code>具备了<strong>双亲<code>IoC</code>容器的管理功能</strong>。<code>ConfigurableBeanFactory</code>接口主要定义了一些对<code>BeanFactory</code>的<strong>配置功能</strong>。可<strong>设置双亲<code>IoC</code>容器</strong>，<strong>配置<code>Bean</code>后置处理器</strong>等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;IoC容器概述&quot;&gt;&lt;a href=&quot;#IoC容器概述&quot; class=&quot;headerlink&quot; title=&quot;IoC容器概述&quot;&gt;&lt;/a&gt;IoC容器概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;依赖反转&lt;/strong&gt;的概念：&lt;strong&gt;依赖对象的获得被反转了&lt;/stro
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
      <category term="IoC" scheme="https://yaoyinglong.github.io/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>Spring整体架构</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/Spring/Spring整体架构/</id>
    <published>2020-08-11T16:00:00.000Z</published>
    <updated>2020-08-13T14:12:06.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring子项目"><a href="#Spring子项目" class="headerlink" title="Spring子项目"></a>Spring子项目</h3><h4 id="Spring-Framework（core）"><a href="#Spring-Framework（core）" class="headerlink" title="Spring Framework（core）"></a>Spring Framework（core）</h4><p>包含一系列<code>Ioc</code>容器的设计，提供了<strong>依赖反转</strong>的实现，集成了<code>AOP</code>，还包含了<code>MVC</code>、<code>JDBC</code>、<strong>事务处理</strong>模块的实现。</p><h4 id="Spring-Web-Flow"><a href="#Spring-Web-Flow" class="headerlink" title="Spring Web Flow"></a>Spring Web Flow</h4><p><strong>定义了一种特定的语言来描述工作流</strong>，同时高级的工作流控制引擎可以管理会话状态，支持<code>AJAX</code>来构建丰富的客户端体验，并提供<code>JSF</code>支持。其实际上是构建在<code>Spring MVC</code>的基础上的，相对于<code>Spring Framework（core）</code>独立发展的。</p><h4 id="Spring-BlazeDS-Integration"><a href="#Spring-BlazeDS-Integration" class="headerlink" title="Spring BlazeDS Integration"></a>Spring BlazeDS Integration</h4><p>提供<code>Spring</code>于<code>Adobe Flex</code>技术集成的模块。</p><h4 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h4><p>基于<code>Spring</code>的<strong>认证</strong>和<strong>安全工具</strong>。</p><h4 id="Spring-Security-OAuth"><a href="#Spring-Security-OAuth" class="headerlink" title="Spring Security OAuth"></a>Spring Security OAuth</h4><p>为OAuth在Spring上集成提供支持，OAuth是一个第三方模块，提供一个开放协议的实现，通过改协议，前端桌面应用可以对Web应用进行简单而标准的安全调用。</p><h4 id="Spring-Dynamic-Modules"><a href="#Spring-Dynamic-Modules" class="headerlink" title="Spring Dynamic Modules"></a>Spring Dynamic Modules</h4><p>可以让Spring运行在OSGi平台上。</p><h4 id="Spring-Batch"><a href="#Spring-Batch" class="headerlink" title="Spring Batch"></a>Spring Batch</h4><p>提供构建<strong>批处理应用</strong>和<strong>自动化操作</strong>的框架。</p><h4 id="Spring-Integration"><a href="#Spring-Integration" class="headerlink" title="Spring Integration"></a>Spring Integration</h4><p>为企业数据集成提供了各种适配器，通过这些适配器来转换各种消息格式，并帮助Spring应用完成与企业应用系统的集成。</p><h4 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h4><p>为Spring应用更好地使用基于AMQP（高级消息队列协议）的消息服务而开发。</p><h4 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h4><p>为Spring应用提供使用费关系型数据的能力。</p><h3 id="Spring设计目标"><a href="#Spring设计目标" class="headerlink" title="Spring设计目标"></a>Spring设计目标</h3><p>​    为开发者提供的是一个<strong>一站式的轻量级应用开发框架</strong>。其抽象了许多应用开发中遇到的共性问题。支持<code>POJO</code>和使用<code>JavaBean</code>的开发方式，使应用<strong>面向接口开发</strong>，充分支持<code>OO</code>（面向对象）的设计方法，使<strong>开发的入门</strong>、<strong>测试</strong>、<strong>应用部署都得到简化</strong>。</p><p>​    通过使用<code>Spring</code>的<code>IoC</code>容器，可以对应用开发中复杂的对象耦合关系实现一个<strong>文本化</strong>、<strong>外部化</strong>的工作，即通过一个或几个<code>XML</code>文件，可以方便地对应用的耦合关系进行浏览、修改和维护，很大程度上简化应用开发。通过<code>Ioc</code>容器实现的依赖反转，把<strong>依赖关系的管理从<code>Java</code>对象中解放出来</strong>，交给IoC容器来完成，从而完成了对象之间的解耦，将原来的<strong>对象—对象</strong>的关系，转化为<strong>对象—IoC容器—对象</strong>的关系。</p><p>​    Spring即作为用户和机器之间的平台，同时也为用户使用底层的机器资源提供了应用开发环境。Spring关系的是一些企业应用资源的使用，如数据持久化、数据集成、事务管理、消息中间件、Web2.0应用、分布式计算等对高效可靠处理企业数据方法的技术抽象。</p><p>​    Spring一方面通过IoC容器来管理POJO对象，以及它们相互之间的耦合关系，使企业的信息、数据、资源可以用简单得Java语言来抽象和描述；另一方面可通过AOP以动态和非侵入式的方式来增强服务的功能。</p><p>​    IoC容器和AOP模块是平台实现的核心，代表了最为基础的底层抽象，同时也是Spring其他模块实现的基础。</p><h3 id="Spring整体架构"><a href="#Spring整体架构" class="headerlink" title="Spring整体架构"></a>Spring整体架构</h3><h4 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h4><p>​    包含了最基本的<code>IoC</code>容器<code>BeanFactory</code>接口的实现，也提供了一系列这个接口的实现。如：<code>XmlBeanFactory</code>、<code>SimpleJndiBeanFactory</code>、<code>StaticListableBeanFactory</code>等，为了让应用更方便得使用<code>IoC</code>容器，还在<code>IoC</code>容器的外围提供如<code>Resource</code>访问资源的抽象和定位等支持。<code>Spring</code>还设计了<code>IoC</code>容器的高级形态<code>ApplicationContext</code>应用上下文提供用户使用。</p><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>​    Spring核心模块，围绕AOP增强功能，Spring集成了AspectJ作为AOP的一个特定实现，还在JVM动态代理/CGLIB的基础上实现了一个AOP框架。</p><h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><p>​    以DispatcherServlet为核心的模块，实现了MVC模式，包括怎样与Web容器环境集成、Web请求的拦截、分发、处理、和ModelAndView数据的返回，以及如何集成各种UI视图展现和数据表现。</p><h4 id="Spring-JDBC-ORM"><a href="#Spring-JDBC-ORM" class="headerlink" title="Spring JDBC/ORM"></a>Spring JDBC/ORM</h4><p>​    Spring JDBC包提供了JdbcTemplate作为模板类，封装了基本的数据库操作方法，如数据查询、更新等。</p><p>​    Spring还提供许多对ORM工具的封装。如Hibernate、iBatis等。可以把对这些工具的使用和Spring声明式事务处理结合起来。同时Spring还提供许多模板对象，如HibernateTemplate来实现对Hibernate的驱动。</p><h4 id="Spring事务处理"><a href="#Spring事务处理" class="headerlink" title="Spring事务处理"></a>Spring事务处理</h4><p>​    Spring事务处理是一个通过Spring AOP实现的自身功能增强的典型模块。通过AOP增强实现了声明式事务处理的功能，使应用只需要在IoC容器中对事务属性进行配置即可完成，同时这些事务处理的基本过程和具体的事务处理器实现是无关的，应用可以选择不同的具体的事务处理机制，使用了声明式事务处理，这些具体的事务处理机制会被纳入Spring事务处理的统一框架中完成，并完成与具体业务代码的解耦。</p><h4 id="Spring远端调用"><a href="#Spring远端调用" class="headerlink" title="Spring远端调用"></a>Spring远端调用</h4><p>​    通过Spring的封装，为应用屏蔽了各种通信和调用细节的实现，通过这一层的封装，使应用可以通过选择各种不同的远端调用来实现。如HTTP调用器、第三方二进制同学实现Hessian/Burlap、RMI调用。</p><h3 id="Spring应用场景"><a href="#Spring应用场景" class="headerlink" title="Spring应用场景"></a>Spring应用场景</h3><p>​    在Spring这个一站式应用平台或框架中，其中各个模块除了依赖IoC容器和AOP之外，相互之间没有很强的耦合性；Spring最重目标是简化应用开发的编程模型。其所提供的服务可贯穿应用道整个软件中，从最上层Web UI道底层数据操作，道其他企业信息数据集成，再到各种J2EE服务的使用。</p><p>​    可把Spring作为一个整体使用，也可以把Spring各个模块拿出来单独使用，因其本身是非常模块化的。Spring的价值：</p><ul><li>非侵入性框架，其目标是使应用程序代码对框架的依赖最小化。</li><li>提供了一个一致的编程模型，使应用直接使用POJO开发，从而可以与运行环境隔离开。</li><li>推动应用的设计风格向面向对象及面向接口编程转变，提高代码的重用性和可测性。</li><li>改进了体系结构的选择，Spring可以帮助我们选择不同的技术实现。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring子项目&quot;&gt;&lt;a href=&quot;#Spring子项目&quot; class=&quot;headerlink&quot; title=&quot;Spring子项目&quot;&gt;&lt;/a&gt;Spring子项目&lt;/h3&gt;&lt;h4 id=&quot;Spring-Framework（core）&quot;&gt;&lt;a href=&quot;#Spr
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>时间&amp;空间复杂</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/时间&amp;空间复杂/</id>
    <published>2020-07-31T16:00:00.000Z</published>
    <updated>2020-08-01T11:15:13.083Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>常见的时间复杂度：</p><ul><li><p><code>O(1)</code>：常数复杂度</p></li><li><p><code>O(log n)</code>：对数复杂度</p></li><li><p><code>O(n)</code>：线性时间复杂度</p></li><li><p><code>O(n^2)</code>：平方</p></li><li><p><code>O(n^3)</code>：立方</p></li><li><p><code>O(2^n)</code>：指数</p></li><li><p><code>O(n!)</code>：阶乘</p></li></ul><p><img src="E:\Blog\source\images\算法\时间复杂度曲线.png" alt></p><h5 id="O-log-n"><a href="#O-log-n" class="headerlink" title="O(log n)"></a>O(log n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="O-log-n-1"><a href="#O-log-n-1" class="headerlink" title="O(log n)"></a>O(log n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i *= <span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="O-k-n"><a href="#O-k-n" class="headerlink" title="O(k^n)"></a>O(k^n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n -<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="O-n"><a href="#O-n" class="headerlink" title="O(n!)"></a>O(n!)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h3&gt;&lt;p&gt;常见的时间复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt;：常数复杂度&lt;/p&gt;
&lt;/li
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/二叉搜索树/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2020-08-27T03:35:30.098Z</updated>
    
    <content type="html"><![CDATA[<p><strong>左子树</strong>上所有节点的值<strong>均小于根节点</strong>的值，而<strong>右子树</strong>上所有结点的值<strong>均大于根节点</strong>的值。故二叉搜索树中序遍历是单调递增的。</p><p><strong>插入的序列越接近有序，生成的二叉搜索树就越像一个链表</strong>，为了避免二叉搜索树变成链表，故引入了<strong>平衡二叉树</strong>，即让树的结构看起来尽量均匀，左右子树的节点数尽量一样多。</p><p>生成平衡二叉树时，先按照生成二叉搜索树的方法构造二叉树，再根据插入的导致二叉树不平衡的节点位置进行调整，有<strong><code>LL</code>左旋</strong>、<strong><code>RR</code>右旋</strong>、<strong><code>LR</code>先左旋后右旋</strong>、<strong><code>RL</code>先右旋后左旋</strong>四种调整方式。</p><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer min;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> left = isValidBST(root.left);</span><br><span class="line">    <span class="keyword">if</span> (!left || min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    min = root.val;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBSTDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    Integer min = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.add(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; node.val &lt;= min) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        min = node.val;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树插入"><a href="#二叉搜索树插入" class="headerlink" title="二叉搜索树插入"></a>二叉搜索树插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">        root.right = insertIntoBST701(root.right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.left = insertIntoBST701(root.left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul><li>若<code>key &gt; root.val</code>，说明要删除的节点在右子树，<code>root.right = deleteNode(root.right, key)</code>。</li><li>若<code>key &lt; root.val</code>，说明要删除的节点在左子树，<code>root.left = deleteNode(root.left, key)</code>。</li><li>若<code>key == root.val</code>，则该节点就是我们要删除的节点，则：<ul><li>若该节点是叶子节点，直接删除：<code>root = null</code>。</li><li>若该节点不是叶子节点且有右节点，则用其<strong>后继节点</strong>值替代<code>root.val = successor.val</code>，然后删除后继节点。</li><li>若该节点不是叶子节点且只有左节点，则用它的<strong>前驱节点</strong>值替代<code>root.val = predecessor.val</code>，然后删除前驱节点。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &gt; root.val) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root.val) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.val = successor(root);</span><br><span class="line">            root.right = deleteNode(root.right, root.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.val = predecessor(root);</span><br><span class="line">            root.left = deleteNode(root.left, root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后继节点</strong>，中序遍历序列的<strong>下一个节点</strong>。即<strong>比当前节点大的最小节点</strong>，先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前驱节点</strong>，中序遍历序列的<strong>前一个节点</strong>。即<strong>比当前节点小的最大节点</strong>，先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将树转换成链表"><a href="#将树转换成链表" class="headerlink" title="将树转换成链表"></a>将树转换成链表</h3><p><code>cursor</code>只是做一个引用传递，不断的将节点的<code>right</code>节点更新，然后将当前游标置为新节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode cursor;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    cursor = ans;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> ans.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">    node.left = <span class="keyword">null</span>;</span><br><span class="line">    cursor.right = node;</span><br><span class="line">    cursor = node;</span><br><span class="line">    inorder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树降序遍历"><a href="#二叉搜索树降序遍历" class="headerlink" title="二叉搜索树降序遍历"></a>二叉搜索树降序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    convertBST(root.right);</span><br><span class="line">    System.out.println(root);</span><br><span class="line">    convertBST(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证 p.val &lt; q.val</span></span><br><span class="line">    <span class="keyword">if</span> (p.val &gt; q.val) &#123;</span><br><span class="line">        TreeNode tmp = p;</span><br><span class="line">        p = q;</span><br><span class="line">        q = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// p,q 都在 root 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val) &#123;</span><br><span class="line">            <span class="comment">// 遍历至右子节点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">            <span class="comment">// p,q 都在 root 的左子树中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="comment">// 遍历至左子节点</span></span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; R) &#123;</span><br><span class="line">        <span class="keyword">return</span> trimBST(root.left, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; L) &#123;</span><br><span class="line">        <span class="keyword">return</span> trimBST(root.right, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    root.left = trimBST(root.left, L, R);</span><br><span class="line">    root.right = trimBST(root.right, L, R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序结果构建树"><a href="#前序结果构建树" class="headerlink" title="前序结果构建树"></a>前序结果构建树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> generateTree(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">generateTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == preorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rootVal = preorder[index];</span><br><span class="line">    <span class="keyword">if</span> (rootVal &gt; upper || rootVal &lt; lower) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    root.left = generateTree(preorder, lower, rootVal);</span><br><span class="line">    root.right = generateTree(preorder, rootVal, upper);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序结果构建树"><a href="#后序结果构建树" class="headerlink" title="后序结果构建树"></a>后序结果构建树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (postorder == <span class="keyword">null</span> || postorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> generateTree(postorder, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">generateTree</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == postorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rootVal = postorder[index];</span><br><span class="line">    <span class="keyword">if</span> (rootVal &gt; upper || rootVal &lt; lower) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    root.right = generateTree(postorder, rootVal, upper);</span><br><span class="line">    root.left = generateTree(postorder, lower, rootVal);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;左子树&lt;/strong&gt;上所有节点的值&lt;strong&gt;均小于根节点&lt;/strong&gt;的值，而&lt;strong&gt;右子树&lt;/strong&gt;上所有结点的值&lt;strong&gt;均大于根节点&lt;/strong&gt;的值。故二叉搜索树中序遍历是单调递增的。&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://yaoyinglong.github.io/tags/%E6%A0%91/"/>
    
      <category term="AVL" scheme="https://yaoyinglong.github.io/tags/AVL/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/平衡二叉树/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2020-08-04T10:51:40.242Z</updated>
    
    <content type="html"><![CDATA[<p>平衡二叉树是一种特殊的<strong>二叉排序树</strong>，<strong>每个</strong>节点<strong>左子树</strong>和<strong>右子树</strong>高度差<strong>至多等于<code>1</code></strong>。</p><p>将二叉树上节点<strong>左子树深度</strong>减去<strong>右子树深度</strong>的值称为<strong>平衡因子<code>BF</code></strong>，平衡二叉树上<strong>所有节点的平衡因子</strong>只可能是<strong>1，-1，0</strong>。</p><p>距离<strong>插入节点最近</strong>且<strong>平衡因子绝对值大于1</strong>的节点<strong>为根的子树</strong>，称为<strong>最小不平衡子树</strong>。</p><p>构建平衡二叉树时，每插入一个节点时，<strong>先检查是否因插入而破坏树的平衡性</strong>，若是则<strong>找出最小不平衡树</strong>，在<strong>保持二叉排序树特性的前提下</strong>，调整最小不平衡子树中各个节点之间的链接关系，<strong>进行相应的旋转</strong>，使之成为新的平衡子树。</p><ul><li><strong>右旋</strong>：最小不平衡子树的BF和它的子树BF符号相同且最小不平衡子树的BF大于0</li><li><strong>左旋</strong>：最小不平衡子树的BF和它的子树BF符号相同且最小不平衡子树的BF小于零</li><li><strong>左右旋</strong>：最小不平衡子树的BF与它的子树的BF符号相反时且最小不平衡子树的BF大于0时，需要对节点先进行一次向左旋使得符号相同后，在向右旋转一次完成平衡操作。</li><li><strong>右左旋</strong>：最小不平衡子树的BF与它的子树的BF符号相反时且最小不平衡子树的BF小于0时，需要对节点先进行一次向右旋转使得符号相同时，在向左旋转一次完成平衡操作。</li></ul><h3 id="有序数组转换成AVL"><a href="#有序数组转换成AVL" class="headerlink" title="有序数组转换成AVL"></a>有序数组转换成<code>AVL</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toBstTraversalLeft(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">toBstTraversalLeft</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = toBstTraversalLeft(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = toBstTraversalLeft(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总是选择中间位置右边的数字作为根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">toBstTraversalRight</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = toBstTraversalRight(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = toBstTraversalRight(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择任意一个中间位置数字作为根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">toBstTraversalRandom</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right + <span class="keyword">new</span> Random().nextInt(<span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = toBstTraversalRandom(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = toBstTraversalRandom(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树判定"><a href="#平衡二叉树判定" class="headerlink" title="平衡二叉树判定"></a>平衡二叉树判定</h3><p>对二叉树做<strong>后序遍历</strong>，从底至顶返回子树深度，若判定某子树不是平衡树则 直接向上返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recur(treeNode) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftDepth = recur(treeNode.leftNode);</span><br><span class="line">    <span class="keyword">if</span> (leftDepth == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rightDepth = recur(treeNode.rightNode);</span><br><span class="line">    <span class="keyword">if</span> (rightDepth == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(leftDepth - rightDepth) &lt; <span class="number">2</span> ? Math.max(leftDepth, rightDepth) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平衡二叉树是一种特殊的&lt;strong&gt;二叉排序树&lt;/strong&gt;，&lt;strong&gt;每个&lt;/strong&gt;节点&lt;strong&gt;左子树&lt;/strong&gt;和&lt;strong&gt;右子树&lt;/strong&gt;高度差&lt;strong&gt;至多等于&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;。&lt;/
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://yaoyinglong.github.io/tags/%E6%A0%91/"/>
    
      <category term="AVL" scheme="https://yaoyinglong.github.io/tags/AVL/"/>
    
  </entry>
  
  <entry>
    <title>面试准备大纲</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/%E5%A4%A7%E7%BA%B2/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/大纲/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2020-08-01T05:17:24.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul><li><code>AOP</code></li><li><code>IOC</code></li><li>源码</li><li><code>SpringBoot</code></li><li><code>SpringCloud</code></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>常见面试笔试内容</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>树（前序遍历、中序遍历、后序遍历、层序遍历）<ul><li>二叉搜索树</li><li>平衡二叉树（AVL树）</li><li>红黑树</li></ul></li><li>图（广度优先遍历BFS、深度优先遍历DFS）</li><li><code>leetcode</code>题（<strong>前期每周5道，中期每周10道，后期每周15道</strong>）</li><li>常见排序总结</li><li>复杂度分析：了解常见时间复杂度，建立复杂度和数据规模之间的概念，理解均摊复杂度分析</li><li>数组<ul><li>双索引技术</li><li>对撞指针—浮动窗口</li></ul></li><li>查找表<ul><li>map</li><li>set</li><li>unordered_map</li><li>unordered_set</li></ul></li><li>链表<ul><li>虚拟头结点</li><li>双指针</li></ul></li><li>栈<ul><li>非递归算法</li><li>深入系统栈，模拟系统递归调用</li></ul></li><li>队列<ul><li>广度优先遍历</li></ul></li><li>回溯<ul><li>回溯算法</li><li>排序问题-组合问题</li><li>Floodfill</li></ul></li><li>动态规划<ul><li>记忆化搜索</li><li>重叠子问题和问题的无后效性</li><li>背包问题</li><li>LIS，LCS问题分析</li></ul></li><li>贪心算法：避过陷阱</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>6大基本原则（<strong>一周</strong>）</li><li>23种设计模式（<strong>一周5个</strong>）</li><li>设计模式对比</li></ul><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ul><li><code>JVM</code></li><li>源码</li><li>多线程</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul><li><code>RabbitMQ</code></li><li>常见面试笔试内容</li></ul><h3 id="Reids"><a href="#Reids" class="headerlink" title="Reids"></a>Reids</h3><ul><li>常见面试笔试内容</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>常用命令</li></ul><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><ul><li>常见面试笔试内容</li></ul><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><ul><li>常见面试笔试内容</li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AOP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IOC&lt;/code&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>SOLID基本原则</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/SOLID%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/SOLID基本原则/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2020-08-25T07:54:00.219Z</updated>
    
    <content type="html"><![CDATA[<p>6大设计基本原则：<strong>单一职责原则</strong>、<strong>里氏替换原则</strong>、<strong>依赖倒置原则</strong>、<strong>接口隔离原则</strong>、<strong>迪米特法则</strong>、<strong>开闭原则</strong></p><h3 id="单一职责原则SRP"><a href="#单一职责原则SRP" class="headerlink" title="单一职责原则SRP"></a>单一职责原则SRP</h3><p>​    单一职责原则提出了一个编写程序的标准，用<strong>职责</strong>或<strong>变化原因</strong>来衡量接口或类设计得是否优良，但职责和变化原因都是不可度量得，因项目和环境而异。单一职责适用于<strong>接口、类、方法</strong>。</p><p><strong>定义</strong>：应该<strong>有且仅有一个原因引起类的变更</strong>。</p><p><strong>优点</strong>：<strong>类复杂性降低</strong>，实现<strong>职责清晰明确</strong>；<strong>可读性高</strong>；<strong>可维护性高</strong>；<strong>变更引起的风险低</strong>；</p><h3 id="里氏替换原则LSP"><a href="#里氏替换原则LSP" class="headerlink" title="里氏替换原则LSP"></a>里氏替换原则LSP</h3><p><strong>定义</strong>：<strong>每一个类型为<code>S</code>的对象<code>s</code>，都有类型为<code>T</code>的对象<code>t</code>，使得以<code>T</code>定义的所有程序<code>P</code>在所有的对象<code>s</code>都代替成<code>t</code>时，程序<code>P</code>的行为无变化，则类型<code>S</code>是类型<code>T</code>的子类；所有引用基类的地方必须能透明的使用其子类的对象。</strong></p><ul><li><strong>子类必须完全实现父类的方法</strong>：若子类<strong>不能完全实现父类方法</strong>，或某些方法在子类种已<strong>发生畸变</strong>，建议断开父子继承关系。</li><li><strong>子类可以有自己的个性</strong>：子类出现的地方父类未必能出现</li><li><strong>覆盖或实现父类方法时输入参数可以被放大</strong></li><li><strong>覆写或实现父类的方法时输出结果可以被缩小</strong></li></ul><p>在类中调用其他类时<strong>务必使用父类或接口</strong>，否则即是违背<code>LSP</code>原则。</p><h3 id="依赖倒置原则DIP"><a href="#依赖倒置原则DIP" class="headerlink" title="依赖倒置原则DIP"></a>依赖倒置原则DIP</h3><p>​    采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。可以通过依赖倒置原则涉及的接口或抽象类对实现类进行约束，可减少需求变化引起的工作量剧增的情况，可让维护人员轻松地扩展和维护，<strong>是实现开闭原则的重要途径</strong>。TDD测试驱动开发模式就是依赖倒置原则的最高级应用。</p><p><strong>定义</strong>：<strong>高层模块不应该依赖底层模块两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象</strong>；</p><p>表现：模块间依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生；接口和抽象类不依赖于实现类；实现类依赖接口或抽象类；</p><p>依赖的三种写法：</p><ul><li>构造函数传递依赖对象，也叫构造函数注入</li><li>Setter方法传递依赖对象，也叫Setter依赖注入</li><li>接口声明依赖对象，也叫接口注入</li></ul><p>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。</p><ul><li>每个类尽量都有接口或抽象类，或抽象类和接口两者都具备</li><li>变量的表面类型尽量是接口或抽象类</li><li>任何类都不应该从具体类派生</li><li>尽量不要覆写基类的方法</li><li>结合里氏替换原则使用</li></ul><h3 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h3><p>定义：<strong>客户端不应该依赖它不需要的接口；类间的依赖关系应该建立在最小的接口上。建立单一的接口，不要建立臃肿庞大的接口</strong>；</p><ul><li>接口尽量小</li><li>接口要高内聚：提高接口、类、模块的处理能力，减少对外的交互</li><li>定制服务，单独为一个个体提供优良的服务</li><li>接口设计要有限度</li></ul><p><strong>根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</strong>接口和类尽量使用原子接口或原子类来组装。</p><ul><li>一个接口只服务玉一个子模块或业务</li><li>通过业务逻辑压缩接口中的public方法</li><li>已经被污染的接口，尽量去修改，若变更风险较大，则采用适配器模式进行转化处理</li><li>了解环境，拒绝盲从</li></ul><h3 id="迪米特法则LD"><a href="#迪米特法则LD" class="headerlink" title="迪米特法则LD"></a>迪米特法则LD</h3><p>也称<strong>最少知识原则</strong>：一个对象应该对其他对象有最少的了解，<strong>对需要耦合或调用的类知道越少越好</strong>。</p><ul><li><strong>只和朋友交流</strong>：类与类间的关系是<strong>建立在类之间而不是方法间</strong>，一个方法<strong>尽量不引入一个类中不存在的对象</strong></li><li>朋友间也是有距离的：<strong>尽量不对外公布太多<code>public</code>方法和非静态得<code>public</code>变量，尽量内敛</strong></li><li>是自己的就是自己的：若一个方法放在本类中，即<strong>不增加类间关系</strong>，也<strong>对本类不产生负面影响</strong>，那就放置在本类中。</li><li>谨慎使用<code>Serializable</code></li></ul><p>两个对象之间的耦合就成为朋友关系，朋友关系类型很多如组合、聚合、依赖等。</p><p><strong>注</strong>：朋友类的定义，出现在<strong>成员变量</strong>、<strong>方法输入输出参数</strong>中的类称为成员朋友类，出现在<strong>方法体内部的类不属于朋友类</strong>。</p><p>迪米尔法则要求类羞涩一点，<strong>尽量不对外公布太多<code>public</code>方法和非静态得<code>public</code>变量，尽量内敛</strong>，多使用<code>private</code>、<code>package-private</code>、<code>protected</code>等访问权限。类公开的<code>public</code>属性或方法越多，修改时涉及得面也就越大，变更引起得风险扩散也就越大。迪米特法则核心观念是类间解耦、弱耦合。</p><p>缺点：会产生大量中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。使用时请反复权衡，既做到让结构清晰，又做到高内聚底耦合。</p><h3 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h3><p>一个软件实体如类、模块和函数应该<strong>对扩展开放</strong>，<strong>对修改关闭</strong>。应该<strong>通过扩展来实现变化</strong>，<strong>而不是通过修改已有代码来实现变化</strong>。</p><p>开闭原则对扩展开放，对修改关闭，<strong>并不意味着不做任何修改</strong>，底层模块的变更，必然要有更高层模块进行耦合。</p><p>可把变化大致分为三类：</p><ul><li><strong>逻辑变化</strong>：可以通过修改原有类中的方法来完成，前提是所有依赖或者关联类都按照相同的逻辑处理。</li><li><strong>子模块变化</strong>：底层模块变化必然引起高层模块变化，因此<strong>通过扩展完成变化时，高层模块修改是必然的</strong>。</li><li>可见视图变化</li></ul><p>开闭原则是<strong>最基础</strong>的一个原则，<strong>前五个原则都是开闭原则的具体形态</strong>，前五个原则就是<strong>指导设计的工具和方法</strong>，而<strong>开闭原则才是精神领袖</strong>。</p><h5 id="开闭原则对测试的影响"><a href="#开闭原则对测试的影响" class="headerlink" title="开闭原则对测试的影响"></a>开闭原则对测试的影响</h5><p>在比较重要的方法，测试方法都会很多，可能测试逻辑都很复杂，若要通过修改修改一个方法或多个方法来完成变化，基本上测试用例都得重新写。所以需要通过扩展来实现业务逻辑而不是修改。</p><h5 id="开闭原则可以提高复用性"><a href="#开闭原则可以提高复用性" class="headerlink" title="开闭原则可以提高复用性"></a>开闭原则可以提高复用性</h5><p>在面向对象设计中，所有的逻辑都是从<strong>原子逻辑</strong>组合而来，而不是在一个类中独立实现一个业务逻辑。颗粒度越小，被复用的可能性就越大。避免相同的逻辑分撒在多个角落，缩小颗粒度，直到一个逻辑不可再拆分为止。</p><h5 id="开闭原则可以提高可维护性"><a href="#开闭原则可以提高可维护性" class="headerlink" title="开闭原则可以提高可维护性"></a>开闭原则可以提高可维护性</h5><h5 id="面向对象开发的要求"><a href="#面向对象开发的要求" class="headerlink" title="面向对象开发的要求"></a>面向对象开发的要求</h5><h4 id="开闭原则应用"><a href="#开闭原则应用" class="headerlink" title="开闭原则应用"></a>开闭原则应用</h4><h5 id="抽象约束"><a href="#抽象约束" class="headerlink" title="抽象约束"></a>抽象约束</h5><p>通过<strong>接口</strong>或<strong>抽象类</strong>可以<strong>约束一组可能变化的行为</strong>，并<strong>且能够实现对扩展开放</strong>：</p><ul><li>通过接口或抽象类约束扩展，<strong>对扩展边界限定</strong>，不允许出现在接口或抽象类中不存在的public方法</li><li>参数类型、引用对象尽量使用接口或抽象类，而不是实现类</li><li>抽象层尽量保持稳定</li></ul><h5 id="元数据（metadata）控制模块行为"><a href="#元数据（metadata）控制模块行为" class="headerlink" title="元数据（metadata）控制模块行为"></a>元数据（metadata）控制模块行为</h5><p>尽量使用元数据来控制程序行为，减少重复开发，如<code>login</code>方法中提供的先检查<code>IP</code>地址是否在允许访问的列表中，然后在确定是否需要到数据库中验证密码，表达的极致其实就是控制反转，如<code>Spring</code>的<code>IoC</code>容器。</p><p>注：元数据是用来描述环境和数据的数据，通俗的说就是配置参数。</p><h5 id="制定项目章程"><a href="#制定项目章程" class="headerlink" title="制定项目章程"></a>制定项目章程</h5><p>对于项目来说约定优于配置。</p><h5 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h5><p>对变化的封装：将相同的变化封装到一个接口或抽象类中，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。</p><p>封装变化，也就是受保护的变化，找出预计有变化或不稳定的点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;6大设计基本原则：&lt;strong&gt;单一职责原则&lt;/strong&gt;、&lt;strong&gt;里氏替换原则&lt;/strong&gt;、&lt;strong&gt;依赖倒置原则&lt;/strong&gt;、&lt;strong&gt;接口隔离原则&lt;/strong&gt;、&lt;strong&gt;迪米特法则&lt;/strong&gt;、&lt;strong&gt;开
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HBase依赖冲突</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/HBase%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/常见问题/HBase依赖冲突/</id>
    <published>2020-07-05T16:00:00.000Z</published>
    <updated>2020-07-13T11:40:15.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>连接代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">hbaseConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    org.apache.hadoop.conf.Configuration conf = HBaseConfiguration.create();</span><br><span class="line">    conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    conf.set(<span class="string">"hbase.zookeeper.property.clientPort"</span>, <span class="string">"2181"</span>);</span><br><span class="line">    conf.set(<span class="string">"zookeeper.znode.parent"</span>, <span class="string">"/hbase-unsecure"</span>);</span><br><span class="line">    Connection connection = ConnectionFactory.createConnection(conf);</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String tableName, String familyName, String columnName, String qualifier)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TableName name = TableName.valueOf(tableName);</span><br><span class="line">    Table table = hbaseConnection.getTable(name);</span><br><span class="line">    Get get = <span class="keyword">new</span> Get(qualifier.getBytes());</span><br><span class="line">    get.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(columnName));</span><br><span class="line">    Result rs = table.get(get);</span><br><span class="line">    <span class="keyword">return</span> Bytes.toString(rs.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hive依赖包冲突"><a href="#hive依赖包冲突" class="headerlink" title="hive依赖包冲突"></a>hive依赖包冲突</h3><p>在项目中同时存在<code>hive</code>和<code>hbase</code>时，<code>hive</code>中引用的<code>guava</code>与<code>hbase</code>中引用的<code>guava</code>版本冲突，从而导致执行<code>hbase</code>查询时报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.hadoop.hbase.DoNotRetryIOException: java.lang.IllegalAccessError: tried to access method com.google.common.base.Stopwatch.&lt;init&gt;()V from <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">hadoop</span>.<span class="title">hbase</span>.<span class="title">zookeeper</span>.<span class="title">MetaTableLocator</span></span></span><br></pre></td></tr></table></figure><p><code>Stopwatch</code>在<code>google</code>的<code>guava</code>包下，<code>hbase1.1.2</code>只在<code>guava12-16</code>下能正常运行。<code>guava17</code>开始，出现以上异常。尝试着将<code>guava</code>版本降低，后启动项目后报如下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">An attempt was made to call the method com.google.common.base.Splitter.splitToList(Ljava/lang/CharSequence;)Ljava/lang/List; but it does not exist. Its class, com.google.common.base.Splitter, is available from the following locations:</span><br><span class="line">jar:file:/mvnRespo/org/apache/hive/hive-exec/<span class="number">1.2</span>.1/hive-exec-<span class="number">1.2</span>.1.jar!/com/google/common/base/Splitter.class</span><br><span class="line">    jar:file:/mvnRespo/com/google/guava/guava/<span class="number">16.0</span>/guava-<span class="number">16.0</span>.jar!/com/google/common/base/Splitter.class</span><br></pre></td></tr></table></figure><p>由此可见<code>hive</code>必须依赖高版本的<code>guava</code>才行，然后就尝试着将hbase的依赖版本升级到<code>1.3.0</code>，问题得到了解决。</p><h3 id="tablestore依赖包冲突"><a href="#tablestore依赖包冲突" class="headerlink" title="tablestore依赖包冲突"></a>tablestore依赖包冲突</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(value = <span class="string">"$&#123;aliyun.endpoint:http&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String endPoint;</span><br><span class="line"><span class="meta">@Value</span>(value = <span class="string">"$&#123;aliyun.accessKeyId:test&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String accessKeyId;</span><br><span class="line"><span class="meta">@Value</span>(value = <span class="string">"$&#123;aliyun.accessSecret:test&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String accessSecret;</span><br><span class="line"><span class="meta">@Value</span>(value = <span class="string">"$&#123;aliyun.instanceName:test&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String instanceName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SyncClient syncClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    syncClient = <span class="keyword">new</span> SyncClient(endPoint, accessKeyId, accessSecret, instanceName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String key, String value, String tableName, String columnName)</span> </span>&#123;</span><br><span class="line">    PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();</span><br><span class="line">    primaryKeyBuilder.addPrimaryKeyColumn(key, PrimaryKeyValue.fromString(value));</span><br><span class="line">    PrimaryKey primaryKey = primaryKeyBuilder.build();</span><br><span class="line">    GetRowRequest request = <span class="keyword">new</span> GetRowRequest();</span><br><span class="line">    SingleRowQueryCriteria singleRowQueryCriteria = <span class="keyword">new</span> SingleRowQueryCriteria(tableName, primaryKey);</span><br><span class="line">    singleRowQueryCriteria.setMaxVersions(<span class="number">1</span>);</span><br><span class="line">    request.setRowQueryCriteria(singleRowQueryCriteria);</span><br><span class="line">    GetRowResponse response = syncClient.getRow(request);</span><br><span class="line">    Row row = response.getRow();</span><br><span class="line">    <span class="keyword">return</span> row.getLatestColumn(columnName).getValue().asString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目中同时存在<code>tablestore</code>和<code>hbase</code>时，<code>tablestore</code>中引用的<code>protobuf</code>版本<code>2.4.1</code>与<code>hbase</code>中引用的<code>protobuf</code>版本<code>2.5.0</code>版本冲突，从而导致执行<code>hbase</code>查询时报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.VerifyError: <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">hadoop</span>.<span class="title">hbase</span>.<span class="title">protofuf</span>.<span class="title">generated</span>.<span class="title">ClientProtos</span>$<span class="title">Result</span> <span class="title">overrides</span> <span class="title">final</span> <span class="title">method</span> <span class="title">getUnknownFields</span>.()<span class="title">Lcom</span>/<span class="title">google</span>/<span class="title">protobuf</span>/<span class="title">UnknownFieldSet</span></span>;</span><br></pre></td></tr></table></figure><p>首先想到的是引入高版本的<code>protobuf</code>。但是引入高版本的<code>protobuf</code>后查询阿里的彩虹表tablestore时会报另外的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsupportedOperationException: This is supposed to be overridden by subclasses.</span><br></pre></td></tr></table></figure><p>尝试着将<code>hbase</code>的版本升高到<code>2.2.0</code>，然后发现问题解决了，然后继续查看了一下<code>protobuf</code>依赖冲突版本，发现多了一个<code>hbase-shaded-protobuf</code>,原来在该版本中使用了<code>hbase-shaded</code> , 用来更改<code>hbase</code>中的一些报名，解决<code>protobuf</code>的冲突问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;远程连接&quot;&gt;&lt;a href=&quot;#远程连接&quot; class=&quot;headerlink&quot; title=&quot;远程连接&quot;&gt;&lt;/a&gt;远程连接&lt;/h3&gt;&lt;p&gt;maven依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="常见问题" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="HBase" scheme="https://yaoyinglong.github.io/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>Maven编译后文件损坏</title>
    <link href="https://yaoyinglong.github.io/Blog/%E6%A1%86%E6%9E%B6/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Maven%E7%BC%96%E8%AF%91%E5%90%8E%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/框架/常见问题/Maven编译后文件损坏/</id>
    <published>2020-07-05T16:00:00.000Z</published>
    <updated>2020-07-13T11:40:15.371Z</updated>
    
    <content type="html"><![CDATA[<p>在一般Maven项目中的<code>build</code>标签下通常会有如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application-test.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上的配置本身是没有问题的，但在某些需要需要将一些文件存放在项目中直接提供下载时，以上配置就回有问题，如果是将文件放到<code>resources</code>目录下，由于<code>filtering</code>设置为<code>true</code>，开启了过滤，会用指定的参数替换<code>directory</code>下的文件中的参数(<code>eg. ${name}</code>)。从而导致文件可能会损坏。</p><p>若配置文件需要传参数将<code>filtering</code>设置为<code>false</code>显然是不行的。使用<code>exclude</code>排除想下载的文件打包时都不会将文件打到<code>jar</code>包中，显然也是不行的。然后尝试做了如下调整，但并没有生效：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application-test.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>src/main/resources/download<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/download<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终只能将下载的文件单独放到其他目录，然后做如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application-test.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>download<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一般Maven项目中的&lt;code&gt;build&lt;/code&gt;标签下通常会有如下配置：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
      <category term="框架" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="常见问题" scheme="https://yaoyinglong.github.io/categories/%E6%A1%86%E6%9E%B6/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="Maven" scheme="https://yaoyinglong.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Go基础</title>
    <link href="https://yaoyinglong.github.io/Blog/Go/Go%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/Go/Go基础/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2020-07-27T11:36:21.998Z</updated>
    
    <content type="html"><![CDATA[<p><code>Go</code>语言是<strong>静态类型</strong>语言，<strong>所有的内存在 <code>Go</code> 中都是经过初始化的</strong>，当一个变量被声明之后，<strong>系统自动赋予它该类型的零值</strong>：<code>int</code> 为 <code>0</code>，<code>float</code> 为 <code>0.0</code>，<code>bool</code> 为 <code>false</code>，<code>string</code> 为<strong>空字符串</strong>，<strong>指针</strong>为 <code>nil</code> 等。</p><p>只有两个<strong>相同类型</strong>的值才可以进行比较，如果值的类型是<strong>接口</strong>（<code>interface</code>），那么它们也必须都实现了<strong>相同的接口</strong>。<code>&amp;&amp;</code>的优先级比<code>||</code>高（&amp;&amp; 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高）。</p><p><strong>变量</strong>、<strong>函数</strong>、<strong>常量</strong>名称如果<strong>首字母大写</strong>，则表示它<strong>可被其它的包访问</strong>；如果首字母小写，则表示它只能在本包中使用。</p><p><code>nil</code> 不是关键字或保留字且不能比较。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Go语言的基本类型有：</p><ul><li><code>bool</code></li><li><code>string</code></li><li><code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code></li><li><code>uint</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>（只有在底层编程时才需要）</li><li><code>byte</code> （<code>uint8</code> 的别名）</li><li><code>rune</code> （<code>int32</code> 的别名 代表一个 <code>Unicode</code> 码点）</li><li><code>float32</code>、<code>float64</code></li><li><code>complex64</code>、<code>complex128</code></li></ul><p>尽管在某些特定的运行环境下 <code>int</code>、<code>uint</code> 和 <code>uintptr</code> 的大小可能相等，但是它们依然是不同的类型，在需要把 <code>int</code> 类型当做 <code>int32</code> 类型使用的时候必须显示的对类型进行转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> num1, num2, num3 = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> num1, num2, num3 = <span class="number">1</span>, <span class="string">"2"</span>, <span class="number">3.5</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    num1 <span class="keyword">int</span></span><br><span class="line">    num2 <span class="keyword">string</span></span><br><span class="line">    num3 <span class="keyword">float64</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    num1 = <span class="number">1</span></span><br><span class="line">    num2 = <span class="string">"2"</span></span><br><span class="line">    num3 = <span class="number">3.5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Go是一门<strong>静态类型</strong>语言，每个变量都有一个在编译时就确定的静态类型。虽然<code>a</code>和<code>b</code>的的基本类型相同，但静态类型不同，无类型转换的情况下<strong>无法相互赋值</strong>。虽然在运行时中，接口变量存储的值也许会变，但接口变量的类型是不会变的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b MyInt</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Go语言常用容器有<strong>数组</strong>，<strong>切片</strong>，<code>Map</code>，<code>List</code>。map和切片是不可以用<code>==</code>直接被比较的。</p><p>数组的长度必须是<strong>常量表达式</strong>，若数组长度的位置出现<code>...</code>省略号，则表示数组的长度是根据<strong>初始化值的个数</strong>来计算。数组的长度是数组类型的一个组成部分，若两个数组<strong>类型相同</strong>（包括数组的<strong>长度</strong>，数组中<strong>元素的类型</strong>），可直接通过较运算符<code>==</code>和<code>!=</code>来判断两个数组是否相等，<strong>不能比较两个类型不同的数组，且不能相互赋值</strong>，否则程序将无法完成编译。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numArr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,&#125;</span><br><span class="line">strArr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;</span><br><span class="line"></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">10</span>, <span class="number">3</span>:<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>切片</strong>（<code>slice</code>）是对数组的一个<strong>连续片段的引用</strong>，所以切片是一个引用类型，终止索引标识的项不包括在切片内。切片的内部结构包含<strong>地址</strong>、<strong>大小</strong>和<strong>容量</strong>，切片一般<strong>用于快速地操作一块数据集合</strong>。切片在扩容时，<strong>容量的扩展规律是按容量的 <code>2</code> 倍数进行扩充</strong>。在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次。<code>make</code>函数创建切片时若只指定长度，则切片的长度和容量相等，<strong>不允许创建长度大于容量的切片</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,&#125;</span><br><span class="line">slice := arr[:]</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">slice := arr[<span class="number">1</span>:]</span><br><span class="line">slice := arr[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;...)</span><br><span class="line">slice = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;, slice...)</span><br><span class="line"></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">slice = <span class="built_in">append</span>(slice[:<span class="number">2</span>], <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>&#125;, slice[<span class="number">2</span>:]...)...)</span><br><span class="line"></span><br><span class="line">sliceA := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sliceB := []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">copyCount := <span class="built_in">copy</span>(sliceA, sliceB)</span><br><span class="line"></span><br><span class="line">sliceB := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sliceA := []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">copyCount := <span class="built_in">copy</span>(sliceA, sliceB)</span><br><span class="line"><span class="comment">// 创建容量和长度都是100的切片</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">99</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>计算切片的<strong>长度</strong>和<strong>容量</strong>，若底层数组容量<code>k</code>的切片<code>slice[i:j]</code>，长度为<code>j-i</code>，容量为<code>k-i</code>。也可以通过第三个索引来控制新切片的容量。若底层数组容量<code>k</code>的切片<code>slice[i:j:s]</code>，长度为<code>j-i</code>，容量为<code>s-i</code>，<code>s&lt;=K</code>。</p><p><code>map</code> 是引用类型，<strong>可动态增长</strong>，未初始化的 <code>map</code> 的值是 <code>nil</code>，使用函数 <code>len()</code> 可以获取 <code>map</code> 中 <code>pair</code> 的数目。<code>map</code>不能使用<code>cap()</code>函数。定义map时可现实指定容量，当 map 增长到容量上限的时候，如果再增加新的 key-value，map 的大小会自动加 <code>1</code>。map可以存函数。<code>map</code>是<strong>无序</strong>的。<strong>切片</strong>、<strong>函数</strong>以及<strong>包含切片的结构类型</strong>由于<strong>具有引用语意</strong>不能作为<code>map</code>的键。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapLit = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> mapLit <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapLit = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">mapLit := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>&#125;</span><br><span class="line">mapLit[<span class="number">3</span>] = <span class="string">"c"</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> mapLit &#123;</span><br><span class="line">    fmt.Println(<span class="string">"key value:"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(mapLit, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">mapLit := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"hello"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">"world"</span>: <span class="number">200</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value, isExist := mapLit[<span class="string">"hello"</span>]；isExist：</span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, value)</span><br><span class="line"></span><br><span class="line">skill := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="string">"fire"</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"chicken fire"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">f, ok := skill[<span class="string">"fire"</span>]</span><br></pre></td></tr></table></figure><p>列表是一种<strong>非连续</strong>的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lit := list.New()</span><br><span class="line">lit.PushBack(<span class="string">"AA"</span>)</span><br><span class="line">lit.PushFront(<span class="string">"BB"</span>)</span><br><span class="line">element := lit.PushFront(<span class="string">"CC"</span>)</span><br><span class="line">lit.InsertBefore(<span class="string">"DD"</span>, element)</span><br><span class="line"><span class="keyword">for</span> i := lit.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">   fmt.Println(<span class="string">"lit value:"</span>, i.Value)</span><br><span class="line">&#125;</span><br><span class="line">lit.Remove(element)</span><br></pre></td></tr></table></figure><p>Go语言线程安全的<code>sync.Map</code>，<code>Range</code>返回为<code>false</code>时将不再往下遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> syncMap sync.Map</span><br><span class="line">syncMap.Store(<span class="number">1</span>, <span class="string">"a"</span>)</span><br><span class="line">syncMap.Store(<span class="number">2</span>, <span class="string">"b"</span>)</span><br><span class="line">value, ok := syncMap.Load(<span class="number">2</span>)</span><br><span class="line">syncMap.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"key, value"</span>, key, value)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>Go 语言常用流程控制有 <code>if</code> 和 <code>for</code>，而 <code>switch</code> 和 <code>goto</code> 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><p><code>if-else</code>分支结构，可结合<code>goto</code>使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> index := <span class="number">12</span>; index &gt; <span class="number">10</span> &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index := <span class="number">10</span>; index == <span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">goto</span> onExit</span><br><span class="line">&#125;</span><br><span class="line">onExit:</span><br><span class="line">fmt.Println(<span class="string">"exit"</span>)</span><br></pre></td></tr></table></figure><p><code>go</code>中只有<code>for</code>循环结构，不支持 <code>while</code> 和 <code>do-while</code> 结构；for range 可以遍历<strong>数组</strong>、<strong>切片</strong>、<strong>字符串</strong>、<code>map</code> 及<strong>通道</strong>（<code>channel</code>）；其中用到的<code>range</code> 返回的是每个<strong>元素的副本</strong>，而不是直接返回对该元素的引用。字符串的遍历是一个个<code>rune</code> 字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">JLoop:</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> JLoop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> index &lt; <span class="number">10</span> &#123;</span><br><span class="line">    index++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str := <span class="string">"12456789"</span></span><br><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Println(<span class="string">"pos, char:"</span>, pos, char)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    channel &lt;- <span class="number">3</span></span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> value := <span class="keyword">range</span> channel &#123;</span><br><span class="line">    fmt.Println(<span class="string">"channel value:"</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code>表达式不需要为<strong>常量</strong>，甚至不需要为<strong>整数</strong>，<code>case</code> 按照从上到下的顺序进行求值，直到找到匹配的项，若<code>switch</code> 没有表达式，则对 <code>true</code> 进行匹配。<code>fallthrough</code>会紧接着执行下一个 <code>case</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"kk"</span></span><br><span class="line"><span class="keyword">switch</span> str &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"hello"</span>, <span class="string">"kk"</span>:</span><br><span class="line">    fmt.Println(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">    fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := <span class="number">11</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r &gt; <span class="number">10</span> &amp;&amp; r &lt; <span class="number">20</span>:</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>Go</code> 语言支持<strong>普通函数</strong>、<strong>匿名函数</strong>和<strong>闭包</strong>。函数间传递变量总是以<strong>值得方式传递</strong>，数组传递会完整复制并传递给函数，最好只传入指向数组的指针。函数间传递切片和<code>map</code>，<strong>只会复制切片和<code>map</code>本身，不会涉及底层数据</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   a = <span class="number">1</span></span><br><span class="line">   b = <span class="number">2</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := funcA()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := funcB()</span><br><span class="line">f := funcB</span><br><span class="line">a, b := f()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">string</span>, c <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"a1"</span>, <span class="string">"b2"</span>, <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">a, b, c := funcC()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcD</span><span class="params">(arr []<span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">      f(value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">funcD([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"this value:"</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数变量</span></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">f</span> = <span class="title">funcA</span></span></span><br><span class="line"><span class="function"><span class="title">a</span>, <span class="title">b</span> := <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 匿名函数</span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"inner func:"</span>, data)</span><br><span class="line">&#125;(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"inner func:"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">500</span>)</span><br></pre></td></tr></table></figure><p><strong>闭包</strong>是引用了<strong>自由变量</strong>的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除。被捕获到闭包中的变量让闭包本身拥有了记忆效应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accumulate</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      value++</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">accumulator := accumulate(<span class="number">1</span>)</span><br><span class="line">fmt.Println(accumulator()) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(accumulator()) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>可变参数和任意类型的可以变参数，用 <code>interface{}</code> 传递<strong>任意类型</strong>数据，<strong>可变参数</strong>变量是一个<strong>包含所有参数的切片</strong>，如果要将这个含有可变参数的变量传递给下一个可变参数函数，可以在传递时给可变参数变量后面添加<code>...</code>，这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notFixedParam</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notFixedParamV2</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">      <span class="keyword">switch</span> arg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">int64</span>:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notFixedParam(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">notFixedParamV2(<span class="string">"kk"</span>, <span class="number">1</span>, <span class="number">234</span>, <span class="string">"hello"</span>, <span class="number">3.14</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawPrint</span><span class="params">(rawList ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, raw := <span class="keyword">range</span> rawList &#123;</span><br><span class="line">fmt.Println(raw)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(slist ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">rawPrint(slist...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defer</code> 语句会将其后面跟随的语句进行<strong>延迟处理</strong>，在 <code>defer</code> 归属的函数<strong>即将返回</strong>时，将延迟处理的语句<strong>按 <code>defer</code> 的逆序进行执行</strong>。类似<code>java</code>的<code>finally</code>语句块。可与宕机<code>panic</code> 一起使用，宕机前会优先执行<code>defer</code>。提供<code>recover</code> 用于宕机恢复，且仅在延迟函数 <code>defer</code> 中有效。正常的执行过程中，调用 <code>recover</code> 会返回 <code>nil</code> 并且没有其他任何效果，调用 <code>recover</code> 可以捕获到 <code>panic</code> 的输入值，并且恢复正常的执行。<code>recover</code> 的宕机恢复机制就对应其他语言中的 <code>try/catch</code> 机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"宕机后要做的事情"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"宕机"</span>)</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p><strong>结构体</strong>的定义只是一种<strong>内存布局的描述</strong>，只有当结构体实例化时，才会真正地分配内存。使用<code>new</code>或<code>&amp;</code>构造的类型实例的类型是<strong>类型的指针</strong>。<code>Go</code>语言的<strong>类型</strong>或<strong>结构体没有构造函数</strong>的功能.</p><p>使用<code>.</code>来访问结构体的<strong>成员变量</strong>，访问结构体指针的成员变量时可以继续使用<code>.</code>，Go使用了语法糖（Syntactic sugar）技术，将 <code>ins.Name</code> 形式转换为 <code>(*ins).Name</code>；对结构体进行<code>&amp;</code>取地址操作时，视为对该类型进行一次 new 的实例化操作；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">R, G, B <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color := <span class="built_in">new</span>(Color)</span><br><span class="line">(*color).R = <span class="number">12</span></span><br><span class="line">color.G = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">color := &amp;Color&#123;&#125;</span><br><span class="line">(*color).R = <span class="number">12</span></span><br><span class="line">color.G = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Command <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name    <span class="keyword">string</span></span><br><span class="line">   Var     *<span class="keyword">int</span></span><br><span class="line">   Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">version := <span class="number">1</span></span><br><span class="line"><span class="comment">// 使用键值对填充结构体</span></span><br><span class="line">cmd := &amp;Command&#123;</span><br><span class="line">    Name:    <span class="string">"version"</span>,</span><br><span class="line">    Var:     &amp;version,</span><br><span class="line">    Comment: <span class="string">"show version"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"cmd, Name, Var, Comment:"</span>, *cmd, cmd.Name, *cmd.Var, cmd.Comment)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用多个值的列表初始化结构体</span></span><br><span class="line">cmd := Command&#123;</span><br><span class="line">    <span class="string">"version"</span>,</span><br><span class="line">    &amp;version,</span><br><span class="line">    <span class="string">"show version"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"cmd, Name, Var, Comment:"</span>, cmd, cmd.Name, *cmd.Var, cmd.Comment)</span><br></pre></td></tr></table></figure><p><strong>匿名结构体</strong>没有类型名称，无须通过 <code>type</code> 关键字定义就可以直接使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name    <span class="keyword">string</span></span><br><span class="line">   Var     *<span class="keyword">int</span></span><br><span class="line">   Comment <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">   <span class="string">"version"</span>,</span><br><span class="line">   &amp;version,</span><br><span class="line">   <span class="string">"show version"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMsg</span> <span class="params">(msg *<span class="keyword">struct</span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">id <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">data <span class="keyword">string</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"msg"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">    data <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="number">1024</span>,</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">&#125;</span><br><span class="line">printMsg(msg)</span><br></pre></td></tr></table></figure><p>结构体可以包含一个或多个<strong>匿名</strong>（或<strong>内嵌</strong>）字段，没有显式的名字，只有字段的类型，<strong>此时类型也就是字段的名</strong>。在一个结构体中<strong>对于每一种数据类型只能有一个匿名字段</strong>。结构体可以包含内嵌结构体，内嵌结构体甚至可以来自其他包。</p><p>结构体实例访问<strong>任意一级</strong>的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> innerS <span class="keyword">struct</span> &#123;</span><br><span class="line">   in1 <span class="keyword">int</span></span><br><span class="line">   in2 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> outerS <span class="keyword">struct</span> &#123;</span><br><span class="line">   b <span class="keyword">int</span></span><br><span class="line">   c <span class="keyword">float32</span></span><br><span class="line">   in1 <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">int</span></span><br><span class="line">   innerS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer := <span class="built_in">new</span>(outerS)</span><br><span class="line">outer.b = <span class="number">6</span></span><br><span class="line">outer.c = <span class="number">7.5</span></span><br><span class="line">outer.<span class="keyword">int</span> = <span class="number">60</span></span><br><span class="line">outer.in1 = <span class="number">20</span></span><br><span class="line">outer.innerS.in1 = <span class="number">5</span></span><br><span class="line">outer.in2 = <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"outer1 :"</span>, *outer)</span><br><span class="line">outer2 := outerS&#123;<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">20</span>, <span class="number">60</span>, innerS&#123;<span class="number">5</span>, <span class="number">10</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="string">"outer2 :"</span>, outer2)</span><br></pre></td></tr></table></figure><p>结构体标签是对结构体字段的额外信息标签，由<strong>一个或多个键值对</strong>组成；键与值使用<strong>冒号</strong>分隔，值用<strong>双引号</strong>括起来；键值对之间使<strong>用一个空格分隔</strong>。标签内容是<strong>静态的</strong>，无须实例化结构体，可以通过<strong>反射</strong>从结构体中获取标签内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ins <span class="keyword">struct</span> &#123;</span><br><span class="line">   in1 <span class="keyword">int</span> <span class="string">`key1:"value1" key2:"value2"`</span></span><br><span class="line">   in2 <span class="keyword">int</span> <span class="string">`key1:"value1" key2:"value2"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeOfIns := reflect.TypeOf(Ins&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> catType, ok := typeOfIns.FieldByName(<span class="string">"in2"</span>); ok &#123;</span><br><span class="line">    fmt.Println(catType.Tag.Get(<span class="string">"key1"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法能给用户定义的类型添加新的行为，实际上也是函数，仅仅是在申明时，在关键字<code>func</code>和方法名间增加了一个参数，该参数称为<strong>接收者</strong>（<strong>值接收者</strong>、<strong>指针接收者</strong>），<strong>有接收者为方法，无接收者为函数</strong>。值接收者调用时会使用这个值的副本来执行，如下所示<code>changeEmailV2</code>方法是无效的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cusUser <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *cusUser)</span> <span class="title">changeEmailV1</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">u.email = email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u cusUser)</span> <span class="title">changeEmailV2</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">u.email = email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>若要创建一个新值，该类型的方法使用值接收者，若要修改当前值，使用指针接收者。</strong></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><code>Go</code>无类和继承的概念，<code>Go</code>语言的接口在命名时，一般会在单词后面添加 <code>er</code>；当方法名首字母大写时，且该接口类型名首字母也大写时，该方法可被接口所在的包之外的代码访问。</p><p>接口被实现必须满足，<strong>接口的方法与实现接口的类型方法格式一致，接口中所有方法均被现实</strong>。类型和接口之间有一对多和多对一的关系。一个类型可以同时实现多个接口，一个接口的方法，不一定需要由一个类型完全实现。</p><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。只要<strong>接口的所有方法被实现</strong>，则这个接口中的所有嵌套接口的方法均可以被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">   WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">   CanWriter() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">   WriterClose() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FileWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NetWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">   FileWriter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *FileWriter)</span> <span class="title">WriteData</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"WriteData:"</span>, data)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *FileWriter)</span> <span class="title">WriterClose</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"FileWriter Close"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *NetWriter)</span> <span class="title">CanWriter</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"CanWrite"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileWriter := <span class="built_in">new</span>(FileWriter)</span><br><span class="line">fileWriter.WriterClose()</span><br><span class="line">fileWriter.WriteData(<span class="string">"FileWriter"</span>)</span><br><span class="line"></span><br><span class="line">netWriter := <span class="built_in">new</span>(NetWriter)</span><br><span class="line">netWriter.WriterClose()</span><br><span class="line">netWriter.WriteData(<span class="string">"NetWriter"</span>)</span><br><span class="line">netWriter.CanWriter()</span><br><span class="line"></span><br><span class="line">f := <span class="built_in">new</span>(NetWriter)</span><br><span class="line"><span class="keyword">var</span> writer DataWriter</span><br><span class="line">writer = f</span><br><span class="line">writer.WriteData(<span class="string">"NetWriter2"</span>)</span><br><span class="line">writer.CanWriter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writer DataWriter = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">writer = f</span><br><span class="line">writer.WriteData(<span class="string">"NetWriter3"</span>)</span><br><span class="line">writer.CanWriter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writeCloser DataWriteCloser = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">writeCloser.WriterClose()</span><br><span class="line">writeCloser.WriteData(<span class="string">"writeCloser"</span>)</span><br><span class="line">writeCloser.CanWriter()</span><br></pre></td></tr></table></figure><p>将接口转换为其他接口，若不写<code>ok</code>接收是否为实现该类型，若<code>rw</code>没有完全实现接口，将触发宕机。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writeCloser DataWriteCloser = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">rw, ok := writeCloser.(Closer)</span><br><span class="line">fmt.Println(ok, <span class="string">";"</span>, rw.WriterClose())</span><br></pre></td></tr></table></figure><p>将接口转换为其他类型时，接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writeCloser DataWriteCloser = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">rw, ok := writeCloser.(*NetWriter)</span><br><span class="line">fmt.Println(ok, <span class="string">";"</span>, rw.WriterClose(), rw.WriteData(<span class="string">"*NetWriter"</span>), rw.CanWriter())</span><br></pre></td></tr></table></figure><p>接口在底层的实现有<code>type</code> 和 <code>data</code>两个部分。显式地将 <code>nil</code> 赋值给接口时，接口的 <code>type</code> 和 <code>data</code> 都将为 <code>nil</code>，此时接口与 nil 值判断是相等的。将带有类型的 <code>nil</code> 赋值给接口时，只有 <code>data</code> 为 <code>nil</code>，而<code>type</code> 不为 <code>nil</code>，此时接口与 <code>nil</code> 判断将不相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> insImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ins *insImpl)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"hi"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStringer</span><span class="params">()</span> <span class="title">fmt</span>.<span class="title">Stringer</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> ins *insImpl = <span class="literal">nil</span></span><br><span class="line">   <span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">fmt.Println(GetStringer() == <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> ins *insImpl = <span class="literal">nil</span></span><br><span class="line">fmt.Println(ins == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>Go的<strong>源码复用</strong>建立在<strong>包<code>package</code></strong>的基础上，入口 <code>main()</code> 函数所在的包（<code>package</code>）叫 <code>main</code>。包与文件夹一一对应，一般包的名称就是其源文件所在目录的名称，所有与包相关的操作，必须依赖于<strong>工作目录<code>GOPATH</code></strong>。包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是<strong>包在引用时一般使用全路径引用</strong>。</p><p>包的习惯用法：</p><ul><li>包名一般小写，使用简短且有意义的名称。</li><li>包名一般和所在目录同名，也可不同，包名中不能包含<code>-</code>等特殊符号。</li><li>包一般使用域名作为目录名称，能保证包名的唯一性。</li><li>包名为 <code>main</code> 的包为应用程序的入口包，编译不包含 <code>main</code> 包的源码文件时不会得到可执行文件。</li><li>一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。</li></ul><p>包的引用路径分为<strong>全路径导入</strong>和<strong>相对路径导入</strong>。可以自定义别名引用包；也可用<code>.</code>省略引用格式，相当于把 包直接合并到当前程序中，在使用 包内的方法是可以不用加前缀直接引用；若只执行包初始化的 <code>init</code> 函数，不使用包内部的数据可使用匿名引用格式；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全路径导入：源码位于GOPATH/src/lab/test目录下</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"lab/test"</span></span><br><span class="line"><span class="comment">// 相对路径导入：源码位GOPATH/src/lab/a目录下</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../a"</span></span><br><span class="line"><span class="comment">// 自定义别名引用包</span></span><br><span class="line"><span class="keyword">import</span> F <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 省略引用格式</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 匿名引用格式</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"fmt"</span></span><br></pre></td></tr></table></figure><p>一个包可有多个 <code>init</code> 函数，包加载时会执行全部 <code>init</code> 函数，但<strong>不能保证执行顺序</strong>；包<strong>不能出现环形引用</strong>；包<strong>允许重复引用</strong>；包初始化程序从 <code>main</code> 函数引用的包开始，<strong>逐级查找</strong>包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图；编译器会将<strong>有向无环图</strong>转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化；单个包的初始化<strong>先初始化常量，然后是全局变量，最后执行包的 <code>init</code> 函数</strong>。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p><code>Go</code> 的并发通过 <code>goroutine</code>特性完成。<code>goroutine</code> 类似于<strong>线程</strong>，但是可根据需要创建多个 <code>goroutine</code> 并发工作。<code>goroutine</code> 是由 <strong><code>Go</code> 运行时调度完成</strong>，而<strong>线程是由操作系统调度完成</strong>。</p><p><code>Go</code> 提供 <code>channel</code>在多个 <code>goroutine</code> 间进行通信，<code>channel</code>是<strong>类型相关</strong>的<strong>语言级别</strong>得<code>goroutine</code>间的<strong>进程内</strong>的通信方式。必须使用 <code>make</code> 创建 <code>channel</code>；可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="number">1</span> &#125;()</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="string">"hi"</span> &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Equip <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> *Equip)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- &amp;Equip&#123;a: <span class="number">1</span>, b: <span class="number">2</span>&#125; &#125;()</span><br></pre></td></tr></table></figure><p>通道使用<code>&lt;-</code>操作符<strong>发送</strong>和<strong>接收</strong>数据；把数据往通道中发送时，若接收方一直<strong>未接收</strong>，发送操作将<strong>持续阻塞</strong>；通道的收发操作在<strong>不同的两个 <code>goroutine</code> 间进行</strong>；接收将<strong>持续阻塞</strong>直到发送方发送数据；每次接收<strong>一个</strong>元素；<strong>被关闭的通道</strong>不会被置为 <code>nil</code>。对已经关闭的通道进行发送，将会触发宕机。从<strong>已关闭</strong>的通道<strong>接收数据</strong>或者正在接收数据时，将会接收到通道<strong>类型的零值</strong>，然后<strong>停止阻塞并返回</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞接收数据</span></span><br><span class="line">data := &lt;-ch</span><br><span class="line"><span class="comment">// 非阻塞接收数据，可能造成高CPU占用，很少使用，若ok未false表示通道ch已关闭</span></span><br><span class="line">data, ok := &lt;-ch</span><br><span class="line"><span class="comment">// 接收任意数据，忽略接收数据</span></span><br><span class="line">&lt;- ch</span><br><span class="line"><span class="comment">// 声明一个只能发送的通道类型</span></span><br><span class="line"><span class="keyword">var</span> chSendOnly = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 声明一个只能接收的通道类型</span></span><br><span class="line"><span class="keyword">var</span> chRecvOnly = <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 关闭通道</span></span><br><span class="line"><span class="built_in">close</span>(chSendOnly)</span><br><span class="line"><span class="comment">// 带缓冲的通道，缓冲通道被填满时，发送数据时发生阻塞，带缓冲通道为空时，接收数据时发生阻塞</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>协程有<strong>独立的栈空间</strong>，<strong>共享堆空间</strong>，调度由用户自己控制，本质上类似于用户级线程，这些用户级线程的调度也是自己实现的。<strong>一个线程上可以跑多个协程，协程是轻量级的线程</strong>。</p><p>使用 <code>go</code> 关键字创建 <code>goroutine</code> 时，被调用函数的<strong>返回值会被忽略</strong>。若要在 <code>goroutine</code> 中返回数据，通过通道把数据从 <code>goroutine</code> 中作为返回值传出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(param1, param2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"param3, param4:"</span>, param1, param2)</span><br><span class="line">&#125;(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><code>Go</code>未为<code>channel</code>专门设置超时处理机制，但可通过<code>select</code>来设置超时。select用法与switch很类似，但select中只要其中一个<code>case</code>已经完成，程序就会继续往下执行，而不会考虑其他<code>case</code>情况，且每个<code>case</code>语句里必须是一个<code>IO</code>操作，<code>select</code>是按顺序<strong>从头至尾</strong>评估。若无语句可执行，则执行<code>default</code>语句，否则被阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num := &lt;-ch:</span><br><span class="line">    fmt.Println(<span class="string">"num:"</span>, num)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">    quit &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Go</code>的<code>sync</code>包中提供互斥锁<code>sync.Mutex</code>和读写互斥锁<code>sync.RWMutex</code>。同时提供了等待组<code>sync.WaitGroup</code>进行多个任务的<strong>同步</strong>，每个 <code>sync.WaitGroup</code> 值在内部维护着一个计数，保证在并发环境中完成指定数量的任务，若<code>WaitGroup</code>的值大于0，<code>Wait</code>方法就会被阻塞。同时提供原子访问<code>atomic</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw sync.Mutex</span><br><span class="line">rw.Lock()</span><br><span class="line"><span class="keyword">defer</span> rw.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rw sync.RWMutex</span><br><span class="line">rw.RLock()</span><br><span class="line"><span class="keyword">defer</span> rw.RUnlock()</span><br><span class="line">rw.Lock()</span><br><span class="line"><span class="keyword">defer</span> rw.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done() </span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">atomic.AddInt32(&amp;counter, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 安全的写整型值</span></span><br><span class="line">atomic.StoreInt64(&amp;counter, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 安全的读整型值</span></span><br><span class="line">atomic.LoadInt64(&amp;counter)</span><br></pre></td></tr></table></figure><p>死锁发生条件：</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不剥夺条件</li><li>环路等待</li></ul><p>解决办法：</p><ul><li>并发范文多个表，约定访问顺序</li><li>同一事物中，尽可能一次锁定获取所需资源</li><li>容易死锁业务场景，尝试升级锁颗粒度</li><li>采用分布式事务锁或乐观锁</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><code>reflect</code> 包定义了两个重要的类型 <code>Type</code> 和 <code>Value</code> <strong>任意接口值</strong>在反射中都可以理解为由 <code>reflect.Type</code> 和 <code>reflect.Value</code> 两部分组成；提供了<code>reflect.TypeOf</code> 和<code>reflect.ValueOf</code> 两个函数来获取任意对象的 <code>Value</code> 和 <code>Type</code>。</p><p>反射中分<strong>类型<code>Type</code></strong>和<strong>种类<code>Kind</code></strong>，当需要区分一个<strong>大品种</strong>的类型时用<code>Kind</code>，<code>Kind</code>方法描述的是<strong>基础类型</strong>；如需统一判断类型中的指针时。而Type是指<strong>系统原生数据类型</strong>，以及<strong>使用<code>type</code>关键字定义的类型</strong>。通过 <code>reflect.Elem()</code> 方法<strong>获取该指针指向的元素类型</strong>。<code>Elem</code>方法能够<strong>对指针进行解引用</strong>，然后将结果存储到<strong>反射 Value 类型对象</strong>  中。</p><p>反射可以将<strong>接口类型变量</strong>转换为<strong>反射类型对象</strong>，反射可以将<strong>反射类型对象</strong>转换为<strong>接口类型变量</strong>，若要修改<strong>反射类型对象</strong>其<strong>值必须是可写的</strong>。可通过 <code>CanSet</code> 方法检查<code>reflect.Value</code>类型变量的<strong>可写性</strong>。对于<strong>不具有可写性</strong>的 <code>Value</code> 类型变量，调用 <code>Set</code> 方法会<strong>报错</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">    B <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := &amp;T&#123;&#125;</span><br><span class="line">typeOfT := reflect.TypeOf(t)</span><br><span class="line"><span class="comment">// Name: ,Kind:ptr</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, typeOfT.Name(), <span class="string">"kind:"</span>, typeOfT.Kind())</span><br><span class="line"><span class="comment">// 通过 reflect.Elem() 方法获取这个指针指向的元素类型</span></span><br><span class="line">typeOfT = typeOfT.Elem()</span><br><span class="line"><span class="comment">// Name: T,Kind: struct</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, typeOfT.Name(), <span class="string">"kind:"</span>, typeOfT.Kind())</span><br><span class="line">typeOfT.Field(<span class="number">0</span>).SetInt(<span class="number">99</span>)</span><br><span class="line">typeOfT.Field(<span class="number">1</span>).SetString(<span class="string">"Sunset Strip"</span>)</span><br><span class="line"></span><br><span class="line">t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</span><br><span class="line">typeOfA := reflect.TypeOf(t)</span><br><span class="line"><span class="comment">// Name: T,Kind: struct</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, typeOfA.Name(), <span class="string">"kind:"</span>, typeOfA.Kind())</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">7</span></span><br><span class="line">tof := reflect.TypeOf(x)</span><br><span class="line"><span class="comment">// Name: MyInt,Kind: int</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, tof.Name(), <span class="string">"kind:"</span>, tof.Kind())</span><br><span class="line">vof := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 不能是int</span></span><br><span class="line">ref := vof.Interface().(MyInt)</span><br><span class="line">fmt.Println(<span class="string">"can set:"</span>, vof.CanSet()) <span class="comment">// false</span></span><br><span class="line">vof2 := reflect.ValueOf(&amp;x)</span><br><span class="line">fmt.Println(<span class="string">"can set:"</span>, vof2.CanSet()) <span class="comment">// false</span></span><br><span class="line">vof3 := vof2.Elem()</span><br><span class="line">fmt.Println(<span class="string">"can set:"</span>, vof3.CanSet()) <span class="comment">// true</span></span><br><span class="line">vof3.SetInt(<span class="number">25</span>)</span><br><span class="line">fmt.Println(<span class="string">"ref:"</span>, vof3)  <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p><code>Map</code>、<code>Slice</code>、<code>Chan</code> 属于<strong>引用类型</strong>，使用起来<strong>类似于指针</strong>，但是在种类常量定义中仍然属于<strong>独立的种类Kind</strong>，不属于 <code>Ptr</code>。所有通过<code>reflect.ValueOf(x)</code> 返回的<code>reflect.Value</code>都<strong>不可以取地址</strong>，通过<strong>指针</strong>间接地获取的<code>reflect.Value</code>都可以取地址，即使开始的是一个不可取地址的<code>Value</code>。当<strong><code>reflect.Value</code>不可寻址</strong>时，使用 <code>Addr()</code> 方法也<strong>无法取到值的地址</strong>。</p><p>已知<code>reflect.Type</code>时，可动态地创建这个类型的实例，实例的类型为<strong>指针</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">typeOfA := reflect.TypeOf(a)</span><br><span class="line">aIns := reflect.New(typeOfA)</span><br><span class="line"><span class="comment">// name: *int, kind: ptr</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, aIns.Type(), <span class="string">"kind:"</span>, aIns.Kind())</span><br></pre></td></tr></table></figure><p>使用反射调用函数时，需将参数使<strong>用反射值对象的切片<code>[]reflect.Value</code>构造后传入<code>Call()</code>方法中</strong>，调用完成时，函数的<strong>返回值</strong>通过<code>[]reflect.Value</code>返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">funcVal := reflect.ValueOf(<span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b</span><br><span class="line">&#125;)</span><br><span class="line">paramList := []reflect.Value&#123;reflect.ValueOf(<span class="number">10</span>), reflect.ValueOf(<span class="number">24</span>)&#125;</span><br><span class="line">retList := funcVal.Call(paramList)</span><br><span class="line">fmt.Println(<span class="string">"result:"</span>, retList[<span class="number">0</span>].Int())</span><br></pre></td></tr></table></figure><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><ul><li>测试用例文件<strong>不会参与正常源码的编译</strong>，<strong>不会被包含到可执行文件中</strong>；</li><li>测试用例的文件名必须以<code>_test.go</code>结尾；</li><li>需要使用 <code>import</code> 导入 <code>testing</code> 包；</li><li>测试函数的名称要以<code>Test</code>或<code>Benchmark</code>开头，后面可以跟任意字母组成的字符串，但第一个字母必须大写，例如 TestAbc()，一个测试用例文件中可以包含多个测试函数；</li><li>单元测试则以<code>(t *testing.T)</code>作为参数，性能测试以<code>(t *testing.B)</code>做为参数；</li><li>测试用例文件使用<code>go test</code>命令来执行，源码中不需要 main() 函数作为入口，所有以<code>_test.go</code>结尾的源码文件内以<code>Test</code>开头的函数都会自动执行。</li></ul><h3 id="SetFinalizer"><a href="#SetFinalizer" class="headerlink" title="SetFinalizer"></a>SetFinalizer</h3><p><code>Go</code>语言自带垃圾回收机制，<code>GC</code> 是自动进行的，可以使用 <code>runtime.GC()</code> 函数手动 <code>GC</code>。</p><p><code>finalizer</code>（<strong>终止器</strong>）是通过 <strong>runtime.SetFinalizer</strong> 来设置与对象关联的一个函数，若某对象定义了 <code>finalizer</code>，当它被 <code>GC</code> 时候，该<code>finalizer</code> 将被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFinalizer</span><span class="params">(x, f <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p>参数<code>x</code> 必须是一个指向通过 <code>new</code> 申请的对象的<strong>指针</strong>，或者通过对复合字面值取址得到的<strong>指针</strong>，参数 <code>f</code> 必须是一个<strong>函数</strong>。<code>SetFinalizer</code> 函数将 <code>x</code> 的终止器设置为 <code>f</code>，当垃圾收集器发现 <code>x</code> 不能再直接或间接访问时，则清理 <code>x</code> 并调用 <code>f(x)</code>，终止器会在 <code>x</code> 不能直接或间接访问后的<strong>任意时间</strong>被调用执行，<strong>不保证终止器会在程序退出前执行</strong>，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。<code>*x</code> 的大小为 <code>0</code> 字节，也不保证终止器会执行。也可以使用<code>SetFinalizer(x, nil)</code>来清理绑定到 <code>x</code> 上的终止器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Road <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRoad</span><span class="params">(r *Road)</span></span> &#123;</span><br><span class="line">   log.Println(<span class="string">"road:"</span>, *r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entry</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> rd = Road(<span class="number">999</span>)</span><br><span class="line">   r := &amp;rd</span><br><span class="line">   runtime.SetFinalizer(r, findRoad)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    runtime.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Go&lt;/code&gt;语言是&lt;strong&gt;静态类型&lt;/strong&gt;语言，&lt;strong&gt;所有的内存在 &lt;code&gt;Go&lt;/code&gt; 中都是经过初始化的&lt;/strong&gt;，当一个变量被声明之后，&lt;strong&gt;系统自动赋予它该类型的零值&lt;/strong&gt;：&lt;co
      
    
    </summary>
    
      <category term="Go" scheme="https://yaoyinglong.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://yaoyinglong.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>亲密关系</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/亲密关系/</id>
    <published>2020-06-26T16:00:00.000Z</published>
    <updated>2020-06-27T03:33:30.709Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候问题不能解决，是因为我们在非常有限的知识来源中寻找答案，却不懂得运用我们的想象力和直觉来突破问题的框架。</p><ul><li>要解决问题，必须先跳脱问题的框架</li><li>所有问题，其实都是经过伪装的礼物和宝贵的经验</li><li>你所看到的每件事，都是你内心世界的投影</li><li>每个人都有能力为自己生活中遇到的事百分百负责</li><li>自由并非来自答案，而是来自问题</li><li>没有什么问题是大道爱无法解决的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多时候问题不能解决，是因为我们在非常有限的知识来源中寻找答案，却不懂得运用我们的想象力和直觉来突破问题的框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要解决问题，必须先跳脱问题的框架&lt;/li&gt;
&lt;li&gt;所有问题，其实都是经过伪装的礼物和宝贵的经验&lt;/li&gt;
&lt;li&gt;你所看到的每件事，
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>情商</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E6%83%85%E5%95%86/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/情商/</id>
    <published>2020-06-24T16:00:00.000Z</published>
    <updated>2020-06-25T11:53:04.756Z</updated>
    
    <content type="html"><![CDATA[<p>提高情商是把<strong>不可控情绪</strong>的部分变为<strong>可控制情绪</strong>，从而<strong>增强理解他人</strong>及<strong>与他人相处</strong>的能力。</p><h3 id="低情商特点"><a href="#低情商特点" class="headerlink" title="低情商特点"></a>低情商特点</h3><ul><li><p>说话做事时<strong>无意识</strong>顾及别人的感受</p></li><li><p><strong>下意识</strong>地推卸责任、散发负面情绪</p></li><li>感知力差，<strong>收不到</strong>他人的情绪反馈</li><li><strong>缺乏</strong>安全感，渴望得到他人的关注</li><li>惯性泼冷水，<strong>没有</strong>赞美他人的天性</li></ul><h5 id="情商五要素"><a href="#情商五要素" class="headerlink" title="情商五要素"></a>情商五要素</h5><ul><li>了解自我</li><li>自我情绪</li><li>自我激励</li><li>识别他人情绪</li></ul><p>情商即是<strong>认识自己</strong>也是<strong>认识他人</strong>，认识自己包括<strong>自我定位</strong>、<strong>自我管理</strong>、<strong>自我激励</strong>；认识他人包括洞<strong>察情绪</strong>、<strong>同理心</strong>、<strong>学会沟通</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提高情商是把&lt;strong&gt;不可控情绪&lt;/strong&gt;的部分变为&lt;strong&gt;可控制情绪&lt;/strong&gt;，从而&lt;strong&gt;增强理解他人&lt;/strong&gt;及&lt;strong&gt;与他人相处&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;h3 id=&quot;低情商特点&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/图/</id>
    <published>2020-06-21T16:00:00.000Z</published>
    <updated>2020-07-13T11:40:15.372Z</updated>
    
    <content type="html"><![CDATA[<p>​    图可分为<strong>有向图</strong>和<strong>无向图</strong>，一般用<code>G=(V,E)</code>来表示图，<code>V</code>表示顶点，<code>E</code>表示通过图的边，常用<strong>邻接矩阵</strong>或者<strong>邻接表</strong>来描述一副图。图的遍历算法，根据访问节点的顺序，可分为<strong>广度优先搜索</strong>（<code>BFS</code>：Breadth First Search）和<strong>深度优先搜索</strong>（<code>DFS</code>：）</p><h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><p>​    广度优先搜索在进一步遍历图中顶点之前，<strong>先访问当前顶点的所有邻接结点</strong>。</p><ol><li>首先选择一个顶点作为起始结点</li><li>将起始结点放入队列中</li><li>从队列首部选出一个顶点，并找出所有与之邻接的结点，将找到的邻接结点放入队列尾部</li><li>按照同样的方法处理队列中的下一个结点</li></ol><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>​    深度优先搜索在搜索过程中访问某个顶点后，需要<strong>递归</strong>地访问此顶点的<strong>所有未访问过的相邻顶点</strong>，<code>DFS</code>在<strong>环监测</strong>和<strong>拓扑排序</strong>中都有不错的应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    图可分为&lt;strong&gt;有向图&lt;/strong&gt;和&lt;strong&gt;无向图&lt;/strong&gt;，一般用&lt;code&gt;G=(V,E)&lt;/code&gt;来表示图，&lt;code&gt;V&lt;/code&gt;表示顶点，&lt;code&gt;E&lt;/code&gt;表示通过图的边，常用&lt;strong&gt;邻接矩阵&lt;/s
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>树基础</title>
    <link href="https://yaoyinglong.github.io/Blog/%E7%AE%97%E6%B3%95/%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/算法/树基础/</id>
    <published>2020-06-21T16:00:00.000Z</published>
    <updated>2020-08-31T01:57:33.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>每个节点有<strong>零个</strong>或<strong>多个</strong>子节点；</li><li>没有父节点的节点称为<strong>根节点</strong>；</li><li>每个<strong>非根节点</strong>有且<strong>仅有一个</strong>父节点；</li><li>除了根节点以外，<strong>每个子节点都可分为多个不相交的子树</strong>；</li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度，<strong>二叉树的度为2</strong>；</li><li><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度；</li><li><strong>叶节点或终端节点</strong>：度为零的节点；</li><li><strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li><strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li><li><strong>兄弟节点</strong>：具有<strong>相同父节点</strong>的节点互称为兄弟节点；</li><li><strong>节点的层次</strong>：从根开始定义起，<strong>根为第<code>1</code>层</strong>，根的子节点为第2层，以此类推；</li><li><strong>树的高度或深度</strong>：树中节点的<strong>最大层次</strong>；</li><li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li><li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li><li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li><li><strong>森林</strong>：由<code>m（m&gt;=0）</code>棵互不相交的树的集合称为森林；</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><strong>无序树</strong>：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为<strong>自由树</strong>；</li><li><strong>有序树</strong>：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul><li><strong>二叉树</strong>：每个节点最多含有两个子树的树称为二叉树；<ul><li><strong>完全二叉树</strong>：对于一颗二叉树，假设其深度为<code>d(d&gt;1)</code>。除了第<code>d</code>层外，其它各层的节点数目均已达最大值，且第<code>d</code>层所有节点<strong>从左向右连续地紧密排列</strong>，这样的二叉树被称为完全二叉树，其中<strong>满二叉树</strong>的定义是所有叶节点都在最底层的完全二叉树;</li><li><strong>平衡二叉树</strong>（<code>AVL</code>树，<strong>红黑树</strong>是该树的一种）：<strong>当且仅当任何节点的两棵子树的高度差不大于1</strong>的二叉树，<code>SGI</code>/<code>STL</code>的<code>set</code>/<code>map</code>底层都是用<strong>红黑树</strong>实现的；</li><li><strong>排序二叉树</strong>（<strong>二叉查找树</strong>（英语：<code>Binary Search Tree</code>），也称<strong>二叉搜索树</strong>、<strong>有序二叉树</strong>）；</li></ul></li><li><strong>霍夫曼树</strong>（用于信息编码）：<strong>带权路径最短的二叉树</strong>称为哈夫曼树或<strong>最优二叉树</strong>；</li><li><strong>B树</strong>：一种<strong>对读写操作进行优化的自平衡的二叉查找树</strong>，能够保持数据有序，拥有多余两个子树。</li></ul></li></ul><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>​    二叉树的遍历分为<strong>广度优先遍历</strong>和<strong>深度优先遍历</strong>，广度优先遍历又叫<strong>层序遍历</strong>，从上往下每一层<strong>从左到右</strong>依次访问节点；深度优先遍历可细分为<strong>先序遍历</strong>、<strong>中序遍历</strong>、<strong>后续遍历</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    TreeNode leftNode;</span><br><span class="line">    TreeNode rightNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p>对任一子树，先访问根，然后遍历其左子树，最后遍历其右子树。前序遍历的形式总是：<strong>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(treeNode);</span><br><span class="line">    preorder(treeNode.leftNode);</span><br><span class="line">    preorder(treeNode.rightNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode tree = stack.pop();</span><br><span class="line">        System.out.println(tree);</span><br><span class="line">        <span class="keyword">if</span> (tree.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tree.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tree.leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>对任一子树，先遍历其左子树，然后访问根，最后遍历其右子树。中序遍历的形式总是：<strong>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(treeNode.leftNode);</span><br><span class="line">    System.out.println(treeNode);</span><br><span class="line">    inorder(treeNode.rightNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backorder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    backorder(treeNode.leftNode);</span><br><span class="line">    backorder(treeNode.rightNode);</span><br><span class="line">    System.out.println(treeNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backOrderDfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        TreeNode right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root.right == <span class="keyword">null</span> || root.right == right) &#123;</span><br><span class="line">            System.out.print(root.val);</span><br><span class="line">            right = root;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="层序遍历-广度优先遍历"><a href="#层序遍历-广度优先遍历" class="headerlink" title="层序遍历|广度优先遍历"></a>层序遍历|广度优先遍历</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode tree = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (tree.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(tree.leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(tree.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">        lists.add(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>计算二叉树的深度可以通过后序遍历和层序遍历计算二叉树的深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.leftNode), maxDepth(root.rightNode)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepthBfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        maxDepth++;</span><br><span class="line">        <span class="keyword">int</span> len = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            TreeNode treeNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (treeNode.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(treeNode.leftNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(treeNode.rightNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepthBfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> minDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> minDepth + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        minDepth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> diameter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameter</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> diameter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = depth(treeNode.leftNode);</span><br><span class="line">    <span class="keyword">int</span> right = depth(treeNode.rightNode);</span><br><span class="line">    diameter = Math.max(left + right, diameter);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="镜像二叉树转换"><a href="#镜像二叉树转换" class="headerlink" title="镜像二叉树转换"></a>镜像二叉树转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode tmp = root.left;</span><br><span class="line">    root.left = mirrorTree(root.right);</span><br><span class="line">    root.right = mirrorTree(tmp);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode treeNode = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(treeNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(treeNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tmp = treeNode.left;</span><br><span class="line">        treeNode.left = treeNode.right;</span><br><span class="line">        treeNode.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称二叉树判断"><a href="#对称二叉树判断" class="headerlink" title="对称二叉树判断"></a>对称二叉树判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span> || p.val != q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">    t1.val += t2.val;</span><br><span class="line">    t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长相同直径"><a href="#最长相同直径" class="headerlink" title="最长相同直径"></a>最长相同直径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traversal(root);</span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">traversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = traversal(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = traversal(root.right);</span><br><span class="line">    <span class="keyword">int</span> arrowLeft = <span class="number">0</span>, arrowRight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.val == root.val) &#123;</span><br><span class="line">        arrowLeft += left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.right.val == root.val) &#123;</span><br><span class="line">        arrowRight += right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    longest = Math.max(longest, arrowLeft + arrowRight);</span><br><span class="line">    <span class="keyword">return</span> Math.max(arrowLeft, arrowRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><p>根据 left 和 right ，可展开为四种情况；</p><ul><li><p>当left和right同时为空 ：说明root的左 / 右子树中都不包含 p,q，返回 null；</p></li><li><p>当left和right同时不为空 ：说明 p, q分列在root的 异侧 ，因此 root为最近公共祖先，返回 root；</p></li><li><p>当left为空 ，right 不为空 ：p,q都不在 root的左子树中，直接返回 right。具体可分为两种情况：</p><ul><li>p,q其中一个在root的 右子树中，此时right指向p；</li><li>p,q两节点都在 root的 右子树中，此时的 right指向最近公共祖先节点 ；</li></ul></li><li><p>当 left不为空 ， right为空 同理；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过前序中序创建树"><a href="#通过前序中序创建树" class="headerlink" title="通过前序中序创建树"></a>通过前序中序创建树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span> || preorder.length != inorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        indexMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTrav(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, indexMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTrav</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> inLeft, Map&lt;Integer, Integer&gt; indexMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preLeft &gt; preRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">    <span class="keyword">if</span> (preLeft == preRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rootIndex = indexMap.get(preorder[preLeft]);</span><br><span class="line">    <span class="keyword">int</span> leftNodes = rootIndex - inLeft;</span><br><span class="line">    root.left = buildTrav(preorder, preLeft + <span class="number">1</span>, leftNodes + preLeft, inLeft, indexMap);</span><br><span class="line">    root.right = buildTrav(preorder, preLeft + leftNodes + <span class="number">1</span>, preRight, rootIndex + <span class="number">1</span>, indexMap);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span> || preorder.length != inorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">int</span> inorderIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preorderVal = preorder[i];</span><br><span class="line">        TreeNode node = stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                inorderIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            node.right = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过中序后序创建树"><a href="#通过中序后序创建树" class="headerlink" title="通过中序后序创建树"></a>通过中序后序创建树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> postIndex;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder == <span class="keyword">null</span> || postorder == <span class="keyword">null</span> || inorder.length == <span class="number">0</span> || inorder.length != postorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postIndex = inorder.length - <span class="number">1</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        indexMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTreeTrav(postorder, <span class="number">0</span>, postIndex, indexMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeTrav</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight, Map&lt;Integer, Integer&gt; indexMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inLeft &gt; inRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postIndex]);</span><br><span class="line">    postIndex--;</span><br><span class="line">    <span class="keyword">int</span> rootIndex = indexMap.get(root.val);</span><br><span class="line">    root.right = buildTreeTrav(postorder, rootIndex + <span class="number">1</span>, inRight, indexMap);</span><br><span class="line">    root.left = buildTreeTrav(postorder, inLeft, rootIndex - <span class="number">1</span>, indexMap);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过前序后序创建树"><a href="#通过前序后序创建树" class="headerlink" title="通过前序后序创建树"></a>通过前序后序创建树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> constructFromPrePostTrav(pre, post, <span class="number">0</span>, <span class="number">0</span>, pre.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePostTrav</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preLeft]);</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; L &lt; N; ++L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (post[preRight + L - <span class="number">1</span>] == pre[preLeft + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.left = constructFromPrePostTrav(pre, post, preLeft + <span class="number">1</span>, preRight, L);</span><br><span class="line">    root.right = constructFromPrePostTrav(pre, post, preLeft + L + <span class="number">1</span>, preRight + L, N-L-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                k = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span> &amp;&amp; node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个节点有&lt;strong&gt;零个&lt;/strong&gt;或&lt;strong&gt;多个&lt;/strong&gt;子节点；&lt;/li&gt;
&lt;li&gt;没有父节点的
      
    
    </summary>
    
      <category term="算法" scheme="https://yaoyinglong.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://yaoyinglong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://yaoyinglong.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>幽默感</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E5%B9%BD%E9%BB%98%E6%84%9F/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/幽默感/</id>
    <published>2020-06-20T16:00:00.000Z</published>
    <updated>2020-06-21T13:03:03.447Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库常面问题</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E9%9D%A2%E9%97%AE%E9%A2%98/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/数据库常面问题/</id>
    <published>2020-06-18T16:00:00.000Z</published>
    <updated>2020-08-10T01:29:52.609Z</updated>
    
    <content type="html"><![CDATA[<ol><li>B+树的定义</li><li>InnoDB中的“页”</li><li>InnoDB中主键索引生成过程</li><li>InnoDB中联合索引生成过程</li><li>索引实战与优化</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;B+树的定义&lt;/li&gt;
&lt;li&gt;InnoDB中的“页”&lt;/li&gt;
&lt;li&gt;InnoDB中主键索引生成过程&lt;/li&gt;
&lt;li&gt;InnoDB中联合索引生成过程&lt;/li&gt;
&lt;li&gt;索引实战与优化&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
</feed>
