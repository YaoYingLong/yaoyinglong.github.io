<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YingLong</title>
  
  <subtitle>虽奔放不羁，但也自我束缚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoyinglong.github.io/"/>
  <updated>2021-04-28T07:22:05.807Z</updated>
  <id>https://yaoyinglong.github.io/</id>
  
  <author>
    <name>YaoYingLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>命令模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/命令模式/</id>
    <published>2021-04-19T16:00:00.000Z</published>
    <updated>2021-04-28T07:22:05.807Z</updated>
    
    <content type="html"><![CDATA[<p>命令模式是一个高内聚的模式 ，将一个请求封装成一个对象， 从而让你使用不同的请求把客户端参数化， 对请<br>求排队或者记录请求日志， 可以提供命令的撤销和恢复功能 。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;命令模式是一个高内聚的模式 ，将一个请求封装成一个对象， 从而让你使用不同的请求把客户端参数化， 对请&lt;br&gt;求排队或者记录请求日志， 可以提供命令的撤销和恢复功能 。&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，命令模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/中介者模式/</id>
    <published>2021-04-18T16:00:00.000Z</published>
    <updated>2021-04-19T07:43:20.096Z</updated>
    
    <content type="html"><![CDATA[<p>常常会出现好多对象之间存在<strong>复杂的交互关系</strong>，这种交互关系常常是<strong>网状结构</strong>，它要求每个对象都必须知道它需要交互的对象。若把这种<strong>网状结构</strong>改为<strong>星形结构</strong>的话，将大大降低它们之间的<strong>耦合性</strong>，这时只要找一个<strong>中介者</strong>就可以了。</p><p>定义一个中介对象来封装一系列对象之间的交互，中介者使各对象不需要显示地相互作用 ，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。<strong>中介者模式</strong>又叫<strong>调停模式</strong>，它是<strong>迪米特法则的典型应用</strong>。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>中介者模式由<strong>抽象中介者</strong>、<strong>具体中介者</strong>、<strong>抽象同事</strong>、<strong>具体同事</strong>几个主要角色。</p><p><strong>抽象中介者</strong>：定义统一的接口， 用于各同事角色之间的通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义同事类</span></span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleague1 c1;</span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleague2 c2;</span><br><span class="line">    <span class="comment">//中介者模式的业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体中介者</strong>：通过协调各同事角色实现协作行为， 因此它必须依赖于各个同事角色 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.c1.selfMethod1();</span><br><span class="line">        <span class="keyword">super</span>.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.c1.selfMethod1();</span><br><span class="line">        <span class="keyword">super</span>.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象同事类</strong>：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体同事类</strong>：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互，每个同事角色都知道中介者角色， 且与其他同事角色通信时， 一定要通过中介者角色协作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague1</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">        <span class="comment">//自己不能处理的业务逻辑， 委托给中介者处理</span></span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague2</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">        <span class="comment">//自己不能处理的业务逻辑， 委托给中介者处理</span></span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomething2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>类之间各司其职，符合迪米特法则</p><p>降低了对象之间的耦合性，使得对象易于独立地被复用</p><p>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在<code>MVC</code>框架中，控制器（C）就是模型（M）和视图（V）的中介者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常常会出现好多对象之间存在&lt;strong&gt;复杂的交互关系&lt;/strong&gt;，这种交互关系常常是&lt;strong&gt;网状结构&lt;/strong&gt;，它要求每个对象都必须知道它需要交互的对象。若把这种&lt;strong&gt;网状结构&lt;/strong&gt;改为&lt;strong&gt;星形结构&lt;/strong
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，中介者模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/创建型模式/原型模式/</id>
    <published>2021-04-07T16:00:00.000Z</published>
    <updated>2021-04-08T10:26:12.777Z</updated>
    
    <content type="html"><![CDATA[<p>用一个已经创建的实例作为原型，<strong>通过复制该原型对象来创建一个和原型相同或相似的新对象</strong>。用这种方式创建对象非常高效，无须知道对象创建的细节。</p><p>在实际项目中，原型模式很少单独出现，一般是和<strong>工厂方法模式</strong>一起出现， 通过<code>clone</code>的方法创建一个对象，然后由工厂方法提供给调用者。 </p><p>原型模式简单程度仅次于<strong>单例模式</strong>和<strong>迭代器模式</strong>，<code>Java</code>中的<code>Object</code>类提供了浅克隆的<code>clone()</code>方法，具体原型类只要实现<strong><code>Cloneable</code></strong>接口就可实现对象的浅克隆。<code>Cloneable</code> 接口只是一个<strong>标记</strong>作用， 在<code>JVM</code>中具有这个标记的对象才有可能被拷贝。 </p><p><img src="../../../../images/设计模式/原型模式结构图.png" alt="原型模式结构图"></p><p>原型模式的克隆分为浅克隆和深克隆</p><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thing</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thing thing = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thing = (Thing) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thing</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thing thing = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thing = (Thing) <span class="keyword">super</span>.clone();</span><br><span class="line">            thing.arrayList = (ArrayList&lt;String&gt;)<span class="keyword">this</span>.arrayList.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象的<code>clone</code>与对象内的<code>final</code>关键字是有冲突的 ，要使用<code>clone</code>方法， 类的成员变量上不要增加<code>final</code>关键字</strong>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><code>Java</code>自带的原型模式基于内存二进制流的复制，在性能上比直接new一个对象更加优良，特别是要在一<br>个循环体内产生大量的对象时</p><p>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用。</p><p><strong>逃避构造函数的约束</strong>，直接在内存中拷贝， 构造函数是不会执行的</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>需要为每一个类都配置一个<strong><code>clone</code></strong>方法</p><p>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则</p><p>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>对象之间相同或相似，即只是个别的几个属性不同的时候</p><p>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源</p><p>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性</p><p>系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值</p><p>一个对象需要提供给其他对象访问， 而且各个调用者可能都需要修改其值时， 可以考虑使用原型模式拷贝多个对象供调用者使用 </p><p><code>JDK</code>源码中 <code>ArrayList</code>的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用一个已经创建的实例作为原型，&lt;strong&gt;通过复制该原型对象来创建一个和原型相同或相似的新对象&lt;/strong&gt;。用这种方式创建对象非常高效，无须知道对象创建的细节。&lt;/p&gt;
&lt;p&gt;在实际项目中，原型模式很少单独出现，一般是和&lt;strong&gt;工厂方法模式&lt;/strong
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，原型模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E9%9A%90%E5%BD%A2%E7%9C%BC%E9%95%9C%E6%94%BB%E7%95%A5/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/隐形眼镜攻略/</id>
    <published>2021-01-28T06:49:56.328Z</published>
    <updated>2021-01-28T07:18:47.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="隐形眼镜攻略"><a href="#隐形眼镜攻略" class="headerlink" title="隐形眼镜攻略"></a>隐形眼镜攻略</h1><h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p>硅水凝胶已经是目前主流材质，各方面参数、安全性、透氧性都远远好于水凝胶</p><p>新—水凝胶</p><h3 id="品牌"><a href="#品牌" class="headerlink" title="品牌"></a>品牌</h3><p>视康爱尔康、库博、强生安视优、博士伦</p><h3 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h3><p>为了更健康的使用隐形眼镜，请选用<strong>短周期产品</strong>，避免使用年抛、半年抛、季抛等传统产品，选择月抛、双周抛和日抛产品，减少因蛋白质、脂质沉淀或镜片发生的破损引发的问题，同时长周期镜片大多都是使用低含水量，较硬的HEMA材质，透氧性较差，很多产品远达不到足够的安全佩戴含氧量，长期佩戴必然会导致眼红、干涩、甚至引发更严重的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;隐形眼镜攻略&quot;&gt;&lt;a href=&quot;#隐形眼镜攻略&quot; class=&quot;headerlink&quot; title=&quot;隐形眼镜攻略&quot;&gt;&lt;/a&gt;隐形眼镜攻略&lt;/h1&gt;&lt;h3 id=&quot;材质&quot;&gt;&lt;a href=&quot;#材质&quot; class=&quot;headerlink&quot; title=&quot;材质&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="自度" scheme="https://yaoyinglong.github.io/categories/%E8%87%AA%E5%BA%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>2020总结</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/2020%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/2020总结/</id>
    <published>2021-01-25T16:00:00.000Z</published>
    <updated>2021-01-22T02:12:02.393Z</updated>
    
    <content type="html"><![CDATA[<p>之前没有写年终总结的习惯，但是今年发生了太多的事，对于我而言算是意义非凡的一年吧。</p><p>总的来说今年算是梦幻开局，平淡结束吧。</p><p>去年底和今年初疫情的原因，开始有点人心惶惶，但是过年没法走亲戚以及开年延迟上班在家办公对于一个宅男来说算是一种慰藉。</p><p>今年经历了曾经从来没有经历过的事，虽然最后还是以失败告终，不去追究谁对谁错，每个人都有自己的选择，有些是没有经历过真的是不太懂，失去过后才来后悔，在那段时间里我不断自我反省，到处寻找答案，甚至买了好几本书看，渐渐的可能找到了一些答案吧。这段经历使我成长了好多好多，撞碎了一些我以为的思想。不再对任何人任何事一开始抱有比较高的期望，逐渐明悟自己想要的是什么，对待感情不再那么执着较真。</p><p>为了转移注意力开始学习，买了差不多二三十本专业的书来看，去LeetCode刷题。</p><p>感谢一路上有人一直带我走出我自己的世界，面对真实的自己，人前人后展现更加真实的自己。可能很多人对我有比较大的误解，觉得我没什么主见什么都听别人的感觉，在意一个人的时候很容易全部注意力都在她身上，总是把她的一举一动一言一行看得很重要所以很容易失去了自我，显得自己很没有主见，</p><p>曾经我是一个极度容易尴尬的人，经过今年的成长，参加了很多活动，内心平静自然多了。</p><p>每次要写点东西的时候总是感觉有好多东西要说，但是真正写的时候又说不出来什么，感觉好像很多事又不值得一说反正也就那样。2020就这样潦草结尾吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前没有写年终总结的习惯，但是今年发生了太多的事，对于我而言算是意义非凡的一年吧。&lt;/p&gt;
&lt;p&gt;总的来说今年算是梦幻开局，平淡结束吧。&lt;/p&gt;
&lt;p&gt;去年底和今年初疫情的原因，开始有点人心惶惶，但是过年没法走亲戚以及开年延迟上班在家办公对于一个宅男来说算是一种慰藉。&lt;/p
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/结构型模式/代理模式/</id>
    <published>2020-11-04T16:00:00.000Z</published>
    <updated>2021-04-09T06:08:06.870Z</updated>
    
    <content type="html"><![CDATA[<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>代理模式是一个使用率非常高的模式，<strong>为其他对象提供一种代理以控制这个对象的访问</strong>。代理模式也叫做<strong>委托模式</strong>，它是一项<strong>基本设计技巧</strong>。许多其他的模式，如<strong>状态模式</strong>、<strong>策略模式</strong>、<strong>访问者模式</strong>本质上是在<strong>更特殊的场合</strong>采用了<strong>委托模式</strong>，而且在日常的应用中，代理模式可以提供非常好的访问控制。</p><p><img src="../../../../images/设计模式/代理模式类图.png" alt="代理模式类图"></p><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问；</p><p>抽象主题类<strong><code>Subject</code></strong>通过<strong>接口</strong>或<strong>抽象类</strong>声明<strong>真实主题</strong>和<strong>代理对象</strong>实现的业务方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实主题类<code>RealSubject</code>实现了<strong>抽象主题中的具体业务</strong>，是代理对象所代表的真实对象，是最终要引用的对象，为<strong>具体主题角色</strong>，也叫<strong>被委托角色</strong>或<strong>被代理角色</strong>，是<strong>业务逻辑的具体执行者</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类<code>Proxy</code>提供了<strong>与真实主题相同的接口</strong>，其内部<strong>含有对真实主题的引用</strong>，它可以<strong>访问</strong>、<strong>控制</strong>或<strong>扩展</strong>真实主题的功能，也叫<strong>委托类</strong>或<strong>代理类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before();</span><br><span class="line">        <span class="keyword">this</span>.subject.request();</span><br><span class="line">        <span class="keyword">this</span>.after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知；一个代理类可以<strong>代理多个</strong>被委托者或被代理者， 因此一个代理类具体代理哪个真实主题角色， 是由场景类决定。 </p><p>代理模式优点<strong>职责清晰</strong>，真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务；<strong>高扩展性</strong>；<strong>智能化</strong>。</p><p>根据代理的创建时期，代理模式分为<strong>静态代理</strong>和<strong>动态代理</strong>，还可以通过<strong>反射</strong>的方式实现<strong><a href="../../Java/基础/动态代理">动态代理</a></strong></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</p><p>可以扩展目标对象的功能</p><p>能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>会造成系统设计中类的数量增加</p><p>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢</p><p>增加了系统的复杂度</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：<strong>保护目标对象</strong>，<strong>增强目标对象</strong>。</p><ul><li>远程代理，通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。</li><li>虚拟代理，通常用于要创建的目标对象开销很大时。</li><li>安全代理，通常用于控制不同种类客户对真实对象的访问权限。</li><li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。</li><li>延迟加载，指为了提高系统的性能，延迟对目标的加载。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于某些原因需要给某对象提供一个代理以控制对该对象的访问。访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。&lt;/p&gt;
&lt;p&gt;代理模式是一个使用率非常高的模式，&lt;strong&gt;为其他对象提供一种代理以控制这个对象的访问&lt;/strong&gt;。代理模
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，代理模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/创建型模式/建造者模式/</id>
    <published>2020-11-03T16:00:00.000Z</published>
    <updated>2021-04-06T02:48:47.440Z</updated>
    
    <content type="html"><![CDATA[<p><strong>建造者模式</strong>也叫<strong>生成器模式</strong>，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<strong>当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。</strong></p><p><img src="../../../../images/设计模式/建造者模式类图.png" alt="建造者模式类图"></p><p>车辆模型抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; sequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequence = sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String actionName : sequence) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"stop"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"alarm"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.alarm();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"engineBoom"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.engineBoom();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>车辆模型的具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzModel</span> <span class="keyword">extends</span> <span class="title">CarModel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz开动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz停车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz鸣笛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz发动引擎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWModel</span> <span class="keyword">extends</span> <span class="title">CarModel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW开动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW停车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW鸣笛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW发动引擎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象汽车的组装者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; seqence)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CarModel <span class="title">getCarModel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的车的组装者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzBuilder</span> <span class="keyword">extends</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BenzModel benz = <span class="keyword">new</span> BenzModel();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.benz.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CarModel <span class="title">getCarModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.benz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWBuilder</span> <span class="keyword">extends</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BMWModel bmw = <span class="keyword">new</span> BMWModel();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bmw.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CarModel <span class="title">getCarModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bmw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">sequence.add(<span class="string">"engineBoom"</span>);</span><br><span class="line">sequence.add(<span class="string">"start"</span>);</span><br><span class="line">sequence.add(<span class="string">"stop"</span>);</span><br><span class="line">BenzBuilder benzBuilder = <span class="keyword">new</span> BenzBuilder();</span><br><span class="line">benzBuilder.setSequence(sequence);</span><br><span class="line">BenzModel benz = (BenzModel)benzBuilder.getCarModel();</span><br><span class="line">benz.run();</span><br><span class="line">BMWBuilder bmwBuilder = <span class="keyword">new</span> BMWBuilder();</span><br><span class="line">bmwBuilder.setSequence(sequence);</span><br><span class="line">BMWModel bmw = (BMWModel)bmwBuilder.getCarModel();</span><br><span class="line">bmw.run();</span><br></pre></td></tr></table></figure><p><code>CarModel</code>及其之类都是产品类，<code>CarBuilder</code>是抽象的建造者，用于规范产品的组建，其子类是具体的建造者，实现抽象类定义的所有，并返回一个组建好的对象。</p><p>建造者模式有良好的<strong>封装性</strong>，使用建造者模式可以使客户端不必知道产品内部组成的细节，建造者是独立的<strong>容易扩展</strong>，因此也<strong>便于控制细节风险</strong>，对建造过程逐步细化，而不对其他的模式产生任何影响。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>相同的方法，不同的执行顺序</strong>，产生不同的事件结果时。</li><li><strong>多个部件或零件，都可以装配到一个对象中</strong>，但是产生的<strong>运行结果又不相同</strong>时。</li><li><strong>产品类非常复杂</strong>，或者产品类中的<strong>调用顺序</strong>不同产生了不同的效能。</li><li>在对象创建过程中会<strong>使用到系统中的一些其他对象</strong>，这些对象在产品对象的<strong>创建过程中不易得到</strong>时，也可以采用建造者模式封装该对象的创建过程，该种场景只能是一个补偿方法。</li></ul><h3 id="与工厂模式的区别"><a href="#与工厂模式的区别" class="headerlink" title="与工厂模式的区别"></a>与工厂模式的区别</h3><p><strong>建造者模式</strong>最主要的功能是<strong>基本方法的调用顺序安排</strong>，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同；而<strong>工厂方法</strong>则重点是<strong>创建</strong>，创建零件是它的主要职责，组装顺序则不是它关心的。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;建造者模式&lt;/strong&gt;也叫&lt;strong&gt;生成器模式&lt;/strong&gt;，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;strong&gt;当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。&lt;/
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，建造者模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/模板方法模式/</id>
    <published>2020-11-02T16:00:00.000Z</published>
    <updated>2021-04-06T01:42:09.059Z</updated>
    
    <content type="html"><![CDATA[<p><strong>模板方法模式</strong>非常简单应用非常广泛的模式，定义一个操作中的<strong>算法框架</strong>，而将一些步骤<strong>延迟到子类</strong>中。使得子类可以<strong>不改变一个算法的结构</strong>即可重定义该算法的某些特定步骤。</p><p><img src="../../../../images/设计模式/模板方法模式类图.png" alt="模板方法模式类图"></p><p><code>AbstractClass</code>叫做<strong>抽象模板</strong>，其方法分为<strong>基本方法</strong>和<strong>模板方法</strong>两类。<strong>基本方法</strong>也叫做基本操作，由子类实现的方法，且在模板方法中被调用。<strong>模板方法</strong>可以有一个或几个，用于实现对基本方法的调度，完成固定的逻辑。为了防止恶意操作，一般模板方法都使用<code>final</code>关键之修饰，防止被覆盖。</p><p>抽象模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareGotoSchool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        derssUp();</span><br><span class="line">        eatBreakfast();</span><br><span class="line">        tackThings();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">derssUp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">tackThings</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">derssUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿衣服"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃妈妈做的早餐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tackThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"背书包，带上家庭作业和红领巾"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">derssUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿工作服"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"做早饭，照顾孩子吃早饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tackThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带上昨天晚上准备的考卷"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.prepareGotoSchool();</span><br><span class="line">Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">teacher.prepareGotoSchool();</span><br></pre></td></tr></table></figure><p><strong>抽象模板</strong>中的<strong>基本方法</strong>尽量设计为<code>protected</code>类型，符合<strong>迪米特法则</strong>，不需要暴露的属性或方法尽量不要设置为protected类型。实现类若非必要，尽量不要扩大父类中的访问权限。 </p><p>模板方法模式可<strong>封装不变部分</strong>，<strong>扩展可变部分</strong>；可提取公共部分代码，便于维护；<strong>行为由父类控制，子类实现</strong>。但一般的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，<strong>子类执行的结果影响了父类的结果</strong>，也就是子类对父类产生了影响，在复杂的项目中，会带来代码阅读的难度。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>多个子类有公有的方法，且逻辑基本相同时</li><li>重要、复杂的算发，可以把核心算法设计为模板方法，周边的相关细节功能由各个子类实现</li><li>重构时，模板方法模式时一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为</li></ul><p>在Spring源码中<strong><code>refresh()</code></strong>就是典型的模板方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span>, <span class="title">ifecycle</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.refresh"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            prepareRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">                StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.beans.post-process"</span>);</span><br><span class="line">                <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line">                beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                initMessageSource();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                onRefresh();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                registerListeners();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                                <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">                destroyBeans();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">                <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">                resetCommonCaches();</span><br><span class="line">                contextRefresh.end();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>JDK</code></strong>中<strong><code>HashMap</code></strong>、<strong><code>Map</code></strong>、<strong><code>AQS</code></strong>中都有用到模板方法设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS中用到的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK8 Map中的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">return</span> (((v = get(key)) != <span class="keyword">null</span>) || containsKey(key))</span><br><span class="line">        ? v : defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt;非常简单应用非常广泛的模式，定义一个操作中的&lt;strong&gt;算法框架&lt;/strong&gt;，而将一些步骤&lt;strong&gt;延迟到子类&lt;/strong&gt;中。使得子类可以&lt;strong&gt;不改变一个算法的结构&lt;/strong&gt;即可重定义该算
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，模板方法模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/创建型模式/工厂模式/</id>
    <published>2020-11-02T16:00:00.000Z</published>
    <updated>2020-11-03T08:00:50.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><strong>工厂方法模式</strong>使用的频率非常高 ，用于创建对象的接口， 让<strong>子类</strong>决定实例化哪一个类。 工厂方法使一个<strong>类的实例化延迟到其子类</strong> 。用于<strong>封装</strong>和<strong>管理</strong>对象的创建，是一种<strong>创建模式</strong>。是<strong>典型的解耦框架</strong>，在需要<strong>灵活的</strong>、<strong>可扩展</strong>的框架时可以采用，可以用在<strong>异构项目</strong>中，可以使用在测试驱动的开发框架下。</p><p><img src="../../../../images/设计模式/工厂方法模式类图.png" alt="工厂方法模式类图"></p><p>抽象产品类，抽象人种类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的产品类可以有多个， 都继承于抽象产品类，具体的人种类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YellowHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂类负责定义产品对象的产生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体如何产生一个产品的对象， 是由具体的工厂类实现的，具体的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"人种生成错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AbstractHumanFactory YinYangLu = <span class="keyword">new</span> HumanFactory();</span><br><span class="line">Human whiteHuman = YinYangLu.createHuman(WhiteHuman.class);</span><br><span class="line">whiteHuman.getColor();</span><br><span class="line">whiteHuman.talk();</span><br><span class="line">Human blackHuman = YinYangLu.createHuman(BlackHuman.class);</span><br><span class="line">blackHuman.getColor();</span><br><span class="line">blackHuman.talk();</span><br><span class="line">Human yellowHuman = YinYangLu.createHuman(YellowHuman.class);</span><br><span class="line">yellowHuman.getColor();</span><br><span class="line">yellowHuman.talk();</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>良好的<strong>封装性</strong>， 代码结构清晰</li><li>良好的<strong>扩展性</strong>，增加产品类， 只要适当地修改具体的工厂类或扩展一个工厂类</li><li><strong>屏蔽产品类</strong>，产品类的实现如何变化， 调用者都不需要关心，上层模块不发生变化</li><li>典型的<strong>解耦框架</strong>，高层模块值需要知道产品的抽象类，符合迪米特法则、依赖倒置原则、里氏替换原则</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>需要<strong>生成对象</strong>的地方都可以使用， 但是需要慎重考虑是否要增加一个工厂类进行管理， 增加代码的复杂度</li><li>需要<strong>灵活</strong>的、 <strong>可扩展</strong>的框架时</li><li><strong>异构项目中</strong>，如通过<code>WebService</code>与一个非Java的项目交互 </li><li>可以使用在<strong>测试驱动开发的框架下</strong></li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>工厂方法模式有很多扩展，且与其他模式结合使用威力更大，可将其<strong>缩小为简单工厂模式</strong>，可<strong>升级为多个工厂类</strong>，可<strong>替代单例模式</strong>，可<strong>延迟初始化</strong>。</p><h4 id="缩小为简单工厂模式"><a href="#缩小为简单工厂模式" class="headerlink" title="缩小为简单工厂模式"></a>缩小为简单工厂模式</h4><p>该模式是工厂方法模式的弱化，<strong>简单工厂模式</strong>又叫<strong>静态工厂模式</strong>，仅简单的对<strong>不同类</strong>对象的创建进行了简单的封装。<strong>缺点</strong>是<strong>工厂类的扩展比较困难</strong>， <strong>不符合开闭原则</strong>。 </p><p><img src="../../../../images/设计模式/简单工厂模式类图.png" alt="简单工厂模式类图"></p><p>简单工厂模式相对于工厂方法模式，去掉了<code>AbstractHumanFactory</code>抽象类， 同时把<code>createHuman</code>方法设置为静态类型， 简化了类的创建过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"人种生成错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Human whiteHuman = HumanFactory.createHuman(WhiteHuman.class);</span><br><span class="line">whiteHuman.getColor();</span><br><span class="line">whiteHuman.talk();</span><br><span class="line">Human blackHuman = HumanFactory.createHuman(BlackHuman.class);</span><br><span class="line">blackHuman.getColor();</span><br><span class="line">blackHuman.talk();</span><br><span class="line">Human yellowHuman = HumanFactory.createHuman(YellowHuman.class);</span><br><span class="line">yellowHuman.getColor();</span><br><span class="line">yellowHuman.talk();</span><br></pre></td></tr></table></figure><h4 id="升级为多个工厂类"><a href="#升级为多个工厂类" class="headerlink" title="升级为多个工厂类"></a>升级为多个工厂类</h4><p>在相对比较复杂的项目中，经常遇到初始化一个对象很耗费精力的情况，所有产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为每个产品定义一个创造者， 然后由调用者自己去选择与哪个工厂方法关联。</p><p><strong>多工厂模式</strong>的工厂抽象类，抽象方法中已经<strong>不再需要传递相关参数</strong>了， 因为每一个具体的工厂都已经非常明确自己的职责。但也给<strong>可扩展性</strong>和<strong>可维护性</strong>带来了一定的影响。</p><p><img src="../../../../images/设计模式/多个工厂类类图.png" alt="多个工厂类类图"></p><p>多工厂模式的抽象工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Human <span class="title">createHuman</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>黑色人种的创建工厂实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackHumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>黄色人种的创建工厂实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YellowHumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>白色人种的创建工厂实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteHumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Human whiteHuman = (<span class="keyword">new</span> WhiteHumanFactory()).createHuman();</span><br><span class="line">whiteHuman.getColor();</span><br><span class="line">whiteHuman.talk();</span><br><span class="line">Human blackHuman = (<span class="keyword">new</span> BlackHumanFactory()).createHuman();</span><br><span class="line">blackHuman.getColor();</span><br><span class="line">blackHuman.talk();</span><br><span class="line">Human yellowHuman = (<span class="keyword">new</span> YellowHumanFactory()).createHuman();</span><br><span class="line">yellowHuman.getColor();</span><br><span class="line">yellowHuman.talk();</span><br></pre></td></tr></table></figure><p>在复杂的应用中一般采用多工厂的方法， 然后再增加一个协调类， 避免调用者与各个子工厂交流， 协调类的作用是封装子工厂类， 对高层模块提供统一的访问接口。</p><h4 id="替代单例模式"><a href="#替代单例模式" class="headerlink" title="替代单例模式"></a>替代单例模式</h4><p>通过获得类构造器， 然后设置访问权限， 生成一个对象， 然后提供外部访问， 保证内存中的对象唯一。 通过工厂方法模式创建了一个单例对象， 该框架可以继续扩展， 在一个项目中可以产生一个<strong>单例构造器</strong>， 所有需要产生单例的类都遵循一定的规则 ， 然后通过扩展该框架。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cl= Class.forName(Singleton.class.getName());</span><br><span class="line">            <span class="comment">// 获得无参构造</span></span><br><span class="line">            Constructor constructor = cl.getDeclaredConstructor();</span><br><span class="line">            <span class="comment">// 设置无参构造是可访问的</span></span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 产生一个实例对象</span></span><br><span class="line">            singleton = (Singleton)constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h4><p>一个对象被消费完后，并不立即释放，工厂类保持其初始状态，等待再次被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Human&gt; humanMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Human <span class="title">createHuman</span><span class="params">(String type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Human human;</span><br><span class="line">        <span class="keyword">if</span> (humanMap.containsKey(type)) &#123;</span><br><span class="line">            human = humanMap.get(type);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (type.equals(<span class="string">"BlackHuman"</span>)) &#123;</span><br><span class="line">                human = <span class="keyword">new</span> BlackHuman();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"WhiteHuman"</span>)) &#123;</span><br><span class="line">                human = <span class="keyword">new</span> WhiteHuman();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                human = <span class="keyword">new</span> YellowHuman();</span><br><span class="line">            &#125;</span><br><span class="line">            humanMap.put(type, human);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> human;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟加载框架是可扩展的， 例如限制某一个产品类的最大实例化数量， 可以通过判断Map中已有的对象数量来实现，还可以用在<strong>对象初始化比较复杂</strong>的情况下， 例如<strong>硬件访问</strong>， 涉及多方面的交互， 则可以通过延迟加载降低对象的<strong>产生和销毁</strong>带来的<strong>复杂性</strong>。</p><hr><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>抽象工厂模式</strong>是一种比较常用的模式，为创建一组<strong>相关</strong>或<strong>相互依赖</strong>的对象提供一个接口， 且<strong>无须指定它们</strong><br><strong>的具体类</strong>。 当一个对象族有相同的约束时可以使用抽象工厂模式。</p><p>优点<strong>封装性</strong>，产品的具体实现细节高层模块不需要关心；产品族内的约束为<strong>非公开</strong>状态。缺点<strong>产品族扩展非常困难</strong>，严重违反开闭原则。</p><p><img src="../../../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="抽象工厂模式类图"></p><p><strong>抽象工厂模式</strong>是<strong>工厂方法模式</strong>的<strong>升级版</strong>， 在有多个业务品种、 业务分类时， 通过抽象工厂模式产生需要的对象是一种非常好的解决方式。</p><p>人种接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人种有三个抽象类， 负责人种的抽象属性定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBlackHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractWhiteHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractYellowHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个抽象类都有两个实现类， 分别实现公共的最细节、 最具体的事物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleYellowHuman</span> <span class="keyword">extends</span> <span class="title">AbstractYellowHuman</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄种女人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaleYellowHuman</span> <span class="keyword">extends</span> <span class="title">AbstractYellowHuman</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄种男人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>制造人类的抽象工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Human <span class="title">createYellowHuman</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Human <span class="title">createWhiteHuman</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Human <span class="title">createBlackHuman</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>制造男人和女人的具体工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleFactory</span> <span class="keyword">implements</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createYellowHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FemaleYellowHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createWhiteHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FemaleWhiteHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createBlackHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FemaleBlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaleFactory</span> <span class="keyword">implements</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createYellowHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleYellowHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createWhiteHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleWhiteHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createBlackHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleBlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HumanFactory maleHumanFactory = <span class="keyword">new</span> MaleFactory();</span><br><span class="line">HumanFactory femaleHumanFactory = <span class="keyword">new</span> FemaleFactory();</span><br><span class="line">Human maleYellowHuman = maleHumanFactory.createYellowHuman();</span><br><span class="line">Human femaleYellowHuman = femaleHumanFactory.createYellowHuman();</span><br><span class="line">femaleYellowHuman.getColor();</span><br><span class="line">femaleYellowHuman.talk();</span><br><span class="line">femaleYellowHuman.getSex();</span><br><span class="line">maleYellowHuman.getColor();</span><br><span class="line">maleYellowHuman.talk();</span><br><span class="line">maleYellowHuman.getSex();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工厂方法模式&quot;&gt;&lt;a href=&quot;#工厂方法模式&quot; class=&quot;headerlink&quot; title=&quot;工厂方法模式&quot;&gt;&lt;/a&gt;工厂方法模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;工厂方法模式&lt;/strong&gt;使用的频率非常高 ，用于创建对象的接口， 让&lt;strong&gt;子
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，工厂方法模式，抽象工厂模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>锁优化</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/锁优化/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2020-10-30T06:43:58.459Z</updated>
    
    <content type="html"><![CDATA[<p><strong>高效并发</strong>是从<code>JDK1.5</code>到<code>JDK1.6</code>的一个重要改进，<code>HotSpot</code>虚拟机为了<strong>在线程之间更高效地共享数据</strong>，以及<strong>解决竞争问题</strong>，从而<strong>提高程序的执行效率</strong>在该版本上花费了大量精力去<strong>实现各种锁优化技术</strong>，如<strong>适应性自旋</strong>、<strong>锁消除</strong>、<strong>锁粗化</strong>、<strong>轻量级锁</strong>和<strong>偏向锁</strong>等。</p><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p><strong>互斥同步</strong>对<strong>性能最大的影响</strong>是<strong>阻塞的实现</strong>，<strong>挂起线程</strong>和<strong>恢复线程</strong>的操作都需要转入<strong>内核态</strong>中完成，这会给操作系统的并发性能带来很大的压力。在许多应用上，<strong>共享数据的锁定状态只会持续很短一段时间</strong>，为了这段时间去<strong>挂起</strong>和<strong>恢复</strong>线程<strong>并不值得</strong>。</p><p>两个或以上的线程同时并行执行，可以让后面请求锁的那个线程<strong>不放弃处理器执行时间</strong>，而是<strong>执行一个忙循环</strong>，也就是所谓的<strong>自旋</strong>，看看<strong>持有锁</strong>的线程<strong>是否会很快就释放锁</strong>，这项技术就是所谓的<strong>自旋锁</strong>。</p><p><strong>自旋锁</strong>在<code>JDK1.4.2</code>中引入但<strong>默认关闭</strong>，使用<code>-XX:UseSpinning</code>参数开启，<strong><code>JDK1.6</code>默认开启</strong>自旋锁。自旋等待不能代替阻塞，自旋等待本身虽然避免了线程切换的开销，但<strong>还是要占用处理器时间</strong>，若锁被占用的时间<strong>很短</strong>，<strong>自旋等待的效果会非常好</strong>，若锁被占用的时间<strong>很长</strong>，自旋等待的线程只会白白消耗处理器资源，<strong>反而带来性能上的浪费</strong>。</p><p><strong>自旋等待的时间</strong>是有一定的<strong>限度</strong>，若自旋<strong>超过了限定的次数</strong>仍然<strong>没有成功获得锁</strong>，就<strong>使用传统的方式挂起线程</strong>。<strong>自旋次数默认为<code>10</code>次</strong>，可使用参数<strong><code>-XX:PreBlockSpin</code></strong>来更改。</p><p><code>JDK1.6</code>引入了<strong>自适应的自旋锁</strong>，自适应意味着<strong>自旋</strong>的<strong>时间不再固定</strong>，而是由<strong>前一次</strong>在<strong>同一个锁上</strong>的<strong>自旋时间</strong>及<strong>锁的拥有者的状态来</strong>决定。若在同一个锁对象上，<strong>上一次是通过自旋等待获得的锁</strong>，且持有锁的<strong>线程正在运行中</strong>，则虚拟机将<strong>认为这次自旋锁也很有可能再次成功</strong>，进而它将<strong>运行自旋等待持续相对更长的时间</strong>。且若对于某个锁，通过自旋的方式<strong>很少成功获得过锁</strong>，则在以后要获取该锁时将可能<strong>省略自旋过程</strong>，以<strong>避免浪费处理器资源</strong>。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁的消除是指虚拟机<strong>即时编译器</strong>在运行时，对一些<strong>代码上要求同步</strong>，但被检测到<strong>不可能</strong>存在<strong>共享数据竞争</strong>的锁进行消除。锁消除<strong>主要</strong>判定<strong>依据</strong>来源于<strong>逃逸分析</strong>的数据支持，若判断在一段代码中，<strong>堆</strong>上所有数据都<strong>不会逃逸</strong>出去从而被其他线程访问到，即可以将其当做栈上数据对待，认为其是私有的，即可进行锁消除。</p><p>Java中有许多同步措施并不是程序员自己加入的，且同步代码在Java中是普遍存在的。例如最简单的String字符串的相加，由于String是不可变的类，在<code>JDK1.5</code>后将转化为<code>StringBuilder</code>对象的连续<code>append</code>操作，而每个<code>append</code>方法中都有一个同步块。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上总是推荐将<strong>同步块</strong>的<strong>作用范围</strong>限制得<strong>尽可能小</strong>，即只在<strong>共享数据</strong>的实际作用域中才进行同步，是为了使得需要同步得操作数量尽可能小，当存在竞争时，等待锁的线程也能<strong>尽可能快的拿到锁</strong>。</p><p>但若一系列<strong>连续操作</strong>都对<strong>同一个对象反复加锁和解锁</strong>，甚至<strong>加锁操作</strong>是出现在<strong>循环体</strong>中，即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><p>如连续的<code>StringBuilder</code>的<code>append</code>方法，若虚拟机检查到有这样<strong>一串零碎的操作都对同一个对象加锁</strong>，将会把加锁同步得范围<strong>粗化到整个操作序列的外部</strong>。连续的<code>StringBuilder</code>的<code>append</code>操作会扩展到第一个<code>append</code>操作之前直到最后一个<code>append</code>操作之后，这样加一次锁即可。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>传统</strong>的锁机制成为<strong>重量级锁</strong>，<strong>轻量级</strong>是相对于使用<strong>操作系统互斥量</strong>来实现的<strong>传统锁</strong>而言的，是<code>JDK1.6</code>加入的新型锁机制。轻量级锁<strong>并不是</strong>用来<strong>代替</strong>重量级锁的，其本意是在<strong>没有多线程竞争</strong>的前提下，<strong>减少重量级锁</strong>使操作系统互斥量产生的性能消耗。</p><p><strong><a href="../../VM/堆中对象分配&amp;布局&amp;访问#对象的内存布局">对象头</a></strong>中用于存储对象自身的<strong>运行时数据</strong>信息是实现<strong>轻量级锁</strong>和<strong>偏向锁</strong>的关键，官方称为<code>Mark Word</code>。对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，<code>Mark Word</code>被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><p>在<code>32</code>位<code>HotSpot</code>虚拟机中， 对象<strong>未被锁定</strong>的状态下，<code>Mark Word</code>的<strong><code>32</code>比特</strong>空间里的<strong><code>25</code>比特</strong>将用于存储<strong>对象哈希码</strong>， <strong><code>4</code>比特</strong>用于存储对象<strong>分代年龄</strong>， <strong><code>2</code>比特</strong>用于存储<strong>锁标志位</strong>， <strong><code>1</code>比特</strong>固定为<strong><code>0</code></strong>表示<strong>未进入偏向模式</strong>。 对象除了未被锁定的正常状态外， 还有<strong>轻量级锁定</strong>、 <strong>重量级锁定</strong>、 <strong><code>GC</code>标记</strong>、 <strong>可偏向</strong>等几种不同状态 。</p><p><img src="../../../../../images/Java/HotSpot虚拟机对象头Mark Word.png" alt="HotSpot虚拟机对象头Mark Word"></p><p>代码<strong>即将进入同步块</strong>时， 若<strong>锁标志位</strong>为<strong><code>01</code>状态</strong>即同步对象没有被锁定 ， 虚拟机首先将在<strong>当前线程</strong>的<strong>栈帧</strong>中建立一个名为<strong><code>Lock Record</code>锁记录</strong> 的空间， 用于存储锁对象目前的<strong><code>Mark Word</code>的拷贝</strong>，官方将该拷贝称为<strong><code>Displaced Mark Word</code></strong> 。</p><p><img src="../../../../../images/Java/轻量级锁CAS操作之前堆栈与对象的状态.png" alt="轻量级锁CAS操作之前堆栈与对象的状态"></p><p>虚拟机将使用<strong><code>CAS</code>操作</strong>尝试把对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。 若更新成功， 即代表该线程拥有了该对象的锁， 且对象<code>Mark Word</code>的<strong>锁标志位</strong>将转变为<strong><code>00</code></strong>， 表示此对象处于轻量级锁定状态。此时<strong>线程堆栈</strong>与<strong>对象头</strong>的状态如下：</p><p><img src="../../../../../images/Java/轻量级锁CAS操作之后堆栈与对象的状态.png" alt="轻量级锁CAS操作之后堆栈与对象的状态"></p><p>若更新失败， 意味着<strong>至少</strong>存在一条线程与当前线程<strong>竞争</strong>获取该对象的<strong>锁</strong>。 虚拟机首先会检查对象的<code>Mark Word</code>是否指向<strong>当前线程的栈帧</strong>， <strong>若是</strong>则说明当<strong>前线程</strong>已经<strong>拥有</strong>了<strong>该对象的锁</strong>， 则直接进入同步块， 否则说明该锁对象已经被其他线程抢占。 若出现<strong>两条以上</strong>的线程争用<strong>同一个锁</strong>， 则<strong>轻量级锁不再有效</strong>， <strong>必须要膨胀为重量级锁</strong>， <strong>锁标志</strong>的状态值变为<strong><code>10</code></strong>， 此时<code>Mark Word</code>中存储的就是指向<strong>重量级锁</strong>（互斥量） 的<strong>指针</strong>， 等待锁的线程也必须进入阻塞状态。 </p><p><strong>轻量级锁解锁过程</strong>也同样是<strong>通过<code>CAS</code>操作</strong>来进行， 若对象的<code>Mark Word</code>仍然指向线程的锁记录， 则用<strong><code>CAS</code>操作</strong>把对象当前的<code>Mark Word</code>和<strong>线程中复制的<code>Displaced Mark Word</code>替换回来</strong>。 若能<strong>成功替换</strong>， 则整个<strong>同步过程顺利完成</strong>； 若<strong>替换失败</strong>， 则说明有<strong>其他线程尝试过获取该锁</strong>， 就要在<strong>释放锁的同时， 唤醒被挂起的线程</strong>。</p><p><strong>轻量级锁</strong>能<strong>提升</strong>程序<strong>同步性能</strong>的<strong>依据</strong>：对于<strong>绝大部分的锁</strong>， 在<strong>整个同步周期内都不存在竞争</strong>，这一经验法则。若没有竞争， <strong>轻量级锁</strong>便通过<strong><code>CAS</code>操作</strong>成功<strong>避免了使用互斥量</strong>的开销； 但如果确实<strong>存在锁竞争</strong>， 除了互斥量的本身开销外， 还<strong>额外发生了<code>CAS</code>操作</strong>的开销。 因此在<strong>有竞争</strong>的情况下，<strong>轻量级锁反而会比传统的重量级锁更慢</strong> 。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>偏向锁</strong>是<code>JDK1.6</code>引入的一项<strong>锁优化措施</strong>， 其<strong>目的</strong>是<strong>消除</strong>数据在<strong>无竞争</strong>情况下的<strong>同步原语</strong>，进一步提高程序的运行性能。 若说<strong>轻量级锁</strong>是在<strong>无竞争</strong>的情况下使用<strong><code>CAS</code>操作</strong>去<strong>消除同步</strong>使用的<strong>互斥量</strong>， <strong>偏向锁</strong>就是在<strong>无竞争</strong>的情况下把<strong>整个同步都消除掉</strong>。</p><p>偏向锁的意思是<strong>锁会偏向于第一个获得它的线程</strong>， 若在接下来的执行过程中， 该锁<strong>一直没有被其他的线程获取</strong>， 则持有<strong>偏向锁</strong>的线程将<strong>永远不需要再进行同步</strong>。</p><p>若虚拟机启用了<strong>偏向锁</strong>， 则当锁对象第一次被线程获取时， 虚拟机将把对象头中的<strong>标志位</strong>设置为<strong><code>01</code></strong>、 把<strong>偏向模式设置为<code>1</code></strong>， 表示进入<strong>偏向模式</strong>。 同时使用<strong><code>CAS</code></strong>操作把获取到该锁的<strong>线程的<code>ID</code></strong>记录在对象的<code>Mark Word</code>中。 若<strong><code>CAS</code></strong>操作成功， <strong>持有偏向锁的线程</strong>以后每次进入<strong>该锁相关的同步块</strong>时， 虚拟机<strong>都可以不再进行任何同步操作</strong> 。偏向锁启用参数<strong><code>-XX：+UseBiasedLocking</code></strong>。</p><p>一旦出现另外一个线程去<strong>尝试获取该锁</strong>， <strong>偏向模式立即结束</strong>。 根据锁对象目前<strong>是否处于被锁定的状态决定是否撤销偏向</strong> ， 撤销后<strong>标志位恢复到未锁定</strong>或<strong>轻量级锁定</strong>的状态， 后续的同步操作按照<strong>轻量级锁</strong>执行。</p><p><img src="../../../../../images/Java/偏向锁、 轻量级锁的状态转化及对象Mark Word的关系.png" alt="偏向锁、 轻量级锁的状态转化及对象Mark Word的关系 "></p><p>当对象进入<strong>偏向状态</strong>时， <code>Mark Word</code>大部分的空间（23个比特） 都用于存储<strong>持有锁的线程<code>ID</code></strong>了， 这部分空间占用了原有<strong>存储对象哈希码</strong>的位置 。</p><p><code>Java</code>中对象如果计算过<strong>哈希码</strong>， 就应该一直保持该值不变 ，否则很多依赖对象哈希码的<code>API</code>都可能存在出错风险。 而作为绝大多数对象哈希码来源的<strong><code>Object::hashCode()</code></strong>方法， 返回的是<strong>对象的一致性哈希码</strong>， 该值是能<strong>强制保证不变</strong>的， 它通过在<strong>对象头中存储计算结果</strong>来保证第一次计算之后， <strong>再次调用该方法取到的哈希码值永远不会再发生改变</strong>。 因此当一个对象<strong>已经计算过一致性哈希码</strong>后， 则<strong>再也无法进入偏向锁状态</strong>了； 而当一个对象当前<strong>正处于偏向锁状态</strong>， 又收到<strong>需要计算</strong>其<strong>一致性哈希码</strong>请求时， 其<strong>偏向状态会被立即撤销</strong>， 且<strong>锁会膨胀为重量级锁</strong>。 在重量级锁的实现中， <strong>对象头指向了重量级锁的位置</strong>， 代表重量级锁的<strong><code>ObjectMonitor</code></strong>类里有字段可以记录<strong>非加锁状态下</strong>的<code>Mark Word</code>， 其中自然可以存储<strong>原来的哈希码</strong>。</p><p><strong>偏向锁</strong>可以<strong>提高带有同步但无竞争</strong>的程序性能， 但同样是一个带有<strong>效益权衡</strong>性质的优化，也就是说它并非总是对程序运行有利。 若程序中大多数锁都总是被多个不同的线程访问， 偏向模式则是多余的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;高效并发&lt;/strong&gt;是从&lt;code&gt;JDK1.5&lt;/code&gt;到&lt;code&gt;JDK1.6&lt;/code&gt;的一个重要改进，&lt;code&gt;HotSpot&lt;/code&gt;虚拟机为了&lt;strong&gt;在线程之间更高效地共享数据&lt;/strong&gt;，以及&lt;strong&gt;解
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="多线程，Thread" scheme="https://yaoyinglong.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8CThread/"/>
    
  </entry>
  
  <entry>
    <title>序列化</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/序列化/</id>
    <published>2020-10-26T16:00:00.000Z</published>
    <updated>2020-10-26T09:13:21.749Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="序列化" scheme="https://yaoyinglong.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>注解实现及应用</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/注解实现及应用/</id>
    <published>2020-10-25T16:00:00.000Z</published>
    <updated>2020-10-26T09:12:04.368Z</updated>
    
    <content type="html"><![CDATA[<p>注解一种<strong>标记式</strong>高耦合的配置方式，<code>Java</code>注解是从<code>JDK1.5</code>引入的。<strong>注解</strong>用于为Java代码提供<strong>元数据</strong>。作为元数据注解<strong>不直接影响</strong>代码执行。注解的本质就是一个<code>Annotation</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解本身就是<code>Annotation</code>接口的子接口，注解中其实可以有属性和方法，但接口中属性和方法都是<code>static fianl</code>的，对于注解没有意义，而<strong>定义接口的方法就相当于注解的属性</strong>，也就是为什么说注解只有成员变量，其实其就是接口的方法，也就是为什么成员变量会有括号。</p><p>注解属性类型可以有一下几种类型：</p><ul><li>基本数据类型</li><li>String</li><li>枚举类型</li><li>注解类型</li><li>Class类型</li><li>以上类型的一维数组类型</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>作用于注解的注解，<code>JDK</code>提供的元注解有<strong><code>@Retention</code></strong>、<strong><code>@Target</code></strong>、<strong><code>@Documented</code></strong>、<strong><code>@Inherited</code></strong>以及<code>JDK8</code>新增的<strong><code>@Repeatable</code></strong>五种。</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>表示注解存在阶段是保留在<strong>源码</strong>（编译期），<strong>字节码</strong>（类加载）或者<strong>运行期</strong>（<code>JVM</code>中运行），在<strong><code>@Retention</code></strong>注解中使用枚举<strong><code>RetentionPolicy</code></strong>来表示注解的<strong>生命周期</strong>。</p><ul><li><p><strong><code>@Retention(RetentionPolicy.SOURCE)</code></strong>，注解仅存在于<strong>源码</strong>中，在<strong><code>class</code>字节码文件中不包含</strong>。</p></li><li><p><strong><code>@Retention(RetentionPolicy.CLASS)</code></strong>， <strong>默认</strong>的保留策略，注解会在class字节码文件中存在，但<strong>运行时无法获得</strong>。</p></li><li><p><strong><code>@Retention(RetentionPolicy.RUNTIME)</code></strong>， 注解会在class字节码文件中存在，在<strong>运行时可以通过反射获取</strong>。</p></li></ul><p>若自定义注解，自定义注解如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现我们目的，所以自定义注解中肯定是使用 <strong><code>@Retention(RetentionPolicy.RUNTIME)</code></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>表示<strong>注解的作用目标</strong>，作用范围可以是<strong>类</strong>、<strong>方法</strong>、<strong>方法参数</strong>等，通过枚举类<strong><code>ElementType</code></strong>表达作用类型。</p><ul><li><p><strong><code>@Target(ElementType.TYPE)</code></strong> 作用<strong>接口</strong>、<strong>类</strong>、<strong>枚举</strong>、<strong>注解</strong></p></li><li><p><strong><code>@Target(ElementType.FIELD)</code></strong> 作用<strong>属性字段</strong>、<strong>枚举的常量</strong></p></li><li><p><strong><code>@Target(ElementType.METHOD)</code></strong> 作用<strong>方法</strong></p></li><li><p><strong><code>@Target(ElementType.PARAMETER)</code></strong> 作用<strong>方法参数</strong></p></li><li><p><strong><code>@Target(ElementType.CONSTRUCTOR)</code></strong> 作用<strong>构造函数</strong></p></li><li><p><strong><code>@Target(ElementType.LOCAL_VARIABLE)</code></strong>作用<strong>局部变量</strong></p></li><li><p><strong><code>@Target(ElementType.ANNOTATION_TYPE)</code></strong>作用于<strong>注解</strong>（<code>@Retention</code>注解中就使用该属性）</p></li><li><p><strong><code>@Target(ElementType.PACKAGE)</code></strong> 作用于<strong>包</strong></p></li><li><p><strong><code>@Target(ElementType.TYPE_PARAMETER)</code></strong> 作用于类型<strong>泛型</strong>，即泛型方法、泛型类、泛型接口 （<code>JDK8</code>加入）</p></li><li><p><strong><code>@Target(ElementType.TYPE_USE)</code></strong> 类型使用，可以<strong>用于标注任意类型除了 <code>class</code></strong> （<code>JDK8</code>加入）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>其作用是能够将注解中的元素包含到 <code>Javadoc</code> 中去。</p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>被<code>@Inherited</code>注解了的<strong>注解</strong>修饰了一个父类，若其子类没有被其他注解修饰，则其子类也继承了父类的注解。</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>被该元注解修饰的注解可以<strong>同时作用一个对象多次</strong>，但是每次作用注解又可以代表不同的含义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value = ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Prople &#123;</span><br><span class="line">    Game[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Prople.class)</span><br><span class="line"><span class="meta">@Target</span>(value = ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Game &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayGame</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Game</span>(value = <span class="string">"LOL"</span>)</span><br><span class="line">    <span class="meta">@Game</span>(value = <span class="string">"PUBG"</span>)</span><br><span class="line">    <span class="meta">@Game</span>(value = <span class="string">"NFS"</span>)</span><br><span class="line">    <span class="meta">@Game</span>(value = <span class="string">"Dirt4"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><p>注解的属性与类中定义的变量有异曲同工之处，注解中的变量都是成员变量，并且注解中是<strong>没有方法</strong>的，<strong>只有成员变量</strong>，<strong>变量名就是使用注解括号中对应的参数名</strong>，变量返回值就是使用注解括号中对应参数类型。</p><p><code>@Repeatable</code>注解中的变量则类型则是对应<code>Annotation</code>（接口）的泛型<code>Class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span></span><br><span class="line"><span class="comment">     * repeatable annotation type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the containing annotation type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK内置注解"><a href="#JDK内置注解" class="headerlink" title="JDK内置注解"></a>JDK内置注解</h3><p><code>JDK</code>预定义了<strong><code>@Override</code></strong>、<strong><code>@Deprecated</code></strong>、<strong><code>@SuppressWarnings</code></strong>三种注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>若注解有<strong>多个属性</strong>，给属性赋值时使用<strong>逗号隔开</strong>分别赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value = ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InvokeListener &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "baseService"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> <span class="keyword">default</span> 25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@InvokeListener</span>(name = <span class="string">"taskService"</span>, weight = <span class="number">50</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskServiceImpl</span> <span class="keyword">implements</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@FieldListener</span>(value = <span class="string">"baseTask"</span>)</span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自定义注解后在使用时通常需要获取注解的属性，需要通过反射的方式获取。获取类注解属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;TaskServiceImpl&gt; taskServiceClass = TaskServiceImpl.class;</span><br><span class="line"><span class="keyword">boolean</span> annotationPresent = taskServiceClass.isAnnotationPresent(InvokeListener.class);</span><br><span class="line"><span class="keyword">if</span> (annotationPresent) &#123;</span><br><span class="line">    InvokeListener annotation = taskServiceClass.getAnnotation(InvokeListener.class);</span><br><span class="line">    System.out.println(annotation.name());</span><br><span class="line">    System.out.println(annotation.weight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取方法注解属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Method play = PlayGame.class.getDeclaredMethod(<span class="string">"play"</span>);</span><br><span class="line"><span class="keyword">if</span> (play != <span class="keyword">null</span>) &#123;</span><br><span class="line">    People annotation = play.getAnnotation(People.class);</span><br><span class="line">    Game[] value = annotation.value();</span><br><span class="line">    <span class="keyword">for</span> (Game game : value) &#123;</span><br><span class="line">        System.out.println(game.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取属性注解属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;TaskServiceImpl&gt; taskServiceClass = TaskServiceImpl.class;</span><br><span class="line">Field field = taskServiceClass.getDeclaredField(<span class="string">"taskName"</span>);</span><br><span class="line"><span class="keyword">boolean</span> annotationPresent = field.isAnnotationPresent(FieldListener.class);</span><br><span class="line"><span class="keyword">if</span> (annotationPresent) &#123;</span><br><span class="line">    FieldListener annotation = field.getAnnotation(FieldListener.class);</span><br><span class="line">    System.out.println(annotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring中使用自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerConfig</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; beanMap = applicationContext.getBeansWithAnnotation(InvokeListener.class);</span><br><span class="line">        <span class="keyword">for</span> (Object bean : beanMap.values()) &#123;</span><br><span class="line">            Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                FieldListener fieldListener = field.getAnnotation(FieldListener.class);</span><br><span class="line">                <span class="keyword">if</span> (fieldListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(fieldListener.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Method[] methods = bean.getClass().getMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                MethodListener methodListener = method.getAnnotation(MethodListener.class);</span><br><span class="line">                <span class="keyword">if</span> (methodListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(methodListener.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注解一种&lt;strong&gt;标记式&lt;/strong&gt;高耦合的配置方式，&lt;code&gt;Java&lt;/code&gt;注解是从&lt;code&gt;JDK1.5&lt;/code&gt;引入的。&lt;strong&gt;注解&lt;/strong&gt;用于为Java代码提供&lt;strong&gt;元数据&lt;/strong&gt;。作为元数据注解&lt;s
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="注解" scheme="https://yaoyinglong.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized总结</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Synchronized%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Synchronized总结/</id>
    <published>2020-10-20T16:00:00.000Z</published>
    <updated>2020-11-12T02:13:37.789Z</updated>
    
    <content type="html"><![CDATA[<p><code>synchronized</code>是<code>Java</code>中解决并发问题的一种最常用最简单的方法 ，它可以确保线程<strong>互斥</strong>的访问同步代码，保证方法或者代码块在运行时，<strong>同一时刻只有一个方法</strong>可以进入到<strong>临界区</strong>，同时它还可以保证<strong>共享变量</strong>的内存<strong>可见性</strong>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>虚拟机支持<strong>方法级的同步</strong>和<strong>方法内部一段指令序列的同步</strong>，两种同步都使用<strong>管程<code>Monitor</code>来支持</strong>的。</p><p><strong>方法级的同步是隐式的，无须通过字节码指令来控制</strong>，它<strong>实现在方法调用</strong>和<strong>返回操作</strong>之中。虚拟机可以从<strong>方法常量池</strong>的<strong>方法结构中</strong>的<strong><code>ACC_SYNCHRONIZED</code>访问标志</strong>得知方法<strong>是否声明为同步方法</strong>。当方法调用时，调用的指令将会<strong>检查方法的<code>ACC_SYNCHRONIZED</code>访问标志</strong>是否被设置，若被设置，执行线程就要求<strong>先成功持有管程<code>Monitor</code></strong>，然后才能执行方法，最后当方法执行完成，<strong>无论是否正常完成都释放管程Monitor</strong>，方法执行期间，执行线程持有了<strong>管程<code>Monitor</code></strong>，其他任何线程都无法再获得同一个<strong>管程<code>Monitor</code></strong>。若同步方法<strong>执行期间抛出异常</strong>，且方法<strong>内部无法处理异常</strong>，同步方法所持有的<strong>管程<code>Monitor</code></strong>将在<strong>异常抛到同步方法外时自动释放</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Synchronized"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后的具体信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2// Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3// String Synchronized</span><br><span class="line">         5: invokevirtual #4// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>同步一段指令集序列</strong>通常是通过<strong><code>synchronized</code>语句块</strong>来完成，<strong>虚拟机的指令集使用<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持<code>synchronized</code>关键字的语义，正确实现<code>synchronized</code>关键字</strong>需要<strong><code>Javac</code>编译器</strong>和<strong><code>Java</code>虚拟机</strong>共同协作支持，编译器必须保证方法通过任何方式完成，方法中调用过的<strong>每条<code>monitorenter</code>指令</strong>都必须执行其<strong>对应的<code>monitorexit</code>指令</strong>，<strong>无论该方法是否正常结束</strong>。</p><p><strong>为了保证方法异常完成时<code>monitorenter</code>和<code>monitorexit</code>指令能正确配对执行，编译器会自动产生一个异常处理器，且声明可处理的所有异常，来执行<code>monitorexit</code>指令</strong>。</p><p><code>monitorenter</code>和<code>monitorexit</code>这两个字节码<strong>都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象</strong>。若<strong><code>synchronized</code></strong>明确指定了对象参数，那就是这个对象的<code>reference</code>，若没有明确指定，就根据<strong>synchronized</strong>修饰的是<strong>实例方法</strong>还是<strong>类方法</strong>，则取对应的<strong>对象实例</strong>或<strong>Class对象</strong>来作为锁对象。</p><p>虚拟机规范要求，执行<strong><code>monitorenter</code></strong>指令时，首先尝试获取对象的锁，若对象<strong>没有被锁定</strong>或当前线程<strong>已经拥有这个对象的锁</strong>，将<strong>锁的计数器加一</strong>，执行<strong><code>monitorexit</code></strong>指令时将<strong>锁计数器减一</strong>，当<strong>计数器为零时锁被释放</strong>。若<strong>获取对象锁失败，当前线程阻塞等待</strong>，直到对象锁被另一个线程释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Synchronized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后的具体信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter</span><br><span class="line">         4: getstatic     #2// Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3// String Synchronized</span><br><span class="line">         9: invokevirtual #4// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: monitorexit</span><br><span class="line">        <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">        <span class="number">17</span>: astore_2</span><br><span class="line">        <span class="number">18</span>: aload_1</span><br><span class="line">        <span class="number">19</span>: monitorexit</span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: athrow</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong><code>synchronized</code></strong>同步块对<strong>同一线程是可重入的</strong>，不会将自己死锁，但是是<strong>不可中断</strong>的。同步块在已进入的线程执行完成之前，会阻塞后面其他线程的进入。<code>Java</code>线程是<strong>映射到操作系统原生线程</strong>上的，阻塞或唤醒线程都需要操作系统帮忙，需要从<strong>用户状态</strong>转换到<strong>核心态</strong>中，因此转态<strong>转换需要耗费很多处理器时间</strong>。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>Java</code>中使用<code>synchronized</code>可使用在<strong>代码块</strong>和<strong>方法</strong>中，<code>synchronized</code>用的位置不同锁得对象就不同。</p><table><thead><tr><th>分类</th><th>被锁对象</th><th>实例</th></tr></thead><tbody><tr><td>实例方法</td><td>类得实例对象</td><td><code>public synchronized void sync1() {}</code></td></tr><tr><td>静态方法</td><td>类对象</td><td><code>public static synchronized void sync2() {}</code></td></tr><tr><td>实例对象</td><td>类得实例对象</td><td><code>synchronized (this) {}</code></td></tr><tr><td>class对象</td><td>类对象</td><td><code>synchronized (SynchronizedDemo.class) {}</code></td></tr><tr><td>任意实例对象Object</td><td>实例对象Object</td><td><code>String lock = &quot;&quot;; synchronized (lock) {}</code></td></tr></tbody></table><p>当一个线程访问<strong>某对象</strong>的<strong><code>synchronized</code>方法</strong>或者<strong><code>synchronized</code>代码块</strong>时，其他线程对<strong>该对象</strong>的该<strong><code>synchronized</code>方法</strong>或者<strong><code>synchronized</code>代码块</strong>的访问将被阻塞；其他线程<strong>仍可以访问</strong>该对象的<strong>非同步</strong>代码块；其他线程对<strong>该对象</strong>的<strong>其他</strong>的<strong><code>synchronized</code>方法</strong>或者<strong><code>synchronized</code>代码块</strong>的访问<strong>将被阻塞</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo instance = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(instance, <span class="string">"thread1"</span>);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(instance, <span class="string">"thread2"</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    <span class="keyword">while</span> (thread1.isAlive() || thread2.isAlive()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下，可以很明显的看出run方法里的代码是顺序执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am thread1</span><br><span class="line">thread1 运行结束</span><br><span class="line">I am thread2</span><br><span class="line">thread2 运行结束</span><br></pre></td></tr></table></figure><p>如下写法运行结果一样，除了使用this对象作为锁，也可以定义一个专门的锁对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以定义多个锁对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am lock1 "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" lock1部分运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am lock2 "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" lock2部分运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下，可以看出run方法里的代码是时被执行的。当<code>thread1</code>释放掉<code>lock1</code>的锁时，<code>thread2</code>即可获得<code>lock1</code>的锁，所以<code>thread2</code>的<code>lock1</code>中的同步代码块可以与<code>thread1</code>的<code>lock2</code>中的同步代码块并行执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I am lock1 thread1</span><br><span class="line">thread1 lock1部分运行结束</span><br><span class="line">I am lock2 thread1</span><br><span class="line">I am lock1 thread2</span><br><span class="line">thread1 lock2部分运行结束</span><br><span class="line">thread2 lock1部分运行结束</span><br><span class="line">I am lock2 thread2</span><br><span class="line">thread2 lock2部分运行结束</span><br></pre></td></tr></table></figure><h5 id="方法锁"><a href="#方法锁" class="headerlink" title="方法锁"></a>方法锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法锁："</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法锁：thread1</span><br><span class="line">thread1运行结束</span><br><span class="line">方法锁：thread2</span><br><span class="line">thread2运行结束</span><br></pre></td></tr></table></figure><h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h5><p><code>Java</code>类可能有多个对象，但只有一个<code>Class</code>对象，而类锁的锁对象就是该类的<code>Class</code>对象，类锁有两种形式：将<strong><code>synchronized</code>加在<code>static</code>方法</strong>上和<strong><code>synchronized(*.class)</code>代码块</strong>。</p><p><strong><code>synchronized</code>加在<code>static</code>方法</strong>上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassStatic4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态方法锁："</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedClassStatic4 instance1 = <span class="keyword">new</span> SynchronizedClassStatic4();</span><br><span class="line">        SynchronizedClassStatic4 instance2 = <span class="keyword">new</span> SynchronizedClassStatic4();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1, <span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2, <span class="string">"thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">while</span> (thread1.isAlive() || thread2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">静态方法锁：thread2</span><br><span class="line">thread2运行结束</span><br><span class="line">静态方法锁：thread1</span><br><span class="line">thread1运行结束</span><br></pre></td></tr></table></figure><p><strong><code>synchronized(*.class)</code>代码块</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassClass5</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedClassClass5.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"类锁同步代码块形式："</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedClassClass5 instance1 = <span class="keyword">new</span> SynchronizedClassClass5();</span><br><span class="line">        SynchronizedClassClass5 instance2 = <span class="keyword">new</span> SynchronizedClassClass5();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance1, <span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance2, <span class="string">"thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">while</span> (thread1.isAlive() || thread2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类锁同步代码块形式：thread1</span><br><span class="line">thread1运行结束</span><br><span class="line">类锁同步代码块形式：thread2</span><br><span class="line">thread2运行结束</span><br></pre></td></tr></table></figure><p>多线程访问<strong><code>synchronized</code></strong>同步方法常见的<strong><code>7</code>种</strong>情况：</p><ul><li>两个线程同时访问<strong>一个对象的同步方法</strong>：阻塞</li><li>两个线程访问的是<strong>两个对象的同步方法</strong>：非阻塞</li><li>两个线程访问的是<code>synchronized</code>的<strong>静态方法</strong>：阻塞</li><li><strong>同时</strong>访问<strong>同步方法</strong>和<strong>非同步方法</strong>：非阻塞</li><li>访问<strong>同一对象</strong>的<strong>不同</strong>的<strong>普通同步方法</strong>：阻塞</li><li>同时访问<strong>静态<code>synchronized</code></strong>和<strong>非静态<code>synchronized</code>方法</strong>：非阻塞</li><li>方法抛出<strong>异常</strong>后，<strong>会释放锁</strong></li></ul><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>同一个方法可重入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">        method(a + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的方法可重入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"methodA"</span>);</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"methodB"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的类可重入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"methodB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> <span class="keyword">extends</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass methodB"</span>);</span><br><span class="line">        <span class="keyword">super</span>.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是&lt;code&gt;Java&lt;/code&gt;中解决并发问题的一种最常用最简单的方法 ，它可以确保线程&lt;strong&gt;互斥&lt;/strong&gt;的访问同步代码，保证方法或者代码块在运行时，&lt;strong&gt;同一时刻只有一个方法&lt;/stron
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Synchronized" scheme="https://yaoyinglong.github.io/tags/Synchronized/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java与线程</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Java%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Java与线程/</id>
    <published>2020-10-20T16:00:00.000Z</published>
    <updated>2020-10-21T02:18:38.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>线程是<strong><code>CPU</code>调度</strong>的<strong>基本单位</strong>，是比进程更轻量级的<strong>调度执行单位</strong>，线程可以把进程的<strong>资源分配</strong>和<strong>执行调度</strong>分开，各个线程既可以共享进程资源（内存地址、文件<code>I/O</code>），又可以独立调度。</p><p>主流操作系统都提供了线程实现，<code>Java</code>提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行<code>start()</code>且还未结束的<code>Thread</code>类的实例代表一个线程。且<code>Thread</code>类所有关键方法都被声明为<code>Native</code>。在<code>Java</code>中<code>Native</code>方法意味着该方法没有使用或无法使用平台无关的手段实现，也可能为了执行效率而使用<code>Native</code>方法，通常最高效的手段是平台相关的手段。</p><p>实现线程主要有<code>3</code>种方式：<strong>使用内核线程实现</strong>、<strong>使用用户线程实现</strong>、<strong>使用用户线程加轻量级进程混合实现</strong></p><h5 id="使用内核实现"><a href="#使用内核实现" class="headerlink" title="使用内核实现"></a>使用内核实现</h5><p><strong><code>KTL</code>内核线程</strong>是直接由操作系统<strong>内核直接支持的线程</strong>，由<strong>内核</strong>来完成线程切换，内核通过<strong>操作调度器</strong>对线程进行调度，并负责将线程的任务<strong>映射到各个处理器上</strong>。每个内核线程可视为内核的一个<strong>分身</strong>。</p><p>程序<strong>一般不会</strong>使用<strong>内核线程</strong>，而是去使用内核线程的一种高级接口<strong>轻量级进程<code>LWP</code></strong>。<strong>轻量级进程</strong>就是通常意义上所说的<strong>线程</strong>，<strong>每个轻量级进程都由一个内核线程支持</strong>，这种关系称为<strong>一对一线程模型</strong>。</p><p><img src="../../../../../images/Java/轻量级进程与内核线程之间11的关系.jpg" alt="轻量级进程与内核线程之间1:1的关系"></p><p><strong>每个轻量级进程</strong>都成为一个<strong>独立的调度单元</strong>，但轻量级进程<strong>具有局限性</strong>，由于是基于内核线程实现的，故<strong>各种线程操作</strong>都需要进行<strong>系统调用</strong>。而<strong>系统调用的代价相对较高</strong>，需要在<strong>用户态</strong>和<strong>内核态</strong>中<strong>来回切换</strong>。每个轻量级进程都需要一个内核线程支持，因此<strong>轻量级进程要消耗一定的内核资源</strong>（如内核线程的栈空间），因此一个<strong>系统支持轻量级进程的数量是有限的</strong>。</p><h5 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h5><p><strong>广义</strong>上讲一个线程只要<strong>不是内核线程</strong>，就可以认为是用户线程，因此<strong>轻量级进程也属于用户线程</strong>，但轻量级进程始终是建立在内核之上的，许多操作系统都要进行<strong>系统调用</strong>，<strong>效率会受限</strong>。</p><p><strong>狭义</strong>上讲<strong>用户线程</strong>指的是<strong>完全建立在用户空间的线程库上</strong>，系统内核不能感知线程存在的实现。<strong>用户线程的建立、同步、销毁和调度完全在用户态中完成</strong>，不需要内核帮助。若程序实现得当，这种<strong>线程不需要切换到内核态</strong>，因此操作可以非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种<strong>进程</strong>与<strong>用户线程</strong>之间的<code>1：N</code>的关系称为<strong>一对多的线程模型</strong>。</p><p><img src="../../../../../images/Java/进程与用户线程之间1比N的关系.jpg" alt></p><p>用户线程<strong>优势在于不需要系统内核支援</strong>，<strong>劣势在于没有系统内核支援</strong>，<strong>所有线程操作都需要使用用户程序自己处理</strong>。由于操作系统只把处理器资源分配到进程，诸如<strong>阻塞处理</strong>、<strong>多处理器系统将线程映射到其他处理器上</strong>这类为题解决起来异常困难，甚至不可能完成。现在使用用户线程的程序越来越少了，Java曾经使用过用户线程但最终放弃了。</p><h5 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h5><p>还可以将<strong>内核线程</strong>与<strong>用户线程</strong>一起使用，在这种混合实现下，<strong>既存在用户线程，也存在轻量级进程</strong>。</p><p><img src="../../../../../images/Java/用户线程与轻量级进程间的N比M的关系.jpg" alt="用户线程与轻量级进程间的N:M的关系"></p><p>用户线程还是完全建立在用户空间中，因此<strong>用户线程</strong>的<strong>创建</strong>、<strong>切换</strong>、<strong>析构</strong>等操作依然廉价，且<strong>支持大规模的用户线程并发</strong>。操作系统提供的<strong>轻量级进程</strong>作为<strong>用户线程</strong>和<strong>内核线程</strong>之间的<strong>桥梁</strong>，通过轻量级进程使用内核提供的<strong>线程调度功能</strong>及<strong>处理器映射</strong>，且<strong>用户线程的系统调用要通过轻量级进程来完成</strong>，大大<strong>降低</strong>了整个<strong>进程被完全阻塞</strong>的风险。这种混合模式中，<strong>用户线程</strong>与<strong>轻量级进程</strong>的<strong>数量比是不固定的</strong>。</p><h5 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h5><p><code>JDK1.2</code>之前是基于<strong>用户线程</strong>实现的，<code>JDK1.2</code>中线程模型<strong>替换为基于操作系统原生线程模型</strong>来实现。<code>Sun JDK</code>的<code>Windows</code>版与<code>Linux</code>版都是使用<strong>一对一的线程模型</strong>实现的，<strong>一条<code>Java</code>线程就映射到一条轻量级进程</strong>中。</p><p>由于<code>Solaris</code>平台中操作系统的线程特性可同时支持<strong>一对一</strong>和<strong>多对多</strong>的线程模型。因此<code>Solaris</code>版的<code>JDK</code>中对应提供了两个平台专有的虚拟机参数<strong><code>-XX:+UseLWPSynchronization</code></strong>和<strong><code>-XX:UseBoundThreads</code></strong>来明确指定虚拟机使用哪种线程模型。</p><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p><strong>线程调度是指操作系统为线程分配处理器使用权的过程</strong>，主要有<strong>协同式线程调度</strong>和<strong>抢占式线程调度</strong>两种调度方式。<strong><code>Java</code>使用的是抢占式线程调度</strong>。</p><p>使用协同式调度的多线程系统，线程的<strong>执行时间</strong>由线程<strong>本身来控制</strong>，线程把自己的工作执行完后，要<strong>主动通知系统切换到另一个线程上</strong>。<strong>优点</strong>是<strong>实现简单</strong>，<strong>切换操作对线程自己是可知的</strong>，<strong>没有线程同步问题</strong>。<strong>缺点</strong>是线程<strong>执行时间不可控</strong>。</p><p>使用抢占式调度的多线程系统，<strong>线程将由系统来分配执行时间</strong>，线程的切换<strong>不由线程本身来决定</strong>，<code>Thread.yield()</code>可以让出执行时间，但线程没办法主动获取执行时间。<strong>优点</strong>线程<strong>执行时间可控</strong>，不会产生由一个线程导致整个进程阻塞。</p><p>虽然Java线程调度是由系统自动来完成，但可通过设置线程优先级来给系统建议给某些线程多分配或少分配一点执行时间。Java中一共设置了<code>10</code>个级别的线程<strong>优先级</strong>，两个线程<strong>同时处于<code>Ready</code>状态</strong>时，<strong>优先级越高</strong>的线程<strong>越容易被系统选择执行</strong>。</p><p>但<strong>线程优先级并不靠谱</strong>，因为Java线程是映射到系统原生线程上来实现的，<strong>最终线程调度还是取决于操作系统</strong>，虽然很多系统都提供线程优先级的概念，但并<strong>不一定</strong>能与Java线程优先级一一对应，且优先级可能被系统自动改变。</p><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java定义了五种线程状态，在任意时间点，一个线程只能有且只有其中一种状态。</p><ul><li><strong>新建（<code>New</code>）</strong>：创建后未启动的线程处于该状态</li><li><strong>运行（<code>Runable</code>）</strong>：包括了操作系统线程状态中的<code>Running</code>和<code>Ready</code>，处于次状态的线程有可能正在执行，也可能在等待<code>CPU</code>为他分配执行时间。</li><li><strong>无限期等待（<code>Waiting</code>）</strong>：该状态下线程不会被CPU分配执行时间，它们要等待被其他线程显式地唤醒。产生：<ul><li>没有设置<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>没有设置<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.park()</code>方法</li></ul></li><li><strong>限期等待（<code>Timed Waiting</code>）</strong>：不会被CPU分配执行时间，无需等待被其他线程显式唤醒，在一定时间之后会由系统自动唤醒。产生：<ul><li>Thread.sleep()方法</li><li>设置了Timeout参数的<code>Object.wait()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.parkNanos()</code>方法</li><li><code>LockSupport.parkUntil()</code>方法</li></ul></li><li><strong>阻塞（<code>Blocked</code>）</strong>：等待获取到一个排他锁，该事件将在另一个线程放弃这个锁时发生；</li><li><strong>结束（<code>Terminated</code>）</strong>：线程已结束执行。</li></ul><p><img src="../../../../../images/Java/线程状态转换关系.png" alt="线程状态转换关系"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程的实现&quot;&gt;&lt;a href=&quot;#线程的实现&quot; class=&quot;headerlink&quot; title=&quot;线程的实现&quot;&gt;&lt;/a&gt;线程的实现&lt;/h3&gt;&lt;p&gt;线程是&lt;strong&gt;&lt;code&gt;CPU&lt;/code&gt;调度&lt;/strong&gt;的&lt;strong&gt;基本单位&lt;/stron
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis总结</title>
    <link href="https://yaoyinglong.github.io/Blog/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/中间件/Redis总结/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-20T02:18:01.122Z</updated>
    
    <content type="html"><![CDATA[<p><code>redis</code>的速度非常的快，<strong>单机</strong>的<code>redis</code>就可以支撑<strong>每秒<code>10</code>几万的并发</strong>，相对于<code>mysql</code>来说，性能是<code>mysql</code>的几十倍。速度快的原因主要有几点：</p><ol><li><strong>完全基于内存操作</strong></li><li><strong>C语言实现</strong>，<strong>优化过的数据结构</strong>，基于几种基础的数据结构，<code>redis</code>做了大量的优化，性能极高</li><li><strong>使用单线程，无上下文的切换成本</strong></li><li>基于<strong>非阻塞的<code>IO</code>多路复用机制</strong></li></ol><p>虽然<code>6.0</code>后改用多线程，但并非是完全摒弃单线程，<code>redis</code>还是使用<strong>单线程模型来处理客户端的请求</strong>，只是使用<strong>多线程来处理数据的读写和协议解析</strong>，因为<code>redis</code>的<strong>性能瓶颈</strong>在于<strong>网络<code>IO</code></strong>而非CPU，使用多线程能提升<code>IO</code>读写的效率，从而整体提高<code>redis</code>的性能，<strong>执行命令还是使用单线程</strong>。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>字符串</strong>：<code>redis</code>没有直接使用C语言传统的字符串表示，而是自己实现的叫做<strong>简单动态字符串<code>SDS</code>的抽象类型</strong>。C语言的字符串<strong>不记录自身的长度信息</strong>，而<code>SDS</code>则<strong>保存了长度信息</strong>，这样将获取字符串长度的时间由<code>O(N)</code>降低到了<code>O(1)</code>，同时可以<strong>避免缓冲区溢出</strong>和<strong>减少修改字符串长度</strong>时所需的<strong>内存重分配次数</strong>。</p><p><strong>链表<code>linkedlist</code></strong>：是一个<strong>双向无环链表结构</strong>，很多<strong>发布订阅</strong>、<strong>慢查询</strong>、<strong>监视器</strong>功能都是使用到了链表来实现，每个链表的节点由一个<strong><code>listNode</code>结构</strong>来表示，每个节点都有指向<strong>前置节点</strong>和<strong>后置节点</strong>的指针，<strong>表头节点的前置和后置节点都指向<code>NULL</code></strong>。</p><p><strong>字典<code>hashtable</code></strong>：用于保存<strong>键值对</strong>的抽象数据结构，<code>redis</code>使用<code>hash</code>表作为底层实现，<strong>每个字典带有两个<code>hash</code>表</strong>，供<strong>平时使用</strong>和<code>rehash</code>时使用，<code>hash</code>表使用<strong>链地址法</strong>来<strong>解决键冲突</strong>，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对<code>hash</code>表进行扩容或者缩容的时候，为了服务的可用性，<strong><code>rehash</code>的过程不是一次性完成的而是渐进式的</strong>。</p><p><strong>跳跃表<code>skiplist</code></strong>：<strong>有序集合的底层实现之一</strong>，<code>redis</code>中实现<strong>有序集合键</strong>和<strong>集群节点的内部结构</strong>中都是使用跳跃表。<code>redis</code>跳跃表由<code>zskiplist</code>和<code>zskiplistNode</code>组成，<code>zskiplist</code>用于保存<strong>跳跃表信息</strong>（表头、表尾节点、长度等），<code>zskiplistNode</code>用于表示<strong>表跳跃节点</strong>，每个跳跃表的<strong>层高</strong>都是<code>1-32</code>的<strong>随机数</strong>，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，<strong>节点按照分值大小排序</strong>，如果<strong>分值相同，则按照成员对象的大小排序</strong>。</p><p><strong>整数集合<code>intset</code></strong>：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</p><p><strong>压缩列表<code>ziplist</code></strong>：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</p><p>基于基础的数据结构，<code>redis</code>封装了自己的对象系统，包含<strong>字符串对象<code>string</code></strong>、<strong>列表对象<code>list</code></strong>、<strong>哈希对象<code>hash</code></strong>、<strong>集合对象<code>set</code></strong>、<strong>有序集合对象<code>zset</code></strong>，每种对象都用到了<strong>至少一种基础的数据结构</strong>。</p><p><code>redis</code>通过<code>encoding</code>属性设置对象的编码形式来提升灵活性和效率，基于不同的场景<code>redis</code>会自动做出优化。不同对象的编码如下：</p><ol><li>字符串对象<code>string</code>：<code>int</code>整数、<code>embstr</code>编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：<code>ziplist</code>、<code>linkedlist</code></li><li>哈希对象<code>hash</code>：<code>ziplist</code>、<code>hashtable</code></li><li>集合对象<code>set</code>：<code>intset</code>、<code>hashtable</code></li><li>有序集合对象<code>zset</code>：<code>ziplist</code>、<code>skiplist</code></li></ol><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>当查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。</p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。</p><h5 id="定期-惰性都没有删除过期的key"><a href="#定期-惰性都没有删除过期的key" class="headerlink" title="定期+惰性都没有删除过期的key"></a>定期+惰性都没有删除过期的key</h5><p>每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存无法被删除，这时候就会走到<code>redis</code>的<strong>内存淘汰机制</strong>。</p><ul><li><strong><code>volatile-lru</code></strong>：从已设置过期时间的key中，移出<strong>最近最少使用</strong>的key进行淘汰</li><li><strong><code>volatile-ttl</code></strong>：从已设置过期时间的key中，移出<strong>将要过期</strong>的key</li><li><strong><code>volatile-random</code></strong>：从已设置过期时间的key中，<strong>随机</strong>选择key淘汰</li><li><strong><code>allkeys-lru</code></strong>：从key中选择最近<strong>最少使用</strong>的进行淘汰</li><li><strong><code>allkeys-random</code></strong>：从key中<strong>随机</strong>选择key进行淘汰</li><li><strong><code>noeviction</code></strong>：当<strong>内存达到阈值</strong>的时候，<strong>新写入操作报错</strong></li></ul><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><code>RDB</code></h5><p><code>RDB</code>持久化<strong>可手动执行</strong>也<strong>可根据配置定期执行</strong>，它的作用是<strong>将某个时间点上的数据库状态保存到<code>RDB</code>文件中</strong>，<code>RDB</code>文件是一个<strong>压缩的二进制文件</strong>，<strong>通过它可以还原某个时刻数据库的状态</strong>。由于<code>RDB</code>文件是保存在硬盘上的，所以即使<code>redis</code>崩溃或者退出，只要<code>RDB</code>文件存在，就可以用它来恢复还原数据库的状态。</p><p>可以通过<code>SAVE</code>或者<code>BGSAVE</code>来生成<code>RDB</code>文件。<strong><code>SAVE</code>命令会阻塞<code>redis</code>进程</strong>，直到<code>RDB</code>文件生成完毕，在进程<strong>阻塞期间，<code>redis</code>不能处理任何命令请求</strong>，显然不合适。</p><p><code>BGSAVE</code>则是会<code>fork</code>出一个子进程，然后<strong>由子进程去负责生成<code>RDB</code>文件</strong>，父进程还可以继续处理命令请求，不会阻塞进程。</p><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><code>AOF</code></h5><p><code>AOF</code>是通过保存<code>redis</code>服务器所<strong>执行的写命令来记录数据库状态的</strong>，<code>AOF</code>通过<strong>追加</strong>、<strong>写入</strong>、<strong>同步</strong>三个步骤来实现持久化机制。</p><p>当<code>AOF</code>持久化处于<strong>激活状态</strong>，服务器<strong>执行完写命令之后</strong>，写命令将会<strong>被追加<code>append</code>到<code>aof_buf</code>缓冲区的末尾</strong>；</p><p>在服务器<strong>每结束一个事件循环之前</strong>，将调用<code>flushAppendOnlyFile</code>函数决定是否要将<code>aof_buf</code>的内容保存到<code>AOF</code>文件中，可以通过配置<code>appendfsync</code>来决定。</p><ul><li><code>always</code>：<code>aof_buf</code>内容写入并同步到<code>AOF</code>文件</li><li><code>everysec</code>：将<code>aof_buf</code>中内容写入到<code>AOF</code>文件，如果上次同步<code>AOF</code>文件时间距离现在超过1秒，则再次对<code>AOF</code>文件进行同步</li><li><code>no</code>：将<code>aof_buf</code>内容写入<code>AOF</code>文件，但是并不对<code>AOF</code>文件进行同步，同步时间由操作系统决定</li></ul><p>默认选项是<code>everysec</code>，因为<code>always</code>来说虽然最安全（只会丢失一次事件循环的写命令），但是<strong>性能较差</strong>，而<code>everysec</code>模式只不过会可能丢失1秒钟的数据，而no模式的效率和<code>everysec</code>相仿，但是会丢失上次同步<code>AOF</code>文件之后的所有写命令数据。</p><h3 id="热KEY"><a href="#热KEY" class="headerlink" title="热KEY"></a>热KEY</h3><p>突然有几十万的请求访问<code>redis</code>上的某个特定<code>key</code>，这样会造成<strong>流量过于集中</strong>，<strong>达到物理网卡上限</strong>，从而导致这台<code>redis</code>的服务器宕机引发雪崩。解决方案：</p><ul><li>提前把<strong>热<code>key</code>打散到不同的服务器</strong>，降低压力</li><li>加入<strong>二级缓存</strong>，<strong>提前加载热<code>key</code>数据到内存中</strong>，如果<code>redis</code>宕机，走内存查询</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上。解决方案：</p><ul><li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了</li><li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在缓存中的数据，每次请求都会打到DB。可以通过<strong>加一层布隆过滤器</strong>。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃。解决方案：</p><ul><li>针对不同<code>key</code>设置不同的过期时间，避免同时过期</li><li>限流，如果<code>redis</code>宕机，可以限流，避免同时刻大量请求打崩DB</li><li>二级缓存，同热<code>key</code>的方案。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;redis&lt;/code&gt;的速度非常的快，&lt;strong&gt;单机&lt;/strong&gt;的&lt;code&gt;redis&lt;/code&gt;就可以支撑&lt;strong&gt;每秒&lt;code&gt;10&lt;/code&gt;几万的并发&lt;/strong&gt;，相对于&lt;code&gt;mysql&lt;/code&gt;来说，性能是&lt;
      
    
    </summary>
    
      <category term="中间件" scheme="https://yaoyinglong.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Redis" scheme="https://yaoyinglong.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis总结</title>
    <link href="https://yaoyinglong.github.io/Blog/Interview/Redis%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/Interview/Redis总结/</id>
    <published>2020-10-18T16:00:00.000Z</published>
    <updated>2020-10-20T10:48:55.140Z</updated>
    
    <content type="html"><![CDATA[<p><code>redis</code>的速度非常的快，<strong>单机</strong>的<code>redis</code>就可以支撑<strong>每秒<code>10</code>几万的并发</strong>，相对于<code>mysql</code>来说，性能是<code>mysql</code>的几十倍。速度快的原因主要有几点：</p><ol><li><strong>完全基于内存操作</strong></li><li><strong>C语言实现</strong>，<strong>优化过的数据结构</strong>，基于几种基础的数据结构，<code>redis</code>做了大量的优化，性能极高</li><li><strong>使用单线程，无上下文的切换成本</strong></li><li>基于<strong>非阻塞的<code>IO</code>多路复用机制</strong></li></ol><p>虽然<code>6.0</code>后改用多线程，但并非是完全摒弃单线程，<code>redis</code>还是使用<strong>单线程模型来处理客户端的请求</strong>，只是使用<strong>多线程来处理数据的读写和协议解析</strong>，因为<code>redis</code>的<strong>性能瓶颈</strong>在于<strong>网络<code>IO</code></strong>而非CPU，使用多线程能提升<code>IO</code>读写的效率，从而整体提高<code>redis</code>的性能，<strong>执行命令还是使用单线程</strong>。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>字符串</strong>：<code>redis</code>没有直接使用C语言传统的字符串表示，而是自己实现的叫做<strong>简单动态字符串<code>SDS</code>的抽象类型</strong>。C语言的字符串<strong>不记录自身的长度信息</strong>，而<code>SDS</code>则<strong>保存了长度信息</strong>，这样将获取字符串长度的时间由<code>O(N)</code>降低到了<code>O(1)</code>，同时可以<strong>避免缓冲区溢出</strong>和<strong>减少修改字符串长度</strong>时所需的<strong>内存重分配次数</strong>。</p><p><strong>链表<code>linkedlist</code></strong>：是一个<strong>双向无环链表结构</strong>，很多<strong>发布订阅</strong>、<strong>慢查询</strong>、<strong>监视器</strong>功能都是使用到了链表来实现，每个链表的节点由一个<strong><code>listNode</code>结构</strong>来表示，每个节点都有指向<strong>前置节点</strong>和<strong>后置节点</strong>的指针，<strong>表头节点的前置和后置节点都指向<code>NULL</code></strong>。</p><p><strong>字典<code>hashtable</code></strong>：用于保存<strong>键值对</strong>的抽象数据结构，<code>redis</code>使用<code>hash</code>表作为底层实现，<strong>每个字典带有两个<code>hash</code>表</strong>，供<strong>平时使用</strong>和<code>rehash</code>时使用，<code>hash</code>表使用<strong>链地址法</strong>来<strong>解决键冲突</strong>，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对<code>hash</code>表进行扩容或者缩容的时候，为了服务的可用性，<strong><code>rehash</code>的过程不是一次性完成的而是渐进式的</strong>。</p><p><strong>跳跃表<code>skiplist</code></strong>：<strong>有序集合的底层实现之一</strong>，<code>redis</code>中实现<strong>有序集合键</strong>和<strong>集群节点的内部结构</strong>中都是使用跳跃表。<code>redis</code>跳跃表由<code>zskiplist</code>和<code>zskiplistNode</code>组成，<code>zskiplist</code>用于保存<strong>跳跃表信息</strong>（表头、表尾节点、长度等），<code>zskiplistNode</code>用于表示<strong>表跳跃节点</strong>，每个跳跃表的<strong>层高</strong>都是<code>1-32</code>的<strong>随机数</strong>，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，<strong>节点按照分值大小排序</strong>，如果<strong>分值相同，则按照成员对象的大小排序</strong>。</p><p><strong>整数集合<code>intset</code></strong>：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</p><p><strong>压缩列表<code>ziplist</code></strong>：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</p><p>基于基础的数据结构，<code>redis</code>封装了自己的对象系统，包含<strong>字符串对象<code>string</code></strong>、<strong>列表对象<code>list</code></strong>、<strong>哈希对象<code>hash</code></strong>、<strong>集合对象<code>set</code></strong>、<strong>有序集合对象<code>zset</code></strong>，每种对象都用到了<strong>至少一种基础的数据结构</strong>。</p><p><code>redis</code>通过<code>encoding</code>属性设置对象的编码形式来提升灵活性和效率，基于不同的场景<code>redis</code>会自动做出优化。不同对象的编码如下：</p><ol><li>字符串对象<code>string</code>：<code>int</code>整数、<code>embstr</code>编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：<code>ziplist</code>、<code>linkedlist</code></li><li>哈希对象<code>hash</code>：<code>ziplist</code>、<code>hashtable</code></li><li>集合对象<code>set</code>：<code>intset</code>、<code>hashtable</code></li><li>有序集合对象<code>zset</code>：<code>ziplist</code>、<code>skiplist</code></li></ol><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>当查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。</p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。</p><h5 id="定期-惰性都没有删除过期的key"><a href="#定期-惰性都没有删除过期的key" class="headerlink" title="定期+惰性都没有删除过期的key"></a>定期+惰性都没有删除过期的key</h5><p>每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存无法被删除，这时候就会走到<code>redis</code>的<strong>内存淘汰机制</strong>。</p><ul><li><strong><code>volatile-lru</code></strong>：从已设置过期时间的key中，移出<strong>最近最少使用</strong>的key进行淘汰</li><li><strong><code>volatile-ttl</code></strong>：从已设置过期时间的key中，移出<strong>将要过期</strong>的key</li><li><strong><code>volatile-random</code></strong>：从已设置过期时间的key中，<strong>随机</strong>选择key淘汰</li><li><strong><code>allkeys-lru</code></strong>：从key中选择最近<strong>最少使用</strong>的进行淘汰</li><li><strong><code>allkeys-random</code></strong>：从key中<strong>随机</strong>选择key进行淘汰</li><li><strong><code>noeviction</code></strong>：当<strong>内存达到阈值</strong>的时候，<strong>新写入操作报错</strong></li></ul><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><code>RDB</code></h5><p><code>RDB</code>持久化<strong>可手动执行</strong>也<strong>可根据配置定期执行</strong>，它的作用是<strong>将某个时间点上的数据库状态保存到<code>RDB</code>文件中</strong>，<code>RDB</code>文件是一个<strong>压缩的二进制文件</strong>，<strong>通过它可以还原某个时刻数据库的状态</strong>。由于<code>RDB</code>文件是保存在硬盘上的，所以即使<code>redis</code>崩溃或者退出，只要<code>RDB</code>文件存在，就可以用它来恢复还原数据库的状态。</p><p>可以通过<code>SAVE</code>或者<code>BGSAVE</code>来生成<code>RDB</code>文件。<strong><code>SAVE</code>命令会阻塞<code>redis</code>进程</strong>，直到<code>RDB</code>文件生成完毕，在进程<strong>阻塞期间，<code>redis</code>不能处理任何命令请求</strong>，显然不合适。</p><p><code>BGSAVE</code>则是会<code>fork</code>出一个子进程，然后<strong>由子进程去负责生成<code>RDB</code>文件</strong>，父进程还可以继续处理命令请求，不会阻塞进程。</p><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><code>AOF</code></h5><p><code>AOF</code>是通过保存<code>redis</code>服务器所<strong>执行的写命令来记录数据库状态的</strong>，<code>AOF</code>通过<strong>追加</strong>、<strong>写入</strong>、<strong>同步</strong>三个步骤来实现持久化机制。</p><p>当<code>AOF</code>持久化处于<strong>激活状态</strong>，服务器<strong>执行完写命令之后</strong>，写命令将会<strong>被追加<code>append</code>到<code>aof_buf</code>缓冲区的末尾</strong>；</p><p>在服务器<strong>每结束一个事件循环之前</strong>，将调用<code>flushAppendOnlyFile</code>函数决定是否要将<code>aof_buf</code>的内容保存到<code>AOF</code>文件中，可以通过配置<code>appendfsync</code>来决定。</p><ul><li><code>always</code>：<code>aof_buf</code>内容写入并同步到<code>AOF</code>文件</li><li><code>everysec</code>：将<code>aof_buf</code>中内容写入到<code>AOF</code>文件，如果上次同步<code>AOF</code>文件时间距离现在超过1秒，则再次对<code>AOF</code>文件进行同步</li><li><code>no</code>：将<code>aof_buf</code>内容写入<code>AOF</code>文件，但是并不对<code>AOF</code>文件进行同步，同步时间由操作系统决定</li></ul><p>默认选项是<code>everysec</code>，因为<code>always</code>来说虽然最安全（只会丢失一次事件循环的写命令），但是<strong>性能较差</strong>，而<code>everysec</code>模式只不过会可能丢失1秒钟的数据，而no模式的效率和<code>everysec</code>相仿，但是会丢失上次同步<code>AOF</code>文件之后的所有写命令数据。</p><h3 id="热KEY"><a href="#热KEY" class="headerlink" title="热KEY"></a>热KEY</h3><p>突然有几十万的请求访问<code>redis</code>上的某个特定<code>key</code>，这样会造成<strong>流量过于集中</strong>，<strong>达到物理网卡上限</strong>，从而导致这台<code>redis</code>的服务器宕机引发雪崩。解决方案：</p><ul><li>提前把<strong>热<code>key</code>打散到不同的服务器</strong>，降低压力</li><li>加入<strong>二级缓存</strong>，<strong>提前加载热<code>key</code>数据到内存中</strong>，如果<code>redis</code>宕机，走内存查询</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上。解决方案：</p><ul><li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了</li><li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在缓存中的数据，每次请求都会打到DB。可以通过<strong>加一层布隆过滤器</strong>。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃。解决方案：</p><ul><li>针对不同<code>key</code>设置不同的过期时间，避免同时过期</li><li>限流，如果<code>redis</code>宕机，可以限流，避免同时刻大量请求打崩DB</li><li>二级缓存，同热<code>key</code>的方案。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;redis&lt;/code&gt;的速度非常的快，&lt;strong&gt;单机&lt;/strong&gt;的&lt;code&gt;redis&lt;/code&gt;就可以支撑&lt;strong&gt;每秒&lt;code&gt;10&lt;/code&gt;几万的并发&lt;/strong&gt;，相对于&lt;code&gt;mysql&lt;/code&gt;来说，性能是&lt;
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="Redis" scheme="https://yaoyinglong.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CAS原理及使用场景</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/CAS%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/CAS原理及使用场景/</id>
    <published>2020-10-14T16:00:00.000Z</published>
    <updated>2020-10-09T07:43:15.836Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="CAS" scheme="https://yaoyinglong.github.io/tags/CAS/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/创建型模式/单例模式/</id>
    <published>2020-10-08T16:00:00.000Z</published>
    <updated>2020-11-03T06:18:47.771Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式的核心代码就是将<strong>构造方法私有化</strong>，只有一个实例，自己负责创建自己的对象即<strong>自行实例化</strong>，提供一种访问其唯一对象的方式，可直接访问，不需要实例化该类的对象。</p><p><strong>优点</strong>：</p><ul><li>内存中只有一个实例，<strong>减少了内存开支</strong>，特别是一个对象需要频繁创建和销毁时。</li><li>只生成一个实例，<strong>减少了系统性能开销</strong>，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可通过在应用启动时直接产生一个单例对象，永久驻留内存的方式解决。</li><li>可以<strong>避免对资源的多重占用</strong>，例如写文件动作，避免了对同一个资源文件同事写操作。</li><li>可以在系统<strong>设置全局访问点</strong>，<strong>优化和共享资源访问</strong>。如设计一个单例类，负责所有数据表的映射处理。</li></ul><p><strong>缺点</strong>：</p><ul><li>单例模式<strong>一般没有接口，扩展困难</strong>。单例模式要求自行实例化，且提供单一实例，接口和抽象类是不能被实例化的。</li><li><strong>对测试不利</strong>，单例模式未开发完，是不能进行测试的，没有接口也不能使用mock方式来进行测试。</li><li><strong>与单一职责原则冲突</strong>。</li></ul><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>实例在使用时才去创建，用的时候才去检查有没有实例。有线程安全和线程不安全两种写法，区别就是<code>synchronized</code>关键字。下面这种写法存在线程安全问题，在并发获取实例时，可能会存在创建多个实例的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>在类加载时实例被创建。实现简单且没有线程安全的问题，可能在还不需要此实例的时候就已经把实例创建出来了，浪费内存空间，没起到<code>lazy loading</code>的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双检锁"><a href="#双检锁" class="headerlink" title="双检锁"></a>双检锁</h3><p><strong>双重校验锁</strong>，综合了<strong>懒汉式</strong>和<strong>饿汉式</strong>两者的优缺点。特点在<code>synchronized</code>关键字内外都加了一层 <code>if</code> 条件判断，既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。这里还用到了<code>volatile</code>关键字来修饰<code>instance</code>，其最关键的作用是<strong>防止指令重排</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类的方式效果类似双检锁，但实现更简单且线程安全。同时静态内部类不会在<code>Singleton</code>类加载时就加载，而是在调用<code>getInstance()</code>方法时才进行加载，<strong>达到了懒加载的效果</strong>。但这种方式只适用于<strong>静态域</strong>的情况，双检锁方式可在<strong>实例域</strong>需要<strong>延迟初始化</strong>时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举的方式是比较少见的一种实现方式，却更简洁清晰。还<strong>自动支持序列化机制</strong>，绝对防止多次实例化。<strong>单元素</strong>的<strong>枚举类型</strong>已经成为实现<code>Singleton</code>的最佳方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在系统中要求一个类有且仅有一个对象，若出现多个对象会出现副作用，可以采用单例模式。</p><ul><li>要求生成<strong>唯一序列号</strong>的环境</li><li>在整个项目中需要一个<strong>共享访问点</strong>或<strong>共享数据</strong></li><li>创建一个对象需要消耗的资源过多，如<strong>访问<code>IO</code></strong>和<strong>数据库</strong>等资源</li><li>需要定义大量的静态常量和静态方法的环境</li></ul><h3 id="Spring中典型应用"><a href="#Spring中典型应用" class="headerlink" title="Spring中典型应用"></a>Spring中典型应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">   Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">         singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">         <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式的核心代码就是将&lt;strong&gt;构造方法私有化&lt;/strong&gt;，只有一个实例，自己负责创建自己的对象即&lt;strong&gt;自行实例化&lt;/strong&gt;，提供一种访问其唯一对象的方式，可直接访问，不需要实例化该类的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/stron
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="https://yaoyinglong.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Volatile原理</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Volatile%E5%8E%9F%E7%90%86/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Volatile原理/</id>
    <published>2020-10-05T16:00:00.000Z</published>
    <updated>2020-10-22T05:17:31.681Z</updated>
    
    <content type="html"><![CDATA[<p>在说<code>Volatile</code>原理前先熟悉一下相关的基本概念<strong><a href="../原子性、可见性、有序性">原子性、可见性、有序性</a></strong></p><h3 id="Volatile原理"><a href="#Volatile原理" class="headerlink" title="Volatile原理"></a>Volatile原理</h3><p>关键字<code>Volatile</code>是<code>Java</code>虚拟机提供的<strong>最轻量级</strong>的<strong>同步机制</strong>，当一个变量被定义为volatile后，其将具备<strong>两种特性</strong>：保证此变量对<strong>所有线程</strong>的<strong>可见性</strong>，<strong>静止指令重排序</strong>。</p><p>在<strong>某些情况</strong>下<code>volatile</code>的同步机制的<strong>性能确实优于锁</strong>，但虚拟机<strong>对锁进行了许多消除和优化</strong>。很难量化认为<code>volatile</code>比<code>synchronized</code>快多少；即便如此大多数场景下volatile总开销仍然要比锁低。</p><p><code>volatile</code>自己与自己比较，<code>volatile</code> 的<strong>读性能消耗</strong>与普通变量几乎相同，但<strong>写操作稍慢</strong>，因为它需要在本地代码中插入许多<strong>内存屏障指令</strong>来保证处理器不发生乱序执行。</p><p>在<strong><code>volatile</code>与锁之间选择</strong>的<strong>唯一依据</strong>仅仅是<strong><code>volatile</code>语义能否满足使用场景的需求</strong>。</p><p><strong><code>Volatile</code>保证当前<code>CPU</code>缓存、其他<code>CPU</code>缓存、主内存、工作内存间的数据一致及读写逻辑代码的有序执行</strong>。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><code>volatile</code>变量在<strong>各个线程的工作内存中不存在一致性问题</strong>，在各个线程的工作内存中，<code>volatile</code>变量<strong>也可以存在不一致</strong>的情况，但由于<strong>每次使用之前都要刷新</strong>，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题。但<code>Java</code>中的<strong>运算并非原子操作</strong>，导致<code>volatile</code>变量的<strong>运算</strong>在<strong>并发</strong>下一样是<strong>不安全</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    race++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[THREAD_COUNT];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10000</span>; i1++) &#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getId() + <span class="string">" completed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(race);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若正确并发最后结果应为<code>200000</code>，但实际运行结果基本上为160000多一点。问题出在<code>race++</code>，<code>increase()</code>方法的字节码可以看到，<code>race++</code>是由<code>4</code>条字节码指令完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     0: getstatic     #2                  // Field race:I</span><br><span class="line">     <span class="number">3</span>: iconst_1</span><br><span class="line">     <span class="number">4</span>: iadd</span><br><span class="line">     5: putstatic     #2                  // Field race:I</span><br><span class="line">     <span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>题外话，这里使用的是<code>Thread.activeCount() &gt; 2</code>而不是<code>Thread.activeCount() &gt; 1</code>是因为我使用的是<code>IDEA</code>，<code>IDEA</code>是用得<strong>反射</strong>，所以还有一个<strong><code>monitor</code>监控线程</strong>。但是在<code>Java</code>和<code>Eclipse</code>中是<code>1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ThreadGroup[name=main,maxpri=<span class="number">10</span>]</span><br><span class="line">    Thread[main,<span class="number">5</span>,main]</span><br><span class="line">    Thread[Monitor Ctrl-Break,<span class="number">5</span>,main]</span><br></pre></td></tr></table></figure><p>使用字节码来分析并发问题，仍不严谨，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器将要<strong>运行许多行代码</strong>才能实现它的语意，若是编译执行，一条字节码指令也可能转化成<strong>若干本地机器码指令</strong>，可以通过使用<strong><code>-XX:+PrintAssembly</code></strong>参数输出<strong>反汇编</strong>来分析会更加严谨。</p><p>访问<code>volatile</code>变量时<strong>不会执行加锁操作</strong>，<code>volatile</code>变量是一种比<code>sychronized</code>关键字<strong>更轻量级的同步机制</strong>。对非<code>volatile</code>变量进行读写时，每个线程先<strong>从内存拷贝变量到<code>CPU</code>缓存中</strong>。若计算机有多个<code>CPU</code>，每个线程可能在不同的<code>CPU</code>上被处理，每个线程可以<strong>拷贝到不同的<code>CPU cache</code>中</strong>。声明<code>volatile</code>变量时，<code>JVM</code>保证每次读变量都从主内存中读取，<strong>跳过<code>CPU cache</code>这一步</strong>。</p><p><img src="../../../../../images/Java/多线程数据读写模型.png" alt></p><p><code>volatile</code> 保证变量对所有线程的<strong>可见性</strong>，当一个线程修改了这个变量的值，<code>volatile</code> 保证了<strong>新值能立即同步到主内存</strong>，以及<strong>每次使用前立即从主内存刷新</strong>。<strong>可见性</strong>只能保证每次读取的是最新的值，但<code>volatile</code>没办法保证对变量操作的<strong>原子性</strong>。</p><h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>若定义<code>initialized</code>变量没有使用<code>volatile</code>修饰，可能会由于<strong>指令重排序优化</strong>，导致A线程中最后一句<code>initialized = true</code>被提前执行。从而导致B线程中使用的配置信息可能出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A中执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">    configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">    configText = readConfigFile(fileName);</span><br><span class="line">    processConfigOptions(configText, configOptions);</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B中执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    doSomethingWithConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>volatile</code> 禁止指令重排序</strong>，<code>volatile</code>修饰的变量，赋值后多执行了一个<strong><code>lock addl $0x0, (%esp)</code></strong>操作，该操作相当于一个<strong>内存屏障</strong>，指令重排序时<strong>不能把后面的指令重排序到内存屏障之前的位置</strong>，只有一个CPU访问内存时，不需要<strong>内存屏障</strong>。<code>lock</code>的作用是使得本<code>CPU</code>的<code>Cache</code>写入内存，该写入操作也会引起别的<code>CPU</code>或别的内核无效化其<code>Cache</code>。所以通过该操作可让<code>volatile</code>变量的修改对其他<code>CPU</code>立即可见。</p><p>从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给个相应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确额的执行结果。<strong><code>lock addl $0x0, (%esp)</code></strong>指令<strong>把修改同步到内存</strong>，意味着所有之前的操作都已经执行完成，这样便形成了<strong>指令重排序无法越过内存屏障的效果</strong>。</p><h3 id="volatile变量内存交互操作"><a href="#volatile变量内存交互操作" class="headerlink" title="volatile变量内存交互操作"></a>volatile变量内存交互操作</h3><p><code>T</code>表示一个线程，<code>V</code>、<code>W</code>表示两个volatile变量，在进行<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>、<code>write</code>操作时满足如下规则：</p><p><strong>该规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值</strong>。只有当线程T对变量V执行的前一个操作是load时，线程T才能对变量V执行use操作；且仅当线程T对变量V执行的最后一个操作时use时，线程T才能对变量V执行load操作。线程T对变量V的use操作可以认为是和线程T对变量V的load、read操作相关联，必须连续译器出现。</p><p><strong>该规则要求在工作内存中，每次修改V后都必须立即同步回主内存中，用于保证其他线程可以看到自己对变量V所作的修改</strong>。仅当线程T对变量V执行的前一个操作时assign时，先吃T才能对变量V执行store操作；且仅当线程T对变量V的执行的最后一个操作是store时，线程T才能对变量V执行assign操作。线程T对变量V的assign操作可以认为是和线程T对变量V的store、write操作相关联，必须连续译器出现。</p><p><strong>该规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同</strong>。若动作A是线程T对变量V实施的use或assign操作，动作F是和动作A相关联的load或store操作，动作P是和动作F相应的对变量V的read或write操作；若动作B是线程T对变量W实施的use或assign操作，动作Q是和动作G相关联的load或store操作，动作Q是和动作G相应的对变量W的read或write操作；若A优于B则P优于Q。</p><h3 id="C和C"><a href="#C和C" class="headerlink" title="C和C++"></a>C和C++</h3><p>在<code>C</code>和<code>C++</code>中的<code>volatile</code>作用：<strong>优化无效代码、禁止指令重排序、直接完成简单运算、读写都走内存不走寄存器</strong>。<code>volatile</code>是通过<code>lock</code>指令触发了<strong>读写屏障</strong>，通过<strong><code>MESI</code>缓存一致性协议</strong>从而实现了<strong>当前<code>CPU</code>、其他<code>CPU</code>和主存之间的一致性</strong>。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p><strong>编译器屏障</strong>：在解决<strong>编译乱序</strong>问题时，需要使用<strong><code>barrier()</code>编译屏障</strong>，在<code>code</code>中使用<code>barrier()</code>可以<strong>阻止编译器对该<code>code</code>的编译优化</strong>，可以<strong>防止编译屏障之前的<code>code</code>和编译屏障之后的<code>code</code>出现编译乱序</strong>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#definebarrier() _asm_ _volatile_("": : :"memory")</span><br></pre></td></tr></table></figure><p><strong><code>CPU</code>屏障</strong>：是为了解决缓存一致性问题，分为<strong>锁总线（<code>ifence</code>、<code>sfence</code>、<code>mfence</code>）</strong>和<strong>锁缓存（<code>lock</code>）</strong>，锁总线的方式已被淘汰。锁缓存其实是通过<strong><code>MESI</code>缓存一致性协议</strong>来完成的。</p><p><strong><code>JVM</code>中的四种内存屏障</strong>：<code>storeload</code>、<code>storestore</code>、<code>loadload</code>、<code>loadstore</code></p><p><strong>注</strong>：<code>32</code>位机<code>32</code>根总线、<code>64</code>位机<code>64</code>根总线，<code>ifence</code>写、<code>sfence</code>写、<code>mfence</code>读写</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>符合以下两条运算场景：</p><ul><li>运算结果<strong>不依赖变量的当前值</strong>，或能够确保只有<strong>单一线程修改变量的值</strong>。</li><li>变量不需要与<strong>其他的状态变量共同参与不变约束</strong></li></ul><p>当<code>shutdown()</code>方法被调用时，能保证所以<strong>线程中执行</strong>的<code>doWork()</code>方法都<strong>立即停止</strong>下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shutdownRequested = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123;</span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双锁检查单例模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在说&lt;code&gt;Volatile&lt;/code&gt;原理前先熟悉一下相关的基本概念&lt;strong&gt;&lt;a href=&quot;../原子性、可见性、有序性&quot;&gt;原子性、可见性、有序性&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Volatile原理&quot;&gt;&lt;a href=&quot;#Volatil
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Volatile" scheme="https://yaoyinglong.github.io/tags/Volatile/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/Java内存模型与线程/</id>
    <published>2020-09-26T16:00:00.000Z</published>
    <updated>2020-10-03T10:36:02.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="硬件效率与一致性"><a href="#硬件效率与一致性" class="headerlink" title="硬件效率与一致性"></a>硬件效率与一致性</h3><p>计算机的<strong>存储设备</strong>与<strong>处理器的运算速度</strong>有<strong>几个数量级</strong>的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的<strong>高速缓存</strong>来作为<strong>内存</strong>与<strong>处理器</strong>之间的缓冲：<strong>将运算需要使用到的数据复制到缓存中</strong>，让运算能快速进行，<strong>当运算结束后再从缓存中将数据同步回内存之中</strong>。</p><p>基于高速缓存的存储交互很好的解决了<strong>处理器与内存的速度矛盾</strong>，但也引入了一个新的问题：<strong>缓存一致性</strong>。在多处理器系统中，每个处理器都有自己的高速缓存，又<strong>共享同一主内存</strong>，多个处理器的运算任务都涉及<strong>同一块</strong>主内存区域时，<strong>可能导致各自的缓存数据不一致</strong>。</p><p>为了解决<strong>缓存数据一致性</strong>问题，需要各个处理器访问缓存时都遵循一些<strong>协议</strong>，如：<code>MSI</code>、<code>MESI</code>、<code>MOSI</code>、<code>Synapse</code>、<code>Firefly</code>、<code>Dragon Protocol</code>等。</p><p><img src="../../../../../images/Java/处理器、高速缓存、主内存间的交互关系.jpg" alt="处理器、高速缓存、主内存间的交互关系"></p><p>除了增加高速缓存外，为了使处理器内部的运算单元尽可能被充分利用，处理器可能会对输入的代码进行<strong>乱序执行优化</strong>，即<strong>指令重排序</strong>，处理器会在<strong>计算之后将乱序执行的结果重组</strong>，<strong>保证该结果与顺序执行的结果是一致的</strong>，但不保证程序中各个语句计算的先后顺序与输入的代码中的顺序一致。</p><p><code>Java</code>虚拟机的即时编译器中也有类似的<strong>指令重排序优化</strong>。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p><code>Java</code>虚拟机中试图定义一种<strong><code>Java</code>内存模型<code>JMM</code></strong>来<strong>屏蔽</strong>各种<strong>硬件</strong>和<strong>操作系统</strong>的<strong>内存访问差异</strong>。<code>C/C++</code>语言是直接使用物理硬件和操作系统的内存模型，由于不同平台上内存模型的差异，可能导致不同平台上并发访问出错。</p><p><strong><code>Java</code>内存模型的主要目标是定义程序中各个变量的访问规则</strong>，即在虚拟机中<strong>将变量存储到内存</strong>和<strong>从内存中取出变量</strong>这样的底层细节。这里说的变量包括：<strong>实例字段</strong>、<strong>静态字段</strong>、<strong>构成数组对象的元素</strong>，不包括：<strong>局部变量</strong>、<strong>方法参数</strong>。因为局部变量和方法参数是<strong>线程私有</strong>的。</p><p><code>Java</code>内存模型并<strong>没有限制执行引擎使用处理器</strong>的<strong>特定寄存器</strong>或<strong>缓存</strong>来和<strong>主内存</strong>交互，也<strong>没有限制即时编译器进行调整代码执行顺序</strong>这类优化措施。</p><p><code>Java</code>内存模型<strong>规定</strong>了所有的<strong>变量都存储在主内存</strong>（虚拟机内存中的一部分）中，每条线程有自己的工作内存，线程的<strong>工作内存</strong>中保存了被该线程使用到的变量的<strong>主内存副本拷贝</strong>，线程对变量的<strong>所有操作都必须在工作内存中进行</strong>，<strong>不能直接读写主内存中的变量</strong>。不同的线程间也无法直接访问对方的工作内存中的变量，线程间变量值得传递均需要通过主内存来完成。</p><p>注：<strong>拷贝副本</strong>，事实上并<strong>不会完全复制一份对象</strong>拷贝出来，该<strong>对象的引用</strong>、<strong>对象中某个在线程访问到的字段</strong>是有可能存在拷贝的，但<strong>不会有虚拟机实现成把整个对象拷贝一次</strong>。</p><p><img src="../../../../../images/Java/线程、主内存、工作内存三者交互关系.jpg" alt="线程、主内存、工作内存三者交互关系"></p><p>注：若<strong>局部变量</strong>是一个<code>reference</code>类型，它引用的对象在堆中可被各个线程共享，但<code>reference</code>本身在Java栈的局部变量表中，是线程私有的。</p><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>Java内存模型中定义了以下<code>8</code>种操作来完成<strong>主内存</strong>与<strong>工作内存</strong>之间的具体<strong>交互协议</strong>，虚拟机实现时必须保证每一种操作都是<strong>原子</strong>的、不可再分的。</p><table><thead><tr><th>操作</th><th>作用域</th><th>完成的工作</th></tr></thead><tbody><tr><td><strong><code>lock</code></strong>（<strong>锁定</strong>）</td><td><strong>主</strong>内存变量</td><td>把一个变量标识为一条<strong>线程独占状态</strong></td></tr><tr><td><strong><code>unlock</code></strong>（<strong>解锁</strong>）</td><td><strong>主</strong>内存变量</td><td>把一个<strong>处于锁定状态的变量释放出来</strong>，释放后才可被其他线程锁定</td></tr><tr><td><strong><code>read</code></strong>（<strong>读取</strong>）</td><td><strong>主</strong>内存变量</td><td>把一个变量的值<strong>从主内存传输到线程的工作内存</strong>中</td></tr><tr><td><strong><code>load</code></strong>（<strong>载入</strong>）</td><td><strong>工作</strong>内存变量</td><td>把<strong><code>read</code></strong>操作从主内存中得到的变量值放入工作内存的<strong>变量副本</strong>中</td></tr><tr><td><strong><code>use</code></strong>（<strong>使用</strong>）</td><td><strong>工作</strong>内存变量</td><td>把工作内存中变量值传递给执行引擎</td></tr><tr><td><strong><code>assign</code></strong>（<strong>赋值</strong>）</td><td><strong>工作</strong>内存变量</td><td><strong>把从执行引擎接收到的值赋给工作内存的变量</strong></td></tr><tr><td><strong><code>store</code></strong>（<strong>存储</strong>）</td><td><strong>工作</strong>内存变量</td><td>把工作内存中一个变量的值传递到主内存中</td></tr><tr><td><strong><code>write</code></strong>（<strong>写入</strong>）</td><td><strong>主</strong>内存变量</td><td>把<strong><code>store</code></strong>操作从工作内存中得到的变量值放入主内存的变量中</td></tr></tbody></table><p>若把一个变量<strong>从主内存复制到工作内存</strong>，需要<strong>顺序</strong>执行<strong><code>read</code></strong>和<strong><code>load</code></strong>操作。若要将变量从<strong>工作内存同步回主内存</strong>，需<strong>顺序</strong>执行<strong><code>store</code></strong>和<strong><code>write</code></strong>操作。<code>Java</code>内存模型只要求上述两个操作必须顺序执行，而<strong>没有保证是连续执行</strong>。</p><p><code>Java</code>内存模型规定了在执行上述<code>8</code>种操作时必须满足以下规则：</p><ul><li><strong>不允许</strong><code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一<strong>单独出现</strong>，即<strong>不允许</strong>一个变量<strong>从主内存读取了但工作内存不接受</strong>，或<strong>从工作内存发起回写但主内存不接受</strong>的情况出现。</li><li><strong>不允许线程丢弃它最近的<code>assign</code>操作</strong>，即变量<strong>在工作内存中改变了之后必须把它同步回主内存</strong>。</li><li><strong>不允许</strong>线程无原因地（<strong>未发生任何<code>assign</code>操作</strong>）把数据从线程<strong>工作内存同步回主内存</strong>。</li><li>一个<strong>新变量只能在主内存中诞生</strong>，<strong>不允许工作内存</strong>中直接使用一个<strong>未被初始化</strong>（<code>load</code>或<code>assign</code>）的变量。即对一个变量实施<code>use</code>、<code>store</code>操作之前，必须先执行过了<code>assign</code>和<code>load</code>操作。</li><li>一个变量同一时刻<strong>只允许一条线程</strong>对其进行<code>lock</code>操作，但<code>lock</code>操作<strong>可以被同一条线程重复执行多次</strong>，多次执行<code>lock</code>后，只有<strong>执行相同次数</strong>的<code>unlock</code>操作，变量才会被解锁。</li><li>若对一个变量执行<code>lock</code>操作，将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量钱，需要<strong>重新执行<code>load</code>或<code>assign</code>操作初始化变量</strong>的值。</li><li>若变量<strong>事先没有被<code>lock</code>操作锁定，不允许对它执行<code>unlock</code>操作</strong>，也<strong>不允许<code>unlock</code></strong>一个被其<strong>他线程锁定</strong>的变量。</li><li><strong>对变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存中</strong>。</li></ul><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;硬件效率与一致性&quot;&gt;&lt;a href=&quot;#硬件效率与一致性&quot; class=&quot;headerlink&quot; title=&quot;硬件效率与一致性&quot;&gt;&lt;/a&gt;硬件效率与一致性&lt;/h3&gt;&lt;p&gt;计算机的&lt;strong&gt;存储设备&lt;/strong&gt;与&lt;strong&gt;处理器的运算速度&lt;/st
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JVM，线程" scheme="https://yaoyinglong.github.io/tags/JVM%EF%BC%8C%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
