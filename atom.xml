<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YingLong</title>
  
  <subtitle>虽奔放不羁，但也自我束缚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoyinglong.github.io/"/>
  <updated>2021-06-25T07:40:20.950Z</updated>
  <id>https://yaoyinglong.github.io/</id>
  
  <author>
    <name>YaoYingLong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>策略模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/策略模式/</id>
    <published>2021-06-23T16:00:00.000Z</published>
    <updated>2021-06-25T07:40:20.950Z</updated>
    
    <content type="html"><![CDATA[<p>当实现某一个功能存在多种算法或者策略，可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。</p><p>如果使用<strong>多重条件转移语句</strong>实现即硬编码，不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。采用策略模式就能很好解决该问题。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一系列算法，并将每个算法封装起来，使它们可以<strong>相互替换</strong>，且算法的变化不会影响使用算法的客户。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性。</p><p><strong><code>Strategy</code>抽象策略类</strong>定义一个公共接口，各种不同算法以不同方式实现该接口，环境角色使用该接口调用不同的算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">strategy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>ConcreteStrategy</code>具体策略类</strong>，实现了抽象策略定义的接口，<strong>提供具体的算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体策略A的策略方法被访问！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体策略B的策略方法被访问！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Context</code>环境类</strong>，持有一个策略类的引用，最终给客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy.strategy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Context c = <span class="keyword">new</span> Context();</span><br><span class="line">    Strategy strategyA = <span class="keyword">new</span> ConcreteStrategyA();</span><br><span class="line">    c.setStrategy(strategyA);</span><br><span class="line">    c.strategy();</span><br><span class="line">    Strategy strategyB = <span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">    c.setStrategy(strategyB);</span><br><span class="line">    c.strategy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>多重条件语句不易维护，而使用策略模式可以<strong>避免使用多重条件语句</strong></li><li>策略模式提供了一系列的可供<strong>重用的算法族</strong>，恰当使用继承可以把算法族的公共代码转移到父类里面，从而<strong>避免重复的代码</strong></li><li><strong>自由切换</strong>，策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的</li><li>策略模式提供了<strong>对开闭原则的完美支持</strong>，可以在不修改原代码的情况下，灵活增加新算法</li><li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>会造成很多的策略类，增加维护难度</li><li>所有策略类都需要对外暴露，上层模块必须知道有哪些策略，才能决定使用哪个策略，与迪米特法则相违<br>背</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>多个类只有在算法或行为上稍有不同的场景</li><li>算法需要自由切换的场景</li><li>需要屏蔽算法规则的场景</li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>策略枚举，把原有定义在抽象策略中的方法移植到枚举中，每个枚举成员就成为一个具体策略 。略枚举是一个非常优秀和方便的模式，但是它受枚举类型的限制，每个枚举项都是public、final、static的，扩展性受到了一定的约束，因此在系统开发中，策略枚举一般担当不经常发生变化的角色。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StrategyEnum &#123;</span><br><span class="line">    ADD(<span class="string">"+"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUB(<span class="string">"-"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    String value;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StrategyEnum</span><span class="params">(String _value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = _value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> b = Integer.parseInt(args[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(<span class="string">"运行结果为： "</span> + StrategyEnum.ADD.exec(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当实现某一个功能存在多种算法或者策略，可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。&lt;/p&gt;
&lt;p&gt;如果使用&lt;strong&gt;多重条件转移语句&lt;/strong&gt;实现即硬编码，不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，策略模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/责任链模式/</id>
    <published>2021-06-22T16:00:00.000Z</published>
    <updated>2021-06-23T07:30:26.046Z</updated>
    
    <content type="html"><![CDATA[<p><strong>定义</strong>：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 </p><p>责任链模式的关键是在<strong>链</strong>上，链是由多个处理者<code>ConcreteHandler</code>组成，由一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应结果。</p><p><img src="../../../../../images/设计模式/责任链模式通用类图.png" alt="责任链模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>抽象处理者角色</strong>，定义一个处理请求的接口，包含抽象处理方法和一个后继连接，融合了<strong>模板方法模式</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChainHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractChainHandler next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">doHandler</span><span class="params">(Object... obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isAccordWith</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">handler</span><span class="params">(Object... obj)</span> </span>&#123;</span><br><span class="line">        T result = doHandler(obj);</span><br><span class="line">        <span class="keyword">if</span> (!isAccordWith(result) &amp;&amp; next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) next.handler(obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(AbstractChainHandler next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体处理者角色</strong>，实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteChainHandler1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractChainHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doHandler</span><span class="params">(Object... obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T1&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isAccordWith</span><span class="params">(T1 t1)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据具体业务逻辑判断返回true还是false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteChainHandler2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractChainHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doHandler</span><span class="params">(Object... obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T1&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isAccordWith</span><span class="params">(T1 t1)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据具体业务逻辑判断返回true还是false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户类角色</strong>，创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractChainHandler h1 = <span class="keyword">new</span> ConcreteChainHandler1();</span><br><span class="line">    AbstractChainHandler h2 = <span class="keyword">new</span> ConcreteChainHandler2();</span><br><span class="line">    h1.setNext(h2);</span><br><span class="line">    h1.handler(<span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。</p><ul><li><strong>降低了对象之间的耦合度</strong>，对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息</li><li><strong>增强了系统的可扩展性</strong>，可以根据需要增加新的请求处理类</li><li><strong>增强了给对象指派职责的灵活性</strong>，当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任</li><li><strong>简化了对象之间的连接</strong>，每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li><strong>责任分担</strong>，每个类只需要处理自己该处理的工作</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>不能保证每个请求一定被处理</strong>，没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，<strong>系统性能将受到一定影响</strong></li><li>职责链建立的合理性要靠客户端来保证，<strong>增加了客户端的复杂性</strong>，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>过滤器链的实现，Spring中的拦截器链</p><ul><li><p>多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。</p></li><li><p>可动态指定一组对象处理请求，或添加新的处理者</p></li><li><p>需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 &lt;/p&gt;
&lt;p&gt;责任链模式的关键是在&lt;strong&gt;链&lt;/strong&gt;上，链是由多个处理
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，责任链模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/结构型模式/装饰模式/</id>
    <published>2021-06-22T16:00:00.000Z</published>
    <updated>2021-06-24T02:39:36.019Z</updated>
    
    <content type="html"><![CDATA[<p><strong>动态地给一个对象添加一些额外的职责</strong>。就增加功能来说，<strong>装饰模式相比生成子类更为灵活</strong>。<strong>是对继承的有力补充</strong>。</p><p>扩展一个类的功能会使用继承方式来实现。但<strong>继承具有静态特征</strong>，<strong>耦合度高</strong>，并且<strong>随着扩展功能的增多，子类会很膨胀</strong>。装饰器模式的目标是<strong>使用组合关系来创建一个装饰对象</strong>来包裹真实对象，并在<strong>保持真实对象的类结构不变</strong>的前提下，为其提供额外的功能。</p><p><img src="../../../../../images/设计模式/装饰器模式结构图.png" alt="装饰器模式结构图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteComponent operation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象装饰角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为具体构件角色增加额外的功能addedFunction()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Component p = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">    p.operation();</span><br><span class="line">    Component d = <span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">    d.operation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若<strong>只有一个具体构件</strong>而<strong>没有抽象构件</strong>时，<strong>可以让抽象装饰继承具体构件</strong>。若只有<strong>一个具体装饰</strong>时，可以将抽象装饰和具体装饰合并。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>装饰类和被装饰类可以独立发展， 而不会相互耦合；</li><li>装饰模式是继承关系的一个替代方案；</li><li>装饰模式可以动态地扩展一个实现类的功能；</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>装饰器模式会增加许多子类，过度使用会增加程序得复杂性，尽量减少装饰类的数量， 以便降低系统的复杂度。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><p>需要<strong>扩展一个类的功能</strong>， 或给一个类增加附加功能，而<strong>又不能采用生成子类的方法</strong>进行扩充时；</p></li><li><p>需要<strong>动态地给一个对象增加功能</strong>， 这些功能可以再<strong>动态地撤销</strong>；</p></li><li><p>当需要通过对现有的一组基本功能进行<strong>排列组合</strong>而产生非常多的功能时，采用继承关系很难实现；</p><p><code>Java I/O</code> 标准库的设计，<code>InputStream</code>的子类<code>FilterInputStream</code>，<code>OutputStream</code>的子类<code>FilterOutputStream</code>，<code>Reader</code>的子类<code>BufferedReader</code>以及<code>FilterReader</code>，还有<code>Writer</code>的子类<code>BufferedWriter</code>、<code>FilterWriter</code>以及 <code>PrintWriter</code>等，它们都是抽象装饰类。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"filename.txt"</span>));</span><br><span class="line">String s = in.readLine();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;动态地给一个对象添加一些额外的职责&lt;/strong&gt;。就增加功能来说，&lt;strong&gt;装饰模式相比生成子类更为灵活&lt;/strong&gt;。&lt;strong&gt;是对继承的有力补充&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;扩展一个类的功能会使用继承方式来实现。但&lt;strong
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，装饰模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java实用工具库</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/Java%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/Java实用工具库/</id>
    <published>2021-06-21T16:00:00.000Z</published>
    <updated>2021-06-22T03:33:19.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="commons-lang3"><a href="#commons-lang3" class="headerlink" title="commons-lang3"></a>commons-lang3</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span></span></span><br></pre></td></tr></table></figure><h4 id="首字母转成大写"><a href="#首字母转成大写" class="headerlink" title="首字母转成大写"></a>首字母转成大写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.capitalize(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><h4 id="重复拼接字符串"><a href="#重复拼接字符串" class="headerlink" title="重复拼接字符串"></a>重复拼接字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.repeat(<span class="string">"ab"</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h4><p>Date类型转String类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String date = DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br></pre></td></tr></table></figure><p>String类型转Date类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = DateUtils.parseDate(<span class="string">"2021-05-01 01:01:01"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br></pre></td></tr></table></figure><p>一个小时候的日期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = DateUtils.addHours(new Date(), 1);</span><br></pre></td></tr></table></figure><h4 id="包装临时对象"><a href="#包装临时对象" class="headerlink" title="包装临时对象"></a>包装临时对象</h4><p>当一个方法需要返回两个及以上字段时，一般会封装成一个临时对象返回，但Pair和Triple可以完美解决</p><p>返回两个字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImmutablePair&lt;Integer, String&gt; pair = ImmutablePair.of(<span class="number">1</span>, <span class="string">"test"</span>);</span><br><span class="line">System.out.println(pair.getLeft() + <span class="string">","</span> + pair.getRight());</span><br></pre></td></tr></table></figure><p>返回三个字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImmutableTriple&lt;Integer, String, Date&gt; triple = ImmutableTriple.of(<span class="number">1</span>, <span class="string">"test"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(triple.getLeft() + <span class="string">","</span> + triple.getMiddle() + <span class="string">","</span> + triple.getRight());</span><br></pre></td></tr></table></figure><hr><h2 id="commons-collections4"><a href="#commons-collections4" class="headerlink" title="commons-collections4"></a>commons-collections4</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>两个集合取交集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = CollectionUtils.retainAll(listA, listB);</span><br></pre></td></tr></table></figure><p>两个集合取并集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = CollectionUtils.union(listA, listB);</span><br></pre></td></tr></table></figure><p>两个集合取差集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = CollectionUtils.subtract(listA, listB);</span><br></pre></td></tr></table></figure><hr><h2 id="common-beanutils"><a href="#common-beanutils" class="headerlink" title="common-beanutils"></a>common-beanutils</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置对象属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> User user = <span class="keyword">new</span> User();</span><br><span class="line"> BeanUtils.setProperty(user, <span class="string">"id"</span>, <span class="number">1</span>);</span><br><span class="line"> BeanUtils.setProperty(user, <span class="string">"name"</span>, <span class="string">"test"</span>);</span><br><span class="line"> System.out.println(BeanUtils.getProperty(user, <span class="string">"name"</span>));</span><br></pre></td></tr></table></figure><p>对象和map互转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = BeanUtils.describe(user);</span><br><span class="line"></span><br><span class="line">User newUser = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.populate(newUser, map);</span><br></pre></td></tr></table></figure><hr><h2 id="commons-io-文件流处理"><a href="#commons-io-文件流处理" class="headerlink" title="commons-io 文件流处理"></a>commons-io 文件流处理</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>读取文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"demo1.txt"</span>);  </span><br><span class="line">List&lt;String&gt; lines = FileUtils.readLines(file, Charset.defaultCharset());</span><br></pre></td></tr></table></figure><p>写入文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtils.writeLines(<span class="keyword">new</span> File(<span class="string">"demo2.txt"</span>), lines);</span><br></pre></td></tr></table></figure><p>复制文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtils.copyFile(srcFile, destFile);</span><br></pre></td></tr></table></figure><hr><h2 id="Guava工具类库"><a href="#Guava工具类库" class="headerlink" title="Guava工具类库"></a>Guava工具类库</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>30.1.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>反转List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; reverse = Lists.reverse(list);</span><br></pre></td></tr></table></figure><p> list集合元素太多，可以分成若干个集合，每个集合10个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; partition = Lists.partition(list, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>Multimap一个key可以映射多个value的HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Multimap&lt;String, Integer&gt; map = ArrayListMultimap.create();  </span><br><span class="line">map.put(<span class="string">"key"</span>, <span class="number">1</span>);  </span><br><span class="line">map.put(<span class="string">"key"</span>, <span class="number">2</span>);  </span><br><span class="line">Collection&lt;Integer&gt; values = map.get(<span class="string">"key"</span>);  </span><br><span class="line"><span class="comment">// 输出 &#123;"key":[1,2]&#125;</span></span><br><span class="line">System.out.println(map); </span><br><span class="line"><span class="comment">// 还能返回你以前使用的臃肿的Map</span></span><br><span class="line">Map&lt;String, Collection&lt;Integer&gt;&gt; collectionMap = map.asMap();</span><br></pre></td></tr></table></figure><p>BiMap一种连value也不能重复的HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BiMap&lt;String, String&gt; biMap = HashBiMap.create();  </span><br><span class="line"><span class="comment">// 如果value重复，put方法会抛异常，除非用forcePut方法  </span></span><br><span class="line">biMap.put(<span class="string">"key"</span>,<span class="string">"value"</span>);  </span><br><span class="line"><span class="comment">// 输出 &#123;"key":"value"&#125;  </span></span><br><span class="line">System.out.println(biMap); </span><br><span class="line"><span class="comment">// 既然value不能重复，何不实现个翻转key/value的方法，已经有了  </span></span><br><span class="line">BiMap&lt;String, String&gt; inverse = biMap.inverse();</span><br><span class="line"><span class="comment">// 输出 &#123;"value":"key"&#125;  </span></span><br><span class="line">System.out.println(inverse);</span><br></pre></td></tr></table></figure><p>Table一种有两个key的HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一批用户，同时按年龄和性别分组  </span></span><br><span class="line">Table&lt;Integer, String, String&gt; table = HashBasedTable.create();  </span><br><span class="line">table.put(<span class="number">18</span>, <span class="string">"男"</span>, <span class="string">"NameA"</span>);  </span><br><span class="line">table.put(<span class="number">18</span>, <span class="string">"女"</span>, <span class="string">"NameB"</span>);  </span><br><span class="line"><span class="comment">// 输出NameA</span></span><br><span class="line">System.out.println(table.get(<span class="number">18</span>, <span class="string">"男"</span>)); </span><br><span class="line"><span class="comment">// 这其实是一个二维的Map，可以查看行数据  </span></span><br><span class="line">Map&lt;String, String&gt; row = table.row(<span class="number">18</span>);</span><br><span class="line"><span class="comment">// 输出 &#123;"男":"NameA","女":"NameB"&#125;</span></span><br><span class="line">System.out.println(row); </span><br><span class="line"><span class="comment">// 查看列数据</span></span><br><span class="line">Map&lt;Integer, String&gt; column = table.column(<span class="string">"男"</span>);</span><br><span class="line"><span class="comment">// 输出 &#123;18:"NameA"&#125;</span></span><br><span class="line">System.out.println(column);</span><br></pre></td></tr></table></figure><p>Multiset一种用来计数的Set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Multiset&lt;String&gt; multiset = HashMultiset.create();  </span><br><span class="line">multiset.add(<span class="string">"apple"</span>);</span><br><span class="line">multiset.add(<span class="string">"apple"</span>);</span><br><span class="line">multiset.add(<span class="string">"orange"</span>);</span><br><span class="line"><span class="comment">// 输出 2</span></span><br><span class="line">System.out.println(multiset.count(<span class="string">"apple"</span>)); </span><br><span class="line"><span class="comment">// 查看去重的元素  </span></span><br><span class="line">Set&lt;String&gt; set = multiset.elementSet();  </span><br><span class="line">System.out.println(set); <span class="comment">// 输出 ["orange","apple"]  </span></span><br><span class="line"><span class="comment">// 还能查看没有去重的元素  </span></span><br><span class="line">Iterator&lt;String&gt; iterator = multiset.iterator();  </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">    System.out.println(iterator.next());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 还能手动设置某个元素出现的次数  </span></span><br><span class="line">multiset.setCount(<span class="string">"apple"</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;commons-lang3&quot;&gt;&lt;a href=&quot;#commons-lang3&quot; class=&quot;headerlink&quot; title=&quot;commons-lang3&quot;&gt;&lt;/a&gt;commons-lang3&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="基础" scheme="https://yaoyinglong.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java，工具" scheme="https://yaoyinglong.github.io/tags/Java%EF%BC%8C%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/命令模式/</id>
    <published>2021-06-20T16:00:00.000Z</published>
    <updated>2021-06-21T09:34:16.549Z</updated>
    
    <content type="html"><![CDATA[<p>命令模式是一个高内聚的模式 ，将一个请求封装成一个对象， 从而让你使用不同的请求把客户端参数化， 对请<br>求排队或者记录请求日志， 可以提供命令的撤销和恢复功能 。</p><p><img src="../../../../../images/设计模式/命令模式通用类图.png" alt="命令模式通用类图"></p><p>命令模式有三个角色：</p><ul><li><strong><code>Receiver</code>接收者角色</strong>：执行命令功能的相关操作，具体命令对象业务的真正实现者。</li><li><strong><code>Command</code>命令角色</strong>：需要执行的所有命令在该角色中声明，拥有执行命令的抽象方法<code>execute()</code>。</li><li><strong><code>Invoker</code>调用者角色</strong>：是请求发送者，通常拥有很多命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>通用的Receiver类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收者可以是多个，具体的Receiver类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteReceiver1</span> <span class="keyword">extends</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteReceiver2</span> <span class="keyword">extends</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令角色是命令模式的核心，抽象的Command类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的Command类，可以在实际应用中扩展该命令类，在每个命令类中，通过构造函数定义该命令是针对哪个接收者发出的，定义一个命令接收的主题，这样调用者就仅需要实现命令的传递即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand1</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.find();</span><br><span class="line">        <span class="keyword">this</span>.receiver.add();</span><br><span class="line">        <span class="keyword">this</span>.receiver.delete();</span><br><span class="line">        <span class="keyword">this</span>.receiver.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand2</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.find();</span><br><span class="line">        <span class="keyword">this</span>.receiver.add();</span><br><span class="line">        <span class="keyword">this</span>.receiver.delete();</span><br><span class="line">        <span class="keyword">this</span>.receiver.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者Invoker类，不管什么命令都要接收、执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先声明调用者Invoker</span></span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">        <span class="comment">//定义接收者</span></span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> ConcreteReceiver1();</span><br><span class="line">        <span class="comment">//定义一个发送给接收者的命令</span></span><br><span class="line">        Command command = <span class="keyword">new</span> ConcreteCommand1(receiver);</span><br><span class="line">        <span class="comment">//把命令交给调用者去执行</span></span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令模式的<code>Receiver</code>在实际应用中可以被封装掉，从而减少高层模块Client类对低层模块Receiver角色类的依赖关系，提高系统整体的稳定性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个子类的全局共享变量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Receiver receiver;</span><br><span class="line">    <span class="comment">//实现类必须定义一个接收者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(Receiver _receiver)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = _receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> ConcreteReceiver1());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand1</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(receiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.find();</span><br><span class="line">        <span class="keyword">this</span>.receiver.add();</span><br><span class="line">        <span class="keyword">this</span>.receiver.delete();</span><br><span class="line">        <span class="keyword">this</span>.receiver.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>类间解耦：调用者角色和接收者角色之间没有任何依赖关系，调用者实现功能时只需要调用Command抽象类的execute方法即可，不需要了解到底是哪个接收者执行。</p><p>可扩展性：Command子类可以非常容易地扩展，而调用者Invoker和高层模块Client不产生严重代码耦合。</p><p>和其他模式结合会更优秀：命令模式和<strong>结合责任链模式</strong>，实现<strong>命令族解析任务</strong>；<strong>结合模板方法模式</strong>，可<strong>减少Command子类的膨胀</strong>问题。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Command子类会出现膨胀问题。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>命令模式在<code>Spring</code>框架<strong><code>JdbcTemplate</code></strong>源码的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action, <span class="keyword">boolean</span> closeResources)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">    Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line">    Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt = con.createStatement();</span><br><span class="line">        applyStatementSettings(stmt);</span><br><span class="line">        T result = action.doInStatement(stmt);</span><br><span class="line">        handleWarnings(stmt);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        String sql = getSql(action);</span><br><span class="line">        JdbcUtils.closeStatement(stmt);</span><br><span class="line">        stmt = <span class="keyword">null</span>;</span><br><span class="line">        DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">        con = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">throw</span> translateException(<span class="string">"StatementCallback"</span>, sql, ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeResources) &#123;</span><br><span class="line">            JdbcUtils.closeStatement(stmt);</span><br><span class="line">            DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">    Assert.notNull(sql, <span class="string">"SQL must not be null"</span>);</span><br><span class="line">    Assert.notNull(rse, <span class="string">"ResultSetExtractor must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Executing SQL query ["</span> + sql + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">SqlProvider</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs = stmt.executeQuery(sql);</span><br><span class="line">                <span class="keyword">return</span> rse.extractData(rs);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                JdbcUtils.closeResultSet(rs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sql;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> execute(<span class="keyword">new</span> QueryStatementCallback(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StatementCallback</code>接口，类似<code>Command</code>命令接口，<code>QueryStatementCallback</code>匿名内部类，实现了命令接口，同时也充当命令接收者；命令调用者是 <code>JdbcTemplate</code>，不同的实现<code>StatementCallback</code>接口的对象，对应不同的<code>doInStatement</code>实现逻辑；</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>实现在没有执行或执行后撤回，有两种方法可以解决，一是结合备忘录模式还原最后状态，该方法适合接收者为状态的变更情况，而不适合事件处理；二是通过增加一个新的命令，实现事件的回滚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;命令模式是一个高内聚的模式 ，将一个请求封装成一个对象， 从而让你使用不同的请求把客户端参数化， 对请&lt;br&gt;求排队或者记录请求日志， 可以提供命令的撤销和恢复功能 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../../images/设计模式/命令模式通用类图
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，命令模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/MySQL基础/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2021-06-18T07:38:50.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务基本特征ACID"><a href="#事务基本特征ACID" class="headerlink" title="事务基本特征ACID"></a>事务基本特征ACID</h3><p>事务是并发控制的单位，是用户定义的一个操作序列，这些操作要么都成功，要么都失败，是一个不可分割的工作单位。</p><ul><li><strong><code>Atomicity</code>原子性</strong>：事务中的包含的操作被看做是一个逻辑单元，要么全部成功，要么全部失败</li><li><strong><code>Isolation</code>隔离性</strong>：多个用户可以对同一个数据并发访问，而不破坏数据的正确性和完整性，并行事务的修改必须与其他并行事务的修改相互独立</li><li><strong><code>Consistency</code>一致性</strong>：合法的数据被写入到数据库，否则事务回滚到最初状态</li><li><strong><code>Durability</code>持久性</strong>：事务结束后，事务处理的结果必须能够得到固化</li></ul><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><h4 id="Read-Uncommitted读未提交"><a href="#Read-Uncommitted读未提交" class="headerlink" title="Read Uncommitted读未提交"></a><code>Read Uncommitted</code>读未提交</h4><p>级别最低，<strong>一个事务可以读到另外一个事务未提交的数据</strong>，事务在<strong>读数据</strong>的时候并<strong>未对数据加锁</strong>，在<strong>修改数据</strong>的时候只对数据增加<strong>行级共享锁</strong>。</p><p><strong>事务1</strong>读取某行记录时，<strong>事务2</strong>也能对这行记录进行读取、更新，因为<strong>事务1</strong>并未对数据增加任何锁；</p><p>当<strong>事务2</strong>对该记录进行更新时，<strong>事务1</strong>再次读取该记录，能读到<strong>事务2</strong>对该记录的修改版本，因为<strong>事务2</strong>只增加了共享读锁，<strong>事务1</strong>可以再增加共享读锁读取数据，即使该修改尚未被提交；</p><p><strong>事务1</strong>更新某行记录时，<strong>事务2</strong>不能对这行记录做更新，直到<strong>事务1</strong>结束，因为<strong>事务1</strong>对数据增加了共享读锁，<strong>事务2</strong>不能增加排他写锁进行数据的修改；</p><h4 id="Read-Committed读已提交"><a href="#Read-Committed读已提交" class="headerlink" title="Read Committed读已提交"></a><code>Read Committed</code>读已提交</h4><p>在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据，事务对当前被读取的数据加<strong>行级共享锁</strong>且当读到时才加锁，一旦读完该行，立即释放该行级共享锁；事务在<strong>更新某数据的瞬间</strong>，必须先对其加<strong>行级排他锁</strong>，直到事务结束才释放。</p><p><strong>事务1</strong>在读取某行记录的整个过程中，<strong>事务2</strong>都可以对该行记录进行读取，因为<strong>事务1</strong>对该行记录增加行级共享锁的情况下，<strong>事务2</strong>同样可以对该数据增加共享锁来读数据；</p><p><strong>事务1</strong>读取某行的一瞬间，<strong>事务2</strong>不能修改该行数据，但只要<strong>事务1</strong>读取完改行数据，<strong>事务2</strong>就可以对该行数据进行修改。因为<strong>事务1</strong>在读取的一瞬间会对数据增加共享锁，<strong>任何其他事务</strong>都不能对该行数据增加<strong>排他锁</strong>。但<strong>事务1</strong>只要读完该行数据，就会释放<strong>行级共享锁</strong>，一旦锁释放，<strong>事务2</strong>就可以对数据增加排他锁并修改数据；</p><p><strong>事务1</strong>更新某行记录时，<strong>事务2</strong>不能对这行记录做更新，直到<strong>事务1</strong>结束。因为<strong>事务1</strong>在更新数据时，会对该行数据增加<strong>排他锁</strong>，直到事务结束才会释放锁，所以在<strong>事务2</strong>没有提交之前，<strong>事务1</strong>都能不对数据增加<strong>共享锁</strong>进行数据的读取。所以<strong>可以解决脏读的现象</strong>，但<strong>不能解决不可重复读现象</strong>。</p><h4 id="Repeatable-Read可重复读"><a href="#Repeatable-Read可重复读" class="headerlink" title="Repeatable Read可重复读"></a><code>Repeatable Read</code>可重复读</h4><p>事务在读取某数据的瞬间，必须先对其加<strong>行级共享锁</strong>，直到事务结束才释放；事务在更新某数据的瞬间，必须先对其加<strong>行级排他锁</strong>，直到事务结束才释放。</p><p><strong>事务1</strong>在读取某行记录的整个过程中，<strong>事务2</strong>都可以对该行记录进行读取，因为<strong>事务1</strong>对该行记录增加行级共享锁的情况下，<strong>事务2</strong>同样可以对该数据增加共享锁来读数据；</p><p><strong>事务1</strong>在读取某行记录的整个过程中，<strong>事务2</strong>都不能修改该行数据，<strong>事务1</strong>在读取的<strong>整个过程</strong>会对数据增加共享锁，直到事务提交才会释放锁，所以整个过程中，<strong>任何其他事务</strong>都不能对该行数据增加排他锁。<strong>所以能解决不可重复读的读现象</strong>；</p><p><strong>事务1</strong>更新某行记录时，<strong>事务2</strong>不能对这行记录做更新，直到<strong>事务1</strong>结束，<strong>事务1</strong>在更新数据的时候，会对该行数据增加排他锁，直到事务结束才会释放锁，所以在<strong>事务2</strong>没有提交之前，<strong>事务1</strong>都能不对数据增加共享锁进行数据的读取。<strong>所以可以解决可重复读的现象</strong>，但<strong>不能解决幻读现象</strong>。</p><h4 id="Serializable串行化"><a href="#Serializable串行化" class="headerlink" title="Serializable串行化"></a><code>Serializable</code>串行化</h4><p>可序列化的隔离级别中可以解决幻读，产生幻读的原因是事务在进行范围查询的时候没有增加<strong>范围锁</strong>所以导致幻读，范围锁<strong><code>range-locks</code></strong>：给<code>SELECT</code> 的查询中使用一个<code>WHERE</code>子句描述范围加锁。事务在读取数据时，必须先对其加<strong>表级共享锁</strong> ，直到事务结束才释放；事务在更新数据时，必须先对其加<strong>表级排他锁</strong> ，直到事务结束才释放。</p><p><strong>事务1</strong>正在读取<strong>A表</strong>中的记录时，则<strong>事务2</strong>也能读取<strong>A表</strong>，但不能对<strong>A表</strong>做<strong>更新、新增、删除</strong>，直到<strong>事务1</strong>结束，因为<strong>事务1</strong>对表增加了<strong>表级共享锁</strong>，<strong>其他事务</strong>只能增加<strong>共享锁读取数据</strong>，不能进行其他任何操作；</p><p><strong>事务1</strong>正在<strong>更新A表</strong>中的记录时，则<strong>事务2</strong>不能读取<strong>A表</strong>的任意记录，更不可能对<strong>A表</strong>做更新、新增、删除，直到<strong>事务1</strong>结束，<strong>事务1</strong>对表增加了<strong>表级排他锁</strong>，其他事务不能对表增加共享锁或排他锁，也就无法进行任何操作；</p><p>可序列化解决了<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>等读现象，但无法读取其它事务已修改但未提交的记录，在当前事务完成之前，其它事务不能修改目前事务已读取的记录，在当前事务完成之前，其它事务所插入的新记录，其索引键值不能在当前事务的任何语句所读取的索引键范围中。</p><p>四种事务隔离级别从<strong>隔离程度上越来越高</strong>，但同时在<strong>并发性上也就越来越低</strong>。之所以有这么几种隔离级别，就是为了方便开发人员在开发过程中根据业务需要选择最合适的隔离级别。</p><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏读又称无效数据的读出，在一个事务的处理过程中读到另一个未提的交事务中的数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>在对数据库中的某个数据，一个事务范围类多次查询却返回了不同的数据值与脏读的区别是：不可重复读是读取了前一事务提交的数据</p><h4 id="虚读（幻读）"><a href="#虚读（幻读）" class="headerlink" title="虚读（幻读）"></a>虚读（幻读）</h4><p>事务在操作过程中两次查询，第二次查询的结果包含了第一次查询中未出现的数据或缺少第一次查询中出现的数据，一般解决幻读的方法是增加<strong>范围锁<code>RangeS</code></strong>，锁定检锁范围为只读，这样就避免了幻读。</p><h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><p><strong><code>1NF</code></strong>：强调的是列的原子性，即列不能够再分成其他几列<br><strong><code>2NF</code></strong>：表必须有一个主键，没有包含在主键中的列必须完全依赖于主键，而不只是依赖于主键的一部分<br><strong><code>3NF</code></strong>：非主键列必须直接依赖于主键列，不能存在传递依赖</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事务基本特征ACID&quot;&gt;&lt;a href=&quot;#事务基本特征ACID&quot; class=&quot;headerlink&quot; title=&quot;事务基本特征ACID&quot;&gt;&lt;/a&gt;事务基本特征ACID&lt;/h3&gt;&lt;p&gt;事务是并发控制的单位，是用户定义的一个操作序列，这些操作要么都成功，要么都失
      
    
    </summary>
    
      <category term="DB" scheme="https://yaoyinglong.github.io/categories/DB/"/>
    
    
      <category term="MySQL" scheme="https://yaoyinglong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁机制</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/MySQL锁机制/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2021-06-18T07:40:09.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><h3 id="页面锁"><a href="#页面锁" class="headerlink" title="页面锁"></a>页面锁</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;表级锁&quot;&gt;&lt;a href=&quot;#表级锁&quot; class=&quot;headerlink&quot; title=&quot;表级锁&quot;&gt;&lt;/a&gt;表级锁&lt;/h3&gt;&lt;h3 id=&quot;行级锁&quot;&gt;&lt;a href=&quot;#行级锁&quot; class=&quot;headerlink&quot; title=&quot;行级锁&quot;&gt;&lt;/a&gt;行级锁&lt;/h
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="MySQL" scheme="https://yaoyinglong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/Innodb/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/Innodb/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2021-06-18T03:05:28.563Z</updated>
    
    <content type="html"><![CDATA[<p>文件系统的<strong>最小单元是块</strong>，一个块的大小是<strong><code>4K</code></strong>，在文件系统中即使一个文件只有<strong>一个字节</strong>，但也不得不占<strong><code>4KB</code></strong>的磁盘空间。</p><p><code>InnoDB</code>存储引擎的<strong>最小存储单元是<code>Page</code>页</strong>，页可用于存<strong>放数据</strong>也可用于存放<strong>键值<code>+</code>指针</strong>，指针大小在<code>InnoDB</code>源码中设置为<strong><code>6</code>字节</strong>，在<code>B+</code>树中<strong>叶子节点存放数据</strong>，<strong>非叶子节点存放键值<code>+</code>指针</strong>，默认一个页的大小是<strong><code>16382</code></strong>即<strong><code>16K</code></strong>。<code>InnoDB</code>的所有数据文件后缀为<strong><code>ibd</code></strong>，其大小始终都是<strong><code>16K</code>的整倍数</strong>。数据表中的数据都是存储在页中，若一行数据大小为<code>1K</code>，则一页可存放16行这样的数据。</p><p>一个页中不可能所有空间都用于存放数据，它还会存放一些少量的其他字段比如<code>page level</code>，<code>index number</code>等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件系统的&lt;strong&gt;最小单元是块&lt;/strong&gt;，一个块的大小是&lt;strong&gt;&lt;code&gt;4K&lt;/code&gt;&lt;/strong&gt;，在文件系统中即使一个文件只有&lt;strong&gt;一个字节&lt;/strong&gt;，但也不得不占&lt;strong&gt;&lt;code&gt;4KB&lt;/code&gt;&lt;/
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="MySQL" scheme="https://yaoyinglong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="https://yaoyinglong.github.io/Blog/DB/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>https://yaoyinglong.github.io/Blog/DB/分库分表/</id>
    <published>2021-06-16T16:00:00.000Z</published>
    <updated>2021-06-17T06:32:16.932Z</updated>
    
    <content type="html"><![CDATA[<p>中大型项目中，一旦遇到数据量比较大，都知道对数据进行拆分，有<strong>垂直拆分</strong>和<strong>水平拆分</strong>两种。</p><p><strong>垂直拆分</strong>：从业务角度拆分多个库。</p><p><strong>水平拆分</strong>：同一个业务数据量大，进行水平拆分。</p><h3 id="分库分表方案"><a href="#分库分表方案" class="headerlink" title="分库分表方案"></a>分库分表方案</h3><p><strong><code>hash</code>取模</strong>和<strong><code>range</code>范围</strong>方案是分库分表方案中常用的方案；分库分表方案<strong>最主要</strong>就是<strong>路由算法</strong>，把路由的<code>key</code>按照指定的算法进行路由存放。</p><h4 id="hash取模方案"><a href="#hash取模方案" class="headerlink" title="hash取模方案"></a>hash取模方案</h4><p><strong><code>hash</code></strong>的方案就是对指定的<strong>路由key</strong>对<strong>分表总数进行取模</strong>，可以参考<strong><code>HashMap</code></strong>源码。</p><p><strong>优点</strong>：是可以<strong>将数据均匀放到各个分表中</strong>，<strong>不会出现热点问题</strong>。</p><p><strong>缺点</strong>：是数据<strong>迁移</strong>和<strong>扩容</strong>会比较困难。因为若之前分表是4，现在分表变成了8，由于取模基数变化导致之前的数据可能会找不到。要解决这样的问题，就需要将之前的数据重新按照新的取模基数做hash方案把数据进行迁移，放到新规划的分表中。但是对某些不允许停机做数据迁移的业务就会非常痛苦。</p><h4 id="range范围方案"><a href="#range范围方案" class="headerlink" title="range范围方案"></a>range范围方案</h4><p>range方案比较简单，就是<strong>把一定范围内的订单，存放到一个表中</strong>；如id=12放到0表中，id=1300万的放到1表中。设计这个方案时就是前期把表的范围设计好。通过id进行路由存放。</p><p><strong>优点</strong>：有利于将来的扩容，不需要做数据迁移。</p><p><strong>缺点</strong>：有热点问题。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>hash是可以解决数据均匀的问题，range可以解决数据迁移问题</strong>，可以将两种方案结合，在<strong>一定的范围内数据均匀</strong>，每次扩容肯定会<strong>先设计好这次扩容的范围大小</strong>，只要<strong>保证这次的范围内的数据均匀</strong>就行了。</p><p>可以先定义一个<strong><code>group</code>组</strong>的概念，首先通过范围range定位是哪个group组，然后根据hash方案定位是哪个DB，再根据range方案定位哪个Table。</p><p>例如对10进行取模，如果值为【0，1，2，3】就路由到DB_0，【4，5，6】路由到DB_1，【7，8，9】路由到DB_2。1000万以内的id都均匀的分配到DB_0，DB_1，DB_2三个数据库中的Table_0表中。</p><p><img src="../../../../images/DB/数据存储示意图.png" alt></p><p><strong>扩容</strong>的时候只需要再设计一个<strong><code>group02</code></strong>组就行了。</p><p>设计是比较简单的，就3张表，把group，DB，table之间建立好关联关系就行了。</p><p><img src="../../../../images/DB/group与DB的关系.png" alt="group与DB的关系"></p><p><img src="../../../../images/DB/table与db的关系.png" alt="table与db的关系"></p><p>在开发的时候把三张关联数据保存到缓存中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中大型项目中，一旦遇到数据量比较大，都知道对数据进行拆分，有&lt;strong&gt;垂直拆分&lt;/strong&gt;和&lt;strong&gt;水平拆分&lt;/strong&gt;两种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;垂直拆分&lt;/strong&gt;：从业务角度拆分多个库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;水平拆分
      
    
    </summary>
    
      <category term="DB" scheme="https://yaoyinglong.github.io/categories/DB/"/>
    
    
      <category term="DB" scheme="https://yaoyinglong.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>Spring初始化扩展</title>
    <link href="https://yaoyinglong.github.io/Blog/%E4%B8%AD%E9%97%B4%E4%BB%B6/Spring/Spring%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%A9%E5%B1%95/"/>
    <id>https://yaoyinglong.github.io/Blog/中间件/Spring/Spring初始化扩展/</id>
    <published>2021-06-16T16:00:00.000Z</published>
    <updated>2021-06-17T08:17:22.551Z</updated>
    
    <content type="html"><![CDATA[<p>经常需要在<strong>容器启动时做一些钩子动作</strong>，比如注册消息消费者，监听配置等。</p><h2 id="容器刷新完成扩展点"><a href="#容器刷新完成扩展点" class="headerlink" title="容器刷新完成扩展点"></a>容器刷新完成扩展点</h2><h3 id="监听容器刷新完成扩展点ApplicationListener-lt-ContextRefreshedEvent-gt"><a href="#监听容器刷新完成扩展点ApplicationListener-lt-ContextRefreshedEvent-gt" class="headerlink" title="监听容器刷新完成扩展点ApplicationListener&lt;ContextRefreshedEvent&gt;"></a>监听容器刷新完成扩展点<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code></h3><p>容器刷新成功意味着所有的<code>Bean</code>已初始化完成，当容器刷新之后<code>Spring</code>将会调用容器内所有实现了<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>的<code>Bean</code>的<code>onApplicationEvent</code>方法，应用程序可以以此达到监听容器初始化完成事件的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerExample</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"ApplicationListenerExample Startup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法，就会造成<code>onApplicationEvent</code>方法被执行两次。因为在<code>Spring MVC</code>项目中，系统会存在两个容器，一个是<code>root ApplicationContext</code>，一个是作为<code>root ApplicationContext</code>的子容器的<code>WebApplicationContext</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerExample</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getApplicationContext().getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"ApplicationListenerExample Startup"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h5><p>可以借助<code>Spring</code>以最小成本实现一个观察者模式，首先定义一个事件，然后注册一个监听器，最后发布事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotifyEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">NotifyEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(NotifyEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"NotifyListener Startup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext webApplicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NotifyEvent event = <span class="keyword">new</span> NotifyEvent(<span class="string">"object"</span>);</span><br><span class="line">        webApplicationContext.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot的CommandLineRunner接口"><a href="#SpringBoot的CommandLineRunner接口" class="headerlink" title="SpringBoot的CommandLineRunner接口"></a><code>SpringBoot</code>的<code>CommandLineRunner</code>接口</h3><p>当容器上下文初始化完成之后，<code>SpringBoot</code>也会调用所有实现了<code>CommandLineRunner</code>接口的<code>run</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandLineStartupRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"CommandLineStartupRunner Startup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个实现了<code>CommandLineRunner</code>的<code>Bean</code>的执行顺序可以根据<code>Bean</code>上的<code>@Order</code>注解调整。其<code>run</code>方法可以接受从控制台输入的参数，跟<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>这种扩展相比更加灵活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar CommandLineStartupRunner.jar abc abcd</span><br></pre></td></tr></table></figure><h3 id="SpringBoot的ApplicationRunner接口"><a href="#SpringBoot的ApplicationRunner接口" class="headerlink" title="SpringBoot的ApplicationRunner接口"></a><code>SpringBoot</code>的<code>ApplicationRunner</code>接口</h3><p><code>SpringBoot</code>的<code>CommandLineRunner</code>接口扩展类似，只不过接受参数是一个<code>ApplicationArguments</code>类，对控制台输入的参数提供了更好的封装，以<code>--</code>开头的被视为<strong>带选项的参数</strong>，否则是普通的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationStartupRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"ApplicationStartupRunner Startup: &#123;&#125;"</span>, args.getOptionNames());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输入参数示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ApplicationStartupRunner.jar abc abcd --autho=mark verbose</span><br></pre></td></tr></table></figure><h2 id="Bean初始化完成扩展点"><a href="#Bean初始化完成扩展点" class="headerlink" title="Bean初始化完成扩展点"></a><code>Bean</code>初始化完成扩展点</h2><h4 id="PostConstruct注解"><a href="#PostConstruct注解" class="headerlink" title="@PostConstruct注解"></a><code>@PostConstruct</code>注解</h4><p><code>@PostConstruct</code>注解一般放在<code>Bean</code>的方法上，被<code>@PostConstruct</code>修饰的方法会在<code>Bean</code>初始化后马上调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostConstructExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InitializingBean接口"><a href="#InitializingBean接口" class="headerlink" title="InitializingBean接口"></a><code>InitializingBean</code>接口</h4><p><code>InitializingBean</code>的用法基本上与<code>@PostConstruct</code>一致，只不过相应的<code>Bean</code>需要实现<code>afterPropertiesSet</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingBeanExample</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bean注解的初始化方法"><a href="#Bean注解的初始化方法" class="headerlink" title="@Bean注解的初始化方法"></a><code>@Bean</code>注解的初始化方法</h4><p>通过<code>@Bean</code>注入<code>Bean</code>的时候可以指定初始化方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitMethodExampleBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> InitMethodExampleBean <span class="title">initMethodExampleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> InitMethodExampleBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过构造函数注入"><a href="#通过构造函数注入" class="headerlink" title="通过构造函数注入"></a>通过构造函数注入</h4><p><code>Spring</code>也支持通过构造函数注入，我们可以把搞事情的代码写在构造函数中，同样能达到目的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorExampleBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstructorExampleBean</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bean</code>初始化完成扩展点执行顺序是：<strong>构造函数注入</strong>，<strong><code>@PostConstruct</code>注解</strong>，<strong><code>InitializingBean</code>接口</strong>，<strong><code>@Bean</code>注解的初始化方法</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经常需要在&lt;strong&gt;容器启动时做一些钩子动作&lt;/strong&gt;，比如注册消息消费者，监听配置等。&lt;/p&gt;
&lt;h2 id=&quot;容器刷新完成扩展点&quot;&gt;&lt;a href=&quot;#容器刷新完成扩展点&quot; class=&quot;headerlink&quot; title=&quot;容器刷新完成扩展点&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="中间件" scheme="https://yaoyinglong.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://yaoyinglong.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/中介者模式/</id>
    <published>2021-04-18T16:00:00.000Z</published>
    <updated>2021-04-19T07:43:20.096Z</updated>
    
    <content type="html"><![CDATA[<p>常常会出现好多对象之间存在<strong>复杂的交互关系</strong>，这种交互关系常常是<strong>网状结构</strong>，它要求每个对象都必须知道它需要交互的对象。若把这种<strong>网状结构</strong>改为<strong>星形结构</strong>的话，将大大降低它们之间的<strong>耦合性</strong>，这时只要找一个<strong>中介者</strong>就可以了。</p><p>定义一个中介对象来封装一系列对象之间的交互，中介者使各对象不需要显示地相互作用 ，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。<strong>中介者模式</strong>又叫<strong>调停模式</strong>，它是<strong>迪米特法则的典型应用</strong>。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>中介者模式由<strong>抽象中介者</strong>、<strong>具体中介者</strong>、<strong>抽象同事</strong>、<strong>具体同事</strong>几个主要角色。</p><p><strong>抽象中介者</strong>：定义统一的接口， 用于各同事角色之间的通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义同事类</span></span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleague1 c1;</span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleague2 c2;</span><br><span class="line">    <span class="comment">//中介者模式的业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体中介者</strong>：通过协调各同事角色实现协作行为， 因此它必须依赖于各个同事角色 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.c1.selfMethod1();</span><br><span class="line">        <span class="keyword">super</span>.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.c1.selfMethod1();</span><br><span class="line">        <span class="keyword">super</span>.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象同事类</strong>：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体同事类</strong>：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互，每个同事角色都知道中介者角色， 且与其他同事角色通信时， 一定要通过中介者角色协作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague1</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">        <span class="comment">//自己不能处理的业务逻辑， 委托给中介者处理</span></span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague2</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理自己的业务逻辑</span></span><br><span class="line">        <span class="comment">//自己不能处理的业务逻辑， 委托给中介者处理</span></span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomething2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>类之间各司其职，符合迪米特法则</p><p>降低了对象之间的耦合性，使得对象易于独立地被复用</p><p>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在<code>MVC</code>框架中，控制器（C）就是模型（M）和视图（V）的中介者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常常会出现好多对象之间存在&lt;strong&gt;复杂的交互关系&lt;/strong&gt;，这种交互关系常常是&lt;strong&gt;网状结构&lt;/strong&gt;，它要求每个对象都必须知道它需要交互的对象。若把这种&lt;strong&gt;网状结构&lt;/strong&gt;改为&lt;strong&gt;星形结构&lt;/strong
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，中介者模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/创建型模式/原型模式/</id>
    <published>2021-04-07T16:00:00.000Z</published>
    <updated>2021-04-08T10:26:12.777Z</updated>
    
    <content type="html"><![CDATA[<p>用一个已经创建的实例作为原型，<strong>通过复制该原型对象来创建一个和原型相同或相似的新对象</strong>。用这种方式创建对象非常高效，无须知道对象创建的细节。</p><p>在实际项目中，原型模式很少单独出现，一般是和<strong>工厂方法模式</strong>一起出现， 通过<code>clone</code>的方法创建一个对象，然后由工厂方法提供给调用者。 </p><p>原型模式简单程度仅次于<strong>单例模式</strong>和<strong>迭代器模式</strong>，<code>Java</code>中的<code>Object</code>类提供了浅克隆的<code>clone()</code>方法，具体原型类只要实现<strong><code>Cloneable</code></strong>接口就可实现对象的浅克隆。<code>Cloneable</code> 接口只是一个<strong>标记</strong>作用， 在<code>JVM</code>中具有这个标记的对象才有可能被拷贝。 </p><p><img src="../../../../images/设计模式/原型模式结构图.png" alt="原型模式结构图"></p><p>原型模式的克隆分为浅克隆和深克隆</p><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thing</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thing thing = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thing = (Thing) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thing</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thing thing = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thing = (Thing) <span class="keyword">super</span>.clone();</span><br><span class="line">            thing.arrayList = (ArrayList&lt;String&gt;)<span class="keyword">this</span>.arrayList.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象的<code>clone</code>与对象内的<code>final</code>关键字是有冲突的 ，要使用<code>clone</code>方法， 类的成员变量上不要增加<code>final</code>关键字</strong>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><code>Java</code>自带的原型模式基于内存二进制流的复制，在性能上比直接new一个对象更加优良，特别是要在一<br>个循环体内产生大量的对象时</p><p>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用。</p><p><strong>逃避构造函数的约束</strong>，直接在内存中拷贝， 构造函数是不会执行的</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>需要为每一个类都配置一个<strong><code>clone</code></strong>方法</p><p>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则</p><p>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>对象之间相同或相似，即只是个别的几个属性不同的时候</p><p>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源</p><p>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性</p><p>系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值</p><p>一个对象需要提供给其他对象访问， 而且各个调用者可能都需要修改其值时， 可以考虑使用原型模式拷贝多个对象供调用者使用 </p><p><code>JDK</code>源码中 <code>ArrayList</code>的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用一个已经创建的实例作为原型，&lt;strong&gt;通过复制该原型对象来创建一个和原型相同或相似的新对象&lt;/strong&gt;。用这种方式创建对象非常高效，无须知道对象创建的细节。&lt;/p&gt;
&lt;p&gt;在实际项目中，原型模式很少单独出现，一般是和&lt;strong&gt;工厂方法模式&lt;/strong
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，原型模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/%E9%9A%90%E5%BD%A2%E7%9C%BC%E9%95%9C%E6%94%BB%E7%95%A5/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/隐形眼镜攻略/</id>
    <published>2021-01-28T06:49:56.328Z</published>
    <updated>2021-01-28T07:18:47.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="隐形眼镜攻略"><a href="#隐形眼镜攻略" class="headerlink" title="隐形眼镜攻略"></a>隐形眼镜攻略</h1><h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p>硅水凝胶已经是目前主流材质，各方面参数、安全性、透氧性都远远好于水凝胶</p><p>新—水凝胶</p><h3 id="品牌"><a href="#品牌" class="headerlink" title="品牌"></a>品牌</h3><p>视康爱尔康、库博、强生安视优、博士伦</p><h3 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h3><p>为了更健康的使用隐形眼镜，请选用<strong>短周期产品</strong>，避免使用年抛、半年抛、季抛等传统产品，选择月抛、双周抛和日抛产品，减少因蛋白质、脂质沉淀或镜片发生的破损引发的问题，同时长周期镜片大多都是使用低含水量，较硬的HEMA材质，透氧性较差，很多产品远达不到足够的安全佩戴含氧量，长期佩戴必然会导致眼红、干涩、甚至引发更严重的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;隐形眼镜攻略&quot;&gt;&lt;a href=&quot;#隐形眼镜攻略&quot; class=&quot;headerlink&quot; title=&quot;隐形眼镜攻略&quot;&gt;&lt;/a&gt;隐形眼镜攻略&lt;/h1&gt;&lt;h3 id=&quot;材质&quot;&gt;&lt;a href=&quot;#材质&quot; class=&quot;headerlink&quot; title=&quot;材质&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="自度" scheme="https://yaoyinglong.github.io/categories/%E8%87%AA%E5%BA%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>2020总结</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%87%AA%E5%BA%A6/2020%E6%80%BB%E7%BB%93/"/>
    <id>https://yaoyinglong.github.io/Blog/自度/2020总结/</id>
    <published>2021-01-25T16:00:00.000Z</published>
    <updated>2021-01-22T02:12:02.393Z</updated>
    
    <content type="html"><![CDATA[<p>之前没有写年终总结的习惯，但是今年发生了太多的事，对于我而言算是意义非凡的一年吧。</p><p>总的来说今年算是梦幻开局，平淡结束吧。</p><p>去年底和今年初疫情的原因，开始有点人心惶惶，但是过年没法走亲戚以及开年延迟上班在家办公对于一个宅男来说算是一种慰藉。</p><p>今年经历了曾经从来没有经历过的事，虽然最后还是以失败告终，不去追究谁对谁错，每个人都有自己的选择，有些是没有经历过真的是不太懂，失去过后才来后悔，在那段时间里我不断自我反省，到处寻找答案，甚至买了好几本书看，渐渐的可能找到了一些答案吧。这段经历使我成长了好多好多，撞碎了一些我以为的思想。不再对任何人任何事一开始抱有比较高的期望，逐渐明悟自己想要的是什么，对待感情不再那么执着较真。</p><p>为了转移注意力开始学习，买了差不多二三十本专业的书来看，去LeetCode刷题。</p><p>感谢一路上有人一直带我走出我自己的世界，面对真实的自己，人前人后展现更加真实的自己。可能很多人对我有比较大的误解，觉得我没什么主见什么都听别人的感觉，在意一个人的时候很容易全部注意力都在她身上，总是把她的一举一动一言一行看得很重要所以很容易失去了自我，显得自己很没有主见，</p><p>曾经我是一个极度容易尴尬的人，经过今年的成长，参加了很多活动，内心平静自然多了。</p><p>每次要写点东西的时候总是感觉有好多东西要说，但是真正写的时候又说不出来什么，感觉好像很多事又不值得一说反正也就那样。2020就这样潦草结尾吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前没有写年终总结的习惯，但是今年发生了太多的事，对于我而言算是意义非凡的一年吧。&lt;/p&gt;
&lt;p&gt;总的来说今年算是梦幻开局，平淡结束吧。&lt;/p&gt;
&lt;p&gt;去年底和今年初疫情的原因，开始有点人心惶惶，但是过年没法走亲戚以及开年延迟上班在家办公对于一个宅男来说算是一种慰藉。&lt;/p
      
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/结构型模式/代理模式/</id>
    <published>2020-11-04T16:00:00.000Z</published>
    <updated>2021-04-09T06:08:06.870Z</updated>
    
    <content type="html"><![CDATA[<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>代理模式是一个使用率非常高的模式，<strong>为其他对象提供一种代理以控制这个对象的访问</strong>。代理模式也叫做<strong>委托模式</strong>，它是一项<strong>基本设计技巧</strong>。许多其他的模式，如<strong>状态模式</strong>、<strong>策略模式</strong>、<strong>访问者模式</strong>本质上是在<strong>更特殊的场合</strong>采用了<strong>委托模式</strong>，而且在日常的应用中，代理模式可以提供非常好的访问控制。</p><p><img src="../../../../images/设计模式/代理模式类图.png" alt="代理模式类图"></p><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问；</p><p>抽象主题类<strong><code>Subject</code></strong>通过<strong>接口</strong>或<strong>抽象类</strong>声明<strong>真实主题</strong>和<strong>代理对象</strong>实现的业务方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实主题类<code>RealSubject</code>实现了<strong>抽象主题中的具体业务</strong>，是代理对象所代表的真实对象，是最终要引用的对象，为<strong>具体主题角色</strong>，也叫<strong>被委托角色</strong>或<strong>被代理角色</strong>，是<strong>业务逻辑的具体执行者</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类<code>Proxy</code>提供了<strong>与真实主题相同的接口</strong>，其内部<strong>含有对真实主题的引用</strong>，它可以<strong>访问</strong>、<strong>控制</strong>或<strong>扩展</strong>真实主题的功能，也叫<strong>委托类</strong>或<strong>代理类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before();</span><br><span class="line">        <span class="keyword">this</span>.subject.request();</span><br><span class="line">        <span class="keyword">this</span>.after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知；一个代理类可以<strong>代理多个</strong>被委托者或被代理者， 因此一个代理类具体代理哪个真实主题角色， 是由场景类决定。 </p><p>代理模式优点<strong>职责清晰</strong>，真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务；<strong>高扩展性</strong>；<strong>智能化</strong>。</p><p>根据代理的创建时期，代理模式分为<strong>静态代理</strong>和<strong>动态代理</strong>，还可以通过<strong>反射</strong>的方式实现<strong><a href="../../Java/基础/动态代理">动态代理</a></strong></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</p><p>可以扩展目标对象的功能</p><p>能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>会造成系统设计中类的数量增加</p><p>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢</p><p>增加了系统的复杂度</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：<strong>保护目标对象</strong>，<strong>增强目标对象</strong>。</p><ul><li>远程代理，通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。</li><li>虚拟代理，通常用于要创建的目标对象开销很大时。</li><li>安全代理，通常用于控制不同种类客户对真实对象的访问权限。</li><li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。</li><li>延迟加载，指为了提高系统的性能，延迟对目标的加载。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于某些原因需要给某对象提供一个代理以控制对该对象的访问。访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。&lt;/p&gt;
&lt;p&gt;代理模式是一个使用率非常高的模式，&lt;strong&gt;为其他对象提供一种代理以控制这个对象的访问&lt;/strong&gt;。代理模
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，代理模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/创建型模式/建造者模式/</id>
    <published>2020-11-03T16:00:00.000Z</published>
    <updated>2021-04-06T02:48:47.440Z</updated>
    
    <content type="html"><![CDATA[<p><strong>建造者模式</strong>也叫<strong>生成器模式</strong>，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<strong>当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。</strong></p><p><img src="../../../../images/设计模式/建造者模式类图.png" alt="建造者模式类图"></p><p>车辆模型抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; sequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequence = sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String actionName : sequence) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"stop"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"alarm"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.alarm();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"engineBoom"</span>.equals(actionName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.engineBoom();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>车辆模型的具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzModel</span> <span class="keyword">extends</span> <span class="title">CarModel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz开动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz停车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz鸣笛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz发动引擎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWModel</span> <span class="keyword">extends</span> <span class="title">CarModel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW开动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW停车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW鸣笛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW发动引擎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象汽车的组装者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; seqence)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CarModel <span class="title">getCarModel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的车的组装者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzBuilder</span> <span class="keyword">extends</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BenzModel benz = <span class="keyword">new</span> BenzModel();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.benz.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CarModel <span class="title">getCarModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.benz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWBuilder</span> <span class="keyword">extends</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BMWModel bmw = <span class="keyword">new</span> BMWModel();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(List&lt;String&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bmw.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CarModel <span class="title">getCarModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bmw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">sequence.add(<span class="string">"engineBoom"</span>);</span><br><span class="line">sequence.add(<span class="string">"start"</span>);</span><br><span class="line">sequence.add(<span class="string">"stop"</span>);</span><br><span class="line">BenzBuilder benzBuilder = <span class="keyword">new</span> BenzBuilder();</span><br><span class="line">benzBuilder.setSequence(sequence);</span><br><span class="line">BenzModel benz = (BenzModel)benzBuilder.getCarModel();</span><br><span class="line">benz.run();</span><br><span class="line">BMWBuilder bmwBuilder = <span class="keyword">new</span> BMWBuilder();</span><br><span class="line">bmwBuilder.setSequence(sequence);</span><br><span class="line">BMWModel bmw = (BMWModel)bmwBuilder.getCarModel();</span><br><span class="line">bmw.run();</span><br></pre></td></tr></table></figure><p><code>CarModel</code>及其之类都是产品类，<code>CarBuilder</code>是抽象的建造者，用于规范产品的组建，其子类是具体的建造者，实现抽象类定义的所有，并返回一个组建好的对象。</p><p>建造者模式有良好的<strong>封装性</strong>，使用建造者模式可以使客户端不必知道产品内部组成的细节，建造者是独立的<strong>容易扩展</strong>，因此也<strong>便于控制细节风险</strong>，对建造过程逐步细化，而不对其他的模式产生任何影响。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>相同的方法，不同的执行顺序</strong>，产生不同的事件结果时。</li><li><strong>多个部件或零件，都可以装配到一个对象中</strong>，但是产生的<strong>运行结果又不相同</strong>时。</li><li><strong>产品类非常复杂</strong>，或者产品类中的<strong>调用顺序</strong>不同产生了不同的效能。</li><li>在对象创建过程中会<strong>使用到系统中的一些其他对象</strong>，这些对象在产品对象的<strong>创建过程中不易得到</strong>时，也可以采用建造者模式封装该对象的创建过程，该种场景只能是一个补偿方法。</li></ul><h3 id="与工厂模式的区别"><a href="#与工厂模式的区别" class="headerlink" title="与工厂模式的区别"></a>与工厂模式的区别</h3><p><strong>建造者模式</strong>最主要的功能是<strong>基本方法的调用顺序安排</strong>，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同；而<strong>工厂方法</strong>则重点是<strong>创建</strong>，创建零件是它的主要职责，组装顺序则不是它关心的。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;建造者模式&lt;/strong&gt;也叫&lt;strong&gt;生成器模式&lt;/strong&gt;，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;strong&gt;当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。&lt;/
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，建造者模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/行为型模式/模板方法模式/</id>
    <published>2020-11-02T16:00:00.000Z</published>
    <updated>2021-04-06T01:42:09.059Z</updated>
    
    <content type="html"><![CDATA[<p><strong>模板方法模式</strong>非常简单应用非常广泛的模式，定义一个操作中的<strong>算法框架</strong>，而将一些步骤<strong>延迟到子类</strong>中。使得子类可以<strong>不改变一个算法的结构</strong>即可重定义该算法的某些特定步骤。</p><p><img src="../../../../images/设计模式/模板方法模式类图.png" alt="模板方法模式类图"></p><p><code>AbstractClass</code>叫做<strong>抽象模板</strong>，其方法分为<strong>基本方法</strong>和<strong>模板方法</strong>两类。<strong>基本方法</strong>也叫做基本操作，由子类实现的方法，且在模板方法中被调用。<strong>模板方法</strong>可以有一个或几个，用于实现对基本方法的调度，完成固定的逻辑。为了防止恶意操作，一般模板方法都使用<code>final</code>关键之修饰，防止被覆盖。</p><p>抽象模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareGotoSchool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        derssUp();</span><br><span class="line">        eatBreakfast();</span><br><span class="line">        tackThings();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">derssUp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">tackThings</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">derssUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿衣服"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃妈妈做的早餐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tackThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"背书包，带上家庭作业和红领巾"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">derssUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿工作服"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"做早饭，照顾孩子吃早饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tackThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带上昨天晚上准备的考卷"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.prepareGotoSchool();</span><br><span class="line">Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">teacher.prepareGotoSchool();</span><br></pre></td></tr></table></figure><p><strong>抽象模板</strong>中的<strong>基本方法</strong>尽量设计为<code>protected</code>类型，符合<strong>迪米特法则</strong>，不需要暴露的属性或方法尽量不要设置为protected类型。实现类若非必要，尽量不要扩大父类中的访问权限。 </p><p>模板方法模式可<strong>封装不变部分</strong>，<strong>扩展可变部分</strong>；可提取公共部分代码，便于维护；<strong>行为由父类控制，子类实现</strong>。但一般的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，<strong>子类执行的结果影响了父类的结果</strong>，也就是子类对父类产生了影响，在复杂的项目中，会带来代码阅读的难度。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>多个子类有公有的方法，且逻辑基本相同时</li><li>重要、复杂的算发，可以把核心算法设计为模板方法，周边的相关细节功能由各个子类实现</li><li>重构时，模板方法模式时一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为</li></ul><p>在Spring源码中<strong><code>refresh()</code></strong>就是典型的模板方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span>, <span class="title">ifecycle</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.refresh"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            prepareRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">                StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.beans.post-process"</span>);</span><br><span class="line">                <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line">                beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                initMessageSource();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                onRefresh();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                registerListeners();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                                <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">                destroyBeans();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">                <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">                resetCommonCaches();</span><br><span class="line">                contextRefresh.end();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>JDK</code></strong>中<strong><code>HashMap</code></strong>、<strong><code>Map</code></strong>、<strong><code>AQS</code></strong>中都有用到模板方法设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS中用到的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK8 Map中的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">return</span> (((v = get(key)) != <span class="keyword">null</span>) || containsKey(key))</span><br><span class="line">        ? v : defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt;非常简单应用非常广泛的模式，定义一个操作中的&lt;strong&gt;算法框架&lt;/strong&gt;，而将一些步骤&lt;strong&gt;延迟到子类&lt;/strong&gt;中。使得子类可以&lt;strong&gt;不改变一个算法的结构&lt;/strong&gt;即可重定义该算
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，模板方法模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://yaoyinglong.github.io/Blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yaoyinglong.github.io/Blog/设计模式/创建型模式/工厂模式/</id>
    <published>2020-11-02T16:00:00.000Z</published>
    <updated>2020-11-03T08:00:50.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><strong>工厂方法模式</strong>使用的频率非常高 ，用于创建对象的接口， 让<strong>子类</strong>决定实例化哪一个类。 工厂方法使一个<strong>类的实例化延迟到其子类</strong> 。用于<strong>封装</strong>和<strong>管理</strong>对象的创建，是一种<strong>创建模式</strong>。是<strong>典型的解耦框架</strong>，在需要<strong>灵活的</strong>、<strong>可扩展</strong>的框架时可以采用，可以用在<strong>异构项目</strong>中，可以使用在测试驱动的开发框架下。</p><p><img src="../../../../images/设计模式/工厂方法模式类图.png" alt="工厂方法模式类图"></p><p>抽象产品类，抽象人种类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的产品类可以有多个， 都继承于抽象产品类，具体的人种类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YellowHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂类负责定义产品对象的产生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体如何产生一个产品的对象， 是由具体的工厂类实现的，具体的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"人种生成错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AbstractHumanFactory YinYangLu = <span class="keyword">new</span> HumanFactory();</span><br><span class="line">Human whiteHuman = YinYangLu.createHuman(WhiteHuman.class);</span><br><span class="line">whiteHuman.getColor();</span><br><span class="line">whiteHuman.talk();</span><br><span class="line">Human blackHuman = YinYangLu.createHuman(BlackHuman.class);</span><br><span class="line">blackHuman.getColor();</span><br><span class="line">blackHuman.talk();</span><br><span class="line">Human yellowHuman = YinYangLu.createHuman(YellowHuman.class);</span><br><span class="line">yellowHuman.getColor();</span><br><span class="line">yellowHuman.talk();</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>良好的<strong>封装性</strong>， 代码结构清晰</li><li>良好的<strong>扩展性</strong>，增加产品类， 只要适当地修改具体的工厂类或扩展一个工厂类</li><li><strong>屏蔽产品类</strong>，产品类的实现如何变化， 调用者都不需要关心，上层模块不发生变化</li><li>典型的<strong>解耦框架</strong>，高层模块值需要知道产品的抽象类，符合迪米特法则、依赖倒置原则、里氏替换原则</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>需要<strong>生成对象</strong>的地方都可以使用， 但是需要慎重考虑是否要增加一个工厂类进行管理， 增加代码的复杂度</li><li>需要<strong>灵活</strong>的、 <strong>可扩展</strong>的框架时</li><li><strong>异构项目中</strong>，如通过<code>WebService</code>与一个非Java的项目交互 </li><li>可以使用在<strong>测试驱动开发的框架下</strong></li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>工厂方法模式有很多扩展，且与其他模式结合使用威力更大，可将其<strong>缩小为简单工厂模式</strong>，可<strong>升级为多个工厂类</strong>，可<strong>替代单例模式</strong>，可<strong>延迟初始化</strong>。</p><h4 id="缩小为简单工厂模式"><a href="#缩小为简单工厂模式" class="headerlink" title="缩小为简单工厂模式"></a>缩小为简单工厂模式</h4><p>该模式是工厂方法模式的弱化，<strong>简单工厂模式</strong>又叫<strong>静态工厂模式</strong>，仅简单的对<strong>不同类</strong>对象的创建进行了简单的封装。<strong>缺点</strong>是<strong>工厂类的扩展比较困难</strong>， <strong>不符合开闭原则</strong>。 </p><p><img src="../../../../images/设计模式/简单工厂模式类图.png" alt="简单工厂模式类图"></p><p>简单工厂模式相对于工厂方法模式，去掉了<code>AbstractHumanFactory</code>抽象类， 同时把<code>createHuman</code>方法设置为静态类型， 简化了类的创建过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"人种生成错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Human whiteHuman = HumanFactory.createHuman(WhiteHuman.class);</span><br><span class="line">whiteHuman.getColor();</span><br><span class="line">whiteHuman.talk();</span><br><span class="line">Human blackHuman = HumanFactory.createHuman(BlackHuman.class);</span><br><span class="line">blackHuman.getColor();</span><br><span class="line">blackHuman.talk();</span><br><span class="line">Human yellowHuman = HumanFactory.createHuman(YellowHuman.class);</span><br><span class="line">yellowHuman.getColor();</span><br><span class="line">yellowHuman.talk();</span><br></pre></td></tr></table></figure><h4 id="升级为多个工厂类"><a href="#升级为多个工厂类" class="headerlink" title="升级为多个工厂类"></a>升级为多个工厂类</h4><p>在相对比较复杂的项目中，经常遇到初始化一个对象很耗费精力的情况，所有产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为每个产品定义一个创造者， 然后由调用者自己去选择与哪个工厂方法关联。</p><p><strong>多工厂模式</strong>的工厂抽象类，抽象方法中已经<strong>不再需要传递相关参数</strong>了， 因为每一个具体的工厂都已经非常明确自己的职责。但也给<strong>可扩展性</strong>和<strong>可维护性</strong>带来了一定的影响。</p><p><img src="../../../../images/设计模式/多个工厂类类图.png" alt="多个工厂类类图"></p><p>多工厂模式的抽象工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Human <span class="title">createHuman</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>黑色人种的创建工厂实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackHumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>黄色人种的创建工厂实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YellowHumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>白色人种的创建工厂实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteHumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Human whiteHuman = (<span class="keyword">new</span> WhiteHumanFactory()).createHuman();</span><br><span class="line">whiteHuman.getColor();</span><br><span class="line">whiteHuman.talk();</span><br><span class="line">Human blackHuman = (<span class="keyword">new</span> BlackHumanFactory()).createHuman();</span><br><span class="line">blackHuman.getColor();</span><br><span class="line">blackHuman.talk();</span><br><span class="line">Human yellowHuman = (<span class="keyword">new</span> YellowHumanFactory()).createHuman();</span><br><span class="line">yellowHuman.getColor();</span><br><span class="line">yellowHuman.talk();</span><br></pre></td></tr></table></figure><p>在复杂的应用中一般采用多工厂的方法， 然后再增加一个协调类， 避免调用者与各个子工厂交流， 协调类的作用是封装子工厂类， 对高层模块提供统一的访问接口。</p><h4 id="替代单例模式"><a href="#替代单例模式" class="headerlink" title="替代单例模式"></a>替代单例模式</h4><p>通过获得类构造器， 然后设置访问权限， 生成一个对象， 然后提供外部访问， 保证内存中的对象唯一。 通过工厂方法模式创建了一个单例对象， 该框架可以继续扩展， 在一个项目中可以产生一个<strong>单例构造器</strong>， 所有需要产生单例的类都遵循一定的规则 ， 然后通过扩展该框架。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cl= Class.forName(Singleton.class.getName());</span><br><span class="line">            <span class="comment">// 获得无参构造</span></span><br><span class="line">            Constructor constructor = cl.getDeclaredConstructor();</span><br><span class="line">            <span class="comment">// 设置无参构造是可访问的</span></span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 产生一个实例对象</span></span><br><span class="line">            singleton = (Singleton)constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h4><p>一个对象被消费完后，并不立即释放，工厂类保持其初始状态，等待再次被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Human&gt; humanMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Human <span class="title">createHuman</span><span class="params">(String type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Human human;</span><br><span class="line">        <span class="keyword">if</span> (humanMap.containsKey(type)) &#123;</span><br><span class="line">            human = humanMap.get(type);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (type.equals(<span class="string">"BlackHuman"</span>)) &#123;</span><br><span class="line">                human = <span class="keyword">new</span> BlackHuman();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"WhiteHuman"</span>)) &#123;</span><br><span class="line">                human = <span class="keyword">new</span> WhiteHuman();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                human = <span class="keyword">new</span> YellowHuman();</span><br><span class="line">            &#125;</span><br><span class="line">            humanMap.put(type, human);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> human;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟加载框架是可扩展的， 例如限制某一个产品类的最大实例化数量， 可以通过判断Map中已有的对象数量来实现，还可以用在<strong>对象初始化比较复杂</strong>的情况下， 例如<strong>硬件访问</strong>， 涉及多方面的交互， 则可以通过延迟加载降低对象的<strong>产生和销毁</strong>带来的<strong>复杂性</strong>。</p><hr><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>抽象工厂模式</strong>是一种比较常用的模式，为创建一组<strong>相关</strong>或<strong>相互依赖</strong>的对象提供一个接口， 且<strong>无须指定它们</strong><br><strong>的具体类</strong>。 当一个对象族有相同的约束时可以使用抽象工厂模式。</p><p>优点<strong>封装性</strong>，产品的具体实现细节高层模块不需要关心；产品族内的约束为<strong>非公开</strong>状态。缺点<strong>产品族扩展非常困难</strong>，严重违反开闭原则。</p><p><img src="../../../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="抽象工厂模式类图"></p><p><strong>抽象工厂模式</strong>是<strong>工厂方法模式</strong>的<strong>升级版</strong>， 在有多个业务品种、 业务分类时， 通过抽象工厂模式产生需要的对象是一种非常好的解决方式。</p><p>人种接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人种有三个抽象类， 负责人种的抽象属性定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBlackHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黑色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractWhiteHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是白色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractYellowHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是黄色人种"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个抽象类都有两个实现类， 分别实现公共的最细节、 最具体的事物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleYellowHuman</span> <span class="keyword">extends</span> <span class="title">AbstractYellowHuman</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄种女人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaleYellowHuman</span> <span class="keyword">extends</span> <span class="title">AbstractYellowHuman</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄种男人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>制造人类的抽象工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Human <span class="title">createYellowHuman</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Human <span class="title">createWhiteHuman</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Human <span class="title">createBlackHuman</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>制造男人和女人的具体工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleFactory</span> <span class="keyword">implements</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createYellowHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FemaleYellowHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createWhiteHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FemaleWhiteHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createBlackHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FemaleBlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaleFactory</span> <span class="keyword">implements</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createYellowHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleYellowHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createWhiteHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleWhiteHuman();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createBlackHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleBlackHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HumanFactory maleHumanFactory = <span class="keyword">new</span> MaleFactory();</span><br><span class="line">HumanFactory femaleHumanFactory = <span class="keyword">new</span> FemaleFactory();</span><br><span class="line">Human maleYellowHuman = maleHumanFactory.createYellowHuman();</span><br><span class="line">Human femaleYellowHuman = femaleHumanFactory.createYellowHuman();</span><br><span class="line">femaleYellowHuman.getColor();</span><br><span class="line">femaleYellowHuman.talk();</span><br><span class="line">femaleYellowHuman.getSex();</span><br><span class="line">maleYellowHuman.getColor();</span><br><span class="line">maleYellowHuman.talk();</span><br><span class="line">maleYellowHuman.getSex();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工厂方法模式&quot;&gt;&lt;a href=&quot;#工厂方法模式&quot; class=&quot;headerlink&quot; title=&quot;工厂方法模式&quot;&gt;&lt;/a&gt;工厂方法模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;工厂方法模式&lt;/strong&gt;使用的频率非常高 ，用于创建对象的接口， 让&lt;strong&gt;子
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://yaoyinglong.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，工厂方法模式，抽象工厂模式" scheme="https://yaoyinglong.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>锁优化</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/并发/锁优化/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2020-10-30T06:43:58.459Z</updated>
    
    <content type="html"><![CDATA[<p><strong>高效并发</strong>是从<code>JDK1.5</code>到<code>JDK1.6</code>的一个重要改进，<code>HotSpot</code>虚拟机为了<strong>在线程之间更高效地共享数据</strong>，以及<strong>解决竞争问题</strong>，从而<strong>提高程序的执行效率</strong>在该版本上花费了大量精力去<strong>实现各种锁优化技术</strong>，如<strong>适应性自旋</strong>、<strong>锁消除</strong>、<strong>锁粗化</strong>、<strong>轻量级锁</strong>和<strong>偏向锁</strong>等。</p><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p><strong>互斥同步</strong>对<strong>性能最大的影响</strong>是<strong>阻塞的实现</strong>，<strong>挂起线程</strong>和<strong>恢复线程</strong>的操作都需要转入<strong>内核态</strong>中完成，这会给操作系统的并发性能带来很大的压力。在许多应用上，<strong>共享数据的锁定状态只会持续很短一段时间</strong>，为了这段时间去<strong>挂起</strong>和<strong>恢复</strong>线程<strong>并不值得</strong>。</p><p>两个或以上的线程同时并行执行，可以让后面请求锁的那个线程<strong>不放弃处理器执行时间</strong>，而是<strong>执行一个忙循环</strong>，也就是所谓的<strong>自旋</strong>，看看<strong>持有锁</strong>的线程<strong>是否会很快就释放锁</strong>，这项技术就是所谓的<strong>自旋锁</strong>。</p><p><strong>自旋锁</strong>在<code>JDK1.4.2</code>中引入但<strong>默认关闭</strong>，使用<code>-XX:UseSpinning</code>参数开启，<strong><code>JDK1.6</code>默认开启</strong>自旋锁。自旋等待不能代替阻塞，自旋等待本身虽然避免了线程切换的开销，但<strong>还是要占用处理器时间</strong>，若锁被占用的时间<strong>很短</strong>，<strong>自旋等待的效果会非常好</strong>，若锁被占用的时间<strong>很长</strong>，自旋等待的线程只会白白消耗处理器资源，<strong>反而带来性能上的浪费</strong>。</p><p><strong>自旋等待的时间</strong>是有一定的<strong>限度</strong>，若自旋<strong>超过了限定的次数</strong>仍然<strong>没有成功获得锁</strong>，就<strong>使用传统的方式挂起线程</strong>。<strong>自旋次数默认为<code>10</code>次</strong>，可使用参数<strong><code>-XX:PreBlockSpin</code></strong>来更改。</p><p><code>JDK1.6</code>引入了<strong>自适应的自旋锁</strong>，自适应意味着<strong>自旋</strong>的<strong>时间不再固定</strong>，而是由<strong>前一次</strong>在<strong>同一个锁上</strong>的<strong>自旋时间</strong>及<strong>锁的拥有者的状态来</strong>决定。若在同一个锁对象上，<strong>上一次是通过自旋等待获得的锁</strong>，且持有锁的<strong>线程正在运行中</strong>，则虚拟机将<strong>认为这次自旋锁也很有可能再次成功</strong>，进而它将<strong>运行自旋等待持续相对更长的时间</strong>。且若对于某个锁，通过自旋的方式<strong>很少成功获得过锁</strong>，则在以后要获取该锁时将可能<strong>省略自旋过程</strong>，以<strong>避免浪费处理器资源</strong>。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁的消除是指虚拟机<strong>即时编译器</strong>在运行时，对一些<strong>代码上要求同步</strong>，但被检测到<strong>不可能</strong>存在<strong>共享数据竞争</strong>的锁进行消除。锁消除<strong>主要</strong>判定<strong>依据</strong>来源于<strong>逃逸分析</strong>的数据支持，若判断在一段代码中，<strong>堆</strong>上所有数据都<strong>不会逃逸</strong>出去从而被其他线程访问到，即可以将其当做栈上数据对待，认为其是私有的，即可进行锁消除。</p><p>Java中有许多同步措施并不是程序员自己加入的，且同步代码在Java中是普遍存在的。例如最简单的String字符串的相加，由于String是不可变的类，在<code>JDK1.5</code>后将转化为<code>StringBuilder</code>对象的连续<code>append</code>操作，而每个<code>append</code>方法中都有一个同步块。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上总是推荐将<strong>同步块</strong>的<strong>作用范围</strong>限制得<strong>尽可能小</strong>，即只在<strong>共享数据</strong>的实际作用域中才进行同步，是为了使得需要同步得操作数量尽可能小，当存在竞争时，等待锁的线程也能<strong>尽可能快的拿到锁</strong>。</p><p>但若一系列<strong>连续操作</strong>都对<strong>同一个对象反复加锁和解锁</strong>，甚至<strong>加锁操作</strong>是出现在<strong>循环体</strong>中，即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><p>如连续的<code>StringBuilder</code>的<code>append</code>方法，若虚拟机检查到有这样<strong>一串零碎的操作都对同一个对象加锁</strong>，将会把加锁同步得范围<strong>粗化到整个操作序列的外部</strong>。连续的<code>StringBuilder</code>的<code>append</code>操作会扩展到第一个<code>append</code>操作之前直到最后一个<code>append</code>操作之后，这样加一次锁即可。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>传统</strong>的锁机制成为<strong>重量级锁</strong>，<strong>轻量级</strong>是相对于使用<strong>操作系统互斥量</strong>来实现的<strong>传统锁</strong>而言的，是<code>JDK1.6</code>加入的新型锁机制。轻量级锁<strong>并不是</strong>用来<strong>代替</strong>重量级锁的，其本意是在<strong>没有多线程竞争</strong>的前提下，<strong>减少重量级锁</strong>使操作系统互斥量产生的性能消耗。</p><p><strong><a href="../../VM/堆中对象分配&amp;布局&amp;访问#对象的内存布局">对象头</a></strong>中用于存储对象自身的<strong>运行时数据</strong>信息是实现<strong>轻量级锁</strong>和<strong>偏向锁</strong>的关键，官方称为<code>Mark Word</code>。对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，<code>Mark Word</code>被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><p>在<code>32</code>位<code>HotSpot</code>虚拟机中， 对象<strong>未被锁定</strong>的状态下，<code>Mark Word</code>的<strong><code>32</code>比特</strong>空间里的<strong><code>25</code>比特</strong>将用于存储<strong>对象哈希码</strong>， <strong><code>4</code>比特</strong>用于存储对象<strong>分代年龄</strong>， <strong><code>2</code>比特</strong>用于存储<strong>锁标志位</strong>， <strong><code>1</code>比特</strong>固定为<strong><code>0</code></strong>表示<strong>未进入偏向模式</strong>。 对象除了未被锁定的正常状态外， 还有<strong>轻量级锁定</strong>、 <strong>重量级锁定</strong>、 <strong><code>GC</code>标记</strong>、 <strong>可偏向</strong>等几种不同状态 。</p><p><img src="../../../../../images/Java/HotSpot虚拟机对象头Mark Word.png" alt="HotSpot虚拟机对象头Mark Word"></p><p>代码<strong>即将进入同步块</strong>时， 若<strong>锁标志位</strong>为<strong><code>01</code>状态</strong>即同步对象没有被锁定 ， 虚拟机首先将在<strong>当前线程</strong>的<strong>栈帧</strong>中建立一个名为<strong><code>Lock Record</code>锁记录</strong> 的空间， 用于存储锁对象目前的<strong><code>Mark Word</code>的拷贝</strong>，官方将该拷贝称为<strong><code>Displaced Mark Word</code></strong> 。</p><p><img src="../../../../../images/Java/轻量级锁CAS操作之前堆栈与对象的状态.png" alt="轻量级锁CAS操作之前堆栈与对象的状态"></p><p>虚拟机将使用<strong><code>CAS</code>操作</strong>尝试把对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。 若更新成功， 即代表该线程拥有了该对象的锁， 且对象<code>Mark Word</code>的<strong>锁标志位</strong>将转变为<strong><code>00</code></strong>， 表示此对象处于轻量级锁定状态。此时<strong>线程堆栈</strong>与<strong>对象头</strong>的状态如下：</p><p><img src="../../../../../images/Java/轻量级锁CAS操作之后堆栈与对象的状态.png" alt="轻量级锁CAS操作之后堆栈与对象的状态"></p><p>若更新失败， 意味着<strong>至少</strong>存在一条线程与当前线程<strong>竞争</strong>获取该对象的<strong>锁</strong>。 虚拟机首先会检查对象的<code>Mark Word</code>是否指向<strong>当前线程的栈帧</strong>， <strong>若是</strong>则说明当<strong>前线程</strong>已经<strong>拥有</strong>了<strong>该对象的锁</strong>， 则直接进入同步块， 否则说明该锁对象已经被其他线程抢占。 若出现<strong>两条以上</strong>的线程争用<strong>同一个锁</strong>， 则<strong>轻量级锁不再有效</strong>， <strong>必须要膨胀为重量级锁</strong>， <strong>锁标志</strong>的状态值变为<strong><code>10</code></strong>， 此时<code>Mark Word</code>中存储的就是指向<strong>重量级锁</strong>（互斥量） 的<strong>指针</strong>， 等待锁的线程也必须进入阻塞状态。 </p><p><strong>轻量级锁解锁过程</strong>也同样是<strong>通过<code>CAS</code>操作</strong>来进行， 若对象的<code>Mark Word</code>仍然指向线程的锁记录， 则用<strong><code>CAS</code>操作</strong>把对象当前的<code>Mark Word</code>和<strong>线程中复制的<code>Displaced Mark Word</code>替换回来</strong>。 若能<strong>成功替换</strong>， 则整个<strong>同步过程顺利完成</strong>； 若<strong>替换失败</strong>， 则说明有<strong>其他线程尝试过获取该锁</strong>， 就要在<strong>释放锁的同时， 唤醒被挂起的线程</strong>。</p><p><strong>轻量级锁</strong>能<strong>提升</strong>程序<strong>同步性能</strong>的<strong>依据</strong>：对于<strong>绝大部分的锁</strong>， 在<strong>整个同步周期内都不存在竞争</strong>，这一经验法则。若没有竞争， <strong>轻量级锁</strong>便通过<strong><code>CAS</code>操作</strong>成功<strong>避免了使用互斥量</strong>的开销； 但如果确实<strong>存在锁竞争</strong>， 除了互斥量的本身开销外， 还<strong>额外发生了<code>CAS</code>操作</strong>的开销。 因此在<strong>有竞争</strong>的情况下，<strong>轻量级锁反而会比传统的重量级锁更慢</strong> 。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>偏向锁</strong>是<code>JDK1.6</code>引入的一项<strong>锁优化措施</strong>， 其<strong>目的</strong>是<strong>消除</strong>数据在<strong>无竞争</strong>情况下的<strong>同步原语</strong>，进一步提高程序的运行性能。 若说<strong>轻量级锁</strong>是在<strong>无竞争</strong>的情况下使用<strong><code>CAS</code>操作</strong>去<strong>消除同步</strong>使用的<strong>互斥量</strong>， <strong>偏向锁</strong>就是在<strong>无竞争</strong>的情况下把<strong>整个同步都消除掉</strong>。</p><p>偏向锁的意思是<strong>锁会偏向于第一个获得它的线程</strong>， 若在接下来的执行过程中， 该锁<strong>一直没有被其他的线程获取</strong>， 则持有<strong>偏向锁</strong>的线程将<strong>永远不需要再进行同步</strong>。</p><p>若虚拟机启用了<strong>偏向锁</strong>， 则当锁对象第一次被线程获取时， 虚拟机将把对象头中的<strong>标志位</strong>设置为<strong><code>01</code></strong>、 把<strong>偏向模式设置为<code>1</code></strong>， 表示进入<strong>偏向模式</strong>。 同时使用<strong><code>CAS</code></strong>操作把获取到该锁的<strong>线程的<code>ID</code></strong>记录在对象的<code>Mark Word</code>中。 若<strong><code>CAS</code></strong>操作成功， <strong>持有偏向锁的线程</strong>以后每次进入<strong>该锁相关的同步块</strong>时， 虚拟机<strong>都可以不再进行任何同步操作</strong> 。偏向锁启用参数<strong><code>-XX：+UseBiasedLocking</code></strong>。</p><p>一旦出现另外一个线程去<strong>尝试获取该锁</strong>， <strong>偏向模式立即结束</strong>。 根据锁对象目前<strong>是否处于被锁定的状态决定是否撤销偏向</strong> ， 撤销后<strong>标志位恢复到未锁定</strong>或<strong>轻量级锁定</strong>的状态， 后续的同步操作按照<strong>轻量级锁</strong>执行。</p><p><img src="../../../../../images/Java/偏向锁、 轻量级锁的状态转化及对象Mark Word的关系.png" alt="偏向锁、 轻量级锁的状态转化及对象Mark Word的关系 "></p><p>当对象进入<strong>偏向状态</strong>时， <code>Mark Word</code>大部分的空间（23个比特） 都用于存储<strong>持有锁的线程<code>ID</code></strong>了， 这部分空间占用了原有<strong>存储对象哈希码</strong>的位置 。</p><p><code>Java</code>中对象如果计算过<strong>哈希码</strong>， 就应该一直保持该值不变 ，否则很多依赖对象哈希码的<code>API</code>都可能存在出错风险。 而作为绝大多数对象哈希码来源的<strong><code>Object::hashCode()</code></strong>方法， 返回的是<strong>对象的一致性哈希码</strong>， 该值是能<strong>强制保证不变</strong>的， 它通过在<strong>对象头中存储计算结果</strong>来保证第一次计算之后， <strong>再次调用该方法取到的哈希码值永远不会再发生改变</strong>。 因此当一个对象<strong>已经计算过一致性哈希码</strong>后， 则<strong>再也无法进入偏向锁状态</strong>了； 而当一个对象当前<strong>正处于偏向锁状态</strong>， 又收到<strong>需要计算</strong>其<strong>一致性哈希码</strong>请求时， 其<strong>偏向状态会被立即撤销</strong>， 且<strong>锁会膨胀为重量级锁</strong>。 在重量级锁的实现中， <strong>对象头指向了重量级锁的位置</strong>， 代表重量级锁的<strong><code>ObjectMonitor</code></strong>类里有字段可以记录<strong>非加锁状态下</strong>的<code>Mark Word</code>， 其中自然可以存储<strong>原来的哈希码</strong>。</p><p><strong>偏向锁</strong>可以<strong>提高带有同步但无竞争</strong>的程序性能， 但同样是一个带有<strong>效益权衡</strong>性质的优化，也就是说它并非总是对程序运行有利。 若程序中大多数锁都总是被多个不同的线程访问， 偏向模式则是多余的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;高效并发&lt;/strong&gt;是从&lt;code&gt;JDK1.5&lt;/code&gt;到&lt;code&gt;JDK1.6&lt;/code&gt;的一个重要改进，&lt;code&gt;HotSpot&lt;/code&gt;虚拟机为了&lt;strong&gt;在线程之间更高效地共享数据&lt;/strong&gt;，以及&lt;strong&gt;解
      
    
    </summary>
    
      <category term="Java" scheme="https://yaoyinglong.github.io/categories/Java/"/>
    
      <category term="并发" scheme="https://yaoyinglong.github.io/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="多线程，Thread" scheme="https://yaoyinglong.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8CThread/"/>
    
  </entry>
  
  <entry>
    <title>序列化</title>
    <link href="https://yaoyinglong.github.io/Blog/Java/%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://yaoyinglong.github.io/Blog/Java/基础/序列化/</id>
    <published>2020-10-26T16:00:00.000Z</published>
    <updated>2020-10-26T09:13:21.749Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="hide" scheme="https://yaoyinglong.github.io/categories/hide/"/>
    
    
      <category term="序列化" scheme="https://yaoyinglong.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
</feed>
