<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>
        Go基础 |
        
        YingLong</title>
    
    
        <meta name="keywords" content="Go">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Go语言是静态类型语言，所有的内存在 Go 中都是经过初始化的，当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。 只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。&amp;amp;&amp;amp;的优先级比||高（&amp;amp;&amp;amp;">
<meta name="keywords" content="Go">
<meta property="og:type" content="article">
<meta property="og:title" content="Go基础">
<meta property="og:url" content="https://yaoyinglong.github.io/Blog/Go/Go基础/index.html">
<meta property="og:site_name" content="YingLong">
<meta property="og:description" content="Go语言是静态类型语言，所有的内存在 Go 中都是经过初始化的，当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。 只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。&amp;amp;&amp;amp;的优先级比||高（&amp;amp;&amp;amp;">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-07-27T11:36:21.998Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go基础">
<meta name="twitter:description" content="Go语言是静态类型语言，所有的内存在 Go 中都是经过初始化的，当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。 只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。&amp;amp;&amp;amp;的优先级比||高（&amp;amp;&amp;amp;">
    

    

    
        <link rel="icon" href="/favicon.ico">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">
    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
<div id="container">
    <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">YingLong</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
            <div id="search-form-wrap">
    
        <form class="search-form">
            <input type="text" class="ins-search-input search-form-input" placeholder="Search">
            <button type="submit" class="search-form-submit"></button>
        </form>
        <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            ROOT_URL: '/',
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

    <div class="outer">
        
        
            <aside id="sidebar">
    
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>

        
        
        
            <ul class="unstyled" id="tree">
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            DB
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/DB/MySQL基础/">MySQL基础</a></li>
                
                    <li class="file"><a href="/Blog/DB/MySQL常用SQL总结/">MySQL常用SQL总结</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Git
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/Git/GIt基本概念/">Git基本概念</a></li>
                
                    <li class="file"><a href="/Blog/Git/GIt常用命令/">Git常用命令</a></li>
                
                    <li class="file"><a href="/Blog/Git/分支管理理解/">分支管理理解</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Go
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file active"><a href="/Blog/Go/Go基础/">Go基础</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Java
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            VM
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/Java/VM/HotSpot收集算法实现/">HotSpot收集算法实现</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/JVM内存池/">JVM内存池</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/内存非配与回收策略/">内存分配与回收策略</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/Java内存区域/">Java内存区域</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/Minor&Major&Full GC/">Minor&Major&Full GC</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/OutOfMemoryError异常/">OOM异常实验</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/垃圾收集算法/">垃圾收集算法</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/堆中对象分配&布局&访问/">堆中对象分配&布局&访问</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/对象是否存活/">对象是否存活</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/类加载的时机/">类加载的时机</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/运行时栈帧结构/">运行时栈帧结构</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/垃圾收集器/">垃圾收集器</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/方法调用/">方法调用</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/字节码指令/">字节码指令</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/理解GC日志/">理解GC日志</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/类加载器/">类加载器</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/Class文件结构/">Class文件结构</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/属性表集合/">属性表集合</a></li>
                
                    <li class="file"><a href="/Blog/Java/VM/类加载过程/">类加载过程</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            基础
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/Java/基础/lambda常用总结/">lambda常用总结</a></li>
                
                    <li class="file"><a href="/Blog/Java/基础/时间及日期总结/">Java8时间及日期</a></li>
                
                    <li class="file"><a href="/Blog/Java/基础/ConcurrentHashMap源码分析/">ConcurrentHashMap源码分析</a></li>
                
                    <li class="file"><a href="/Blog/Java/基础/HashMap源码分析/">HashMap源码分析</a></li>
                
                    <li class="file"><a href="/Blog/Java/基础/位运算/">位运算</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/Java/工具/Java中调用Groovy脚本/">Java中调用Groovy脚本</a></li>
                
                    <li class="file"><a href="/Blog/Java/工具/国密SM2/">国密SM2</a></li>
                
                    <li class="file"><a href="/Blog/Java/工具/国密SM4/">国密SM4</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            并发
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/Java/并发/CAS原理及使用场景/">CAS原理及使用场景</a></li>
                
                    <li class="file"><a href="/Blog/Java/并发/原子性、可见性、有序性/">原子性、可见性、有序性</a></li>
                
                    <li class="file"><a href="/Blog/Java/并发/Synchronized总结/">Synchronized总结</a></li>
                
                    <li class="file"><a href="/Blog/Java/并发/线程安全/">线程安全</a></li>
                
                    <li class="file"><a href="/Blog/Java/并发/Volatile源码分析/">Volatile源码分析</a></li>
                
                    <li class="file"><a href="/Blog/Java/并发/线程安全实现方式/">线程安全实现方式</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="file"><a href="/Blog/Java/JVM整体概览/">JVM整体概览</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Linux
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/Linux/Linux常用命令/">Linux常用命令</a></li>
                
                    <li class="file"><a href="/Blog/Linux/Linux常用技巧/">Linux常用技巧</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Maven
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/Maven/Maven加密JAR包/">Maven加密JAR包</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven基础/">Maven基础</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven常用/">Maven常用</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven属性/">Maven属性</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven常用工具/">Maven常用工具</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven插件编写/">Maven插件编写</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven生命周期/">Maven生命周期</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven个性化打包/">Maven个性化打包</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven仓库/">Maven仓库</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven插件基础/">Maven插件基础</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven聚合与继承/">Maven聚合与继承</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven常用插件/">Maven常用插件</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven标签全解/">Maven标签全解</a></li>
                
                    <li class="file"><a href="/Blog/Maven/Maven Assembly标签全解/">Maven Assembly标签全解</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Python
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/Python/Excel文件数据抽取/">Excel文件数据抽取</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Test
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/Test/IT测试总结/">IT测试总结</a></li>
                
                    <li class="file"><a href="/Blog/Test/JMeter日常总结/">JMeter日常总结</a></li>
                
                    <li class="file"><a href="/Blog/Test/LoadRunner日常总结/">LoadRunner日常总结</a></li>
                
                    <li class="file"><a href="/Blog/Test/UT测试总结/">UT测试总结</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            协议族
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/协议族/TCPIP四层&五层模型/">TCP/IP四层&五层模型</a></li>
                
                    <li class="file"><a href="/Blog/协议族/网络基础知识/">网络基础知识</a></li>
                
                    <li class="file"><a href="/Blog/协议族/以太网/">以太网</a></li>
                
                    <li class="file"><a href="/Blog/协议族/地址解析协议/">地址解析协议ARP</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            杂记
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/杂记/IDEA实用插件/">IDEA实用插件</a></li>
                
                    <li class="file"><a href="/Blog/杂记/JAVA实用工具/">JAVA实用工具</a></li>
                
                    <li class="file"><a href="/Blog/杂记/IDEA快捷的使用/">IDEA的快捷使用</a></li>
                
                    <li class="file"><a href="/Blog/杂记/Win实用工具/">Win实用工具</a></li>
                
                    <li class="file"><a href="/Blog/杂记/XSD使用总结/">XSD实用总结</a></li>
                
                    <li class="file"><a href="/Blog/杂记/SonarQube配置总结/">SonarQube配置总结</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            框架
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Spring
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/框架/Spring/Spring Gzip压缩/">Spring Gzip压缩</a></li>
                
                    <li class="file"><a href="/Blog/框架/Spring/IoC容器/">IoC容器</a></li>
                
                    <li class="file"><a href="/Blog/框架/Spring/Spring整体架构/">Spring整体架构</a></li>
                
                    <li class="file"><a href="/Blog/框架/Spring/Spring知识点/">Spring知识点</a></li>
                
                    <li class="file"><a href="/Blog/框架/Spring/Spring线程池跨线程数据共享/">Spring线程池跨线程数据共享</a></li>
                
                    <li class="file"><a href="/Blog/框架/Spring/Hystrix总结/">Hystrix总结</a></li>
                
                    <li class="file"><a href="/Blog/框架/Spring/SpringMvc异步/">SpringMvc异步原理及实现</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            常见问题
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/框架/常见问题/HBase依赖冲突/">HBase依赖冲突</a></li>
                
                    <li class="file"><a href="/Blog/框架/常见问题/Maven编译后文件损坏/">Maven编译后文件损坏</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="file"><a href="/Blog/框架/Redis分布式锁实现/">Redis分布式锁实现</a></li>
                
                    <li class="file"><a href="/Blog/框架/Tomcat工作原理/">Tomcat工作原理</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            算法
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/算法/二叉搜索树/">二叉搜索树</a></li>
                
                    <li class="file"><a href="/Blog/算法/平衡二叉树/">平衡二叉树</a></li>
                
                    <li class="file"><a href="/Blog/算法/时间&空间复杂/">时间&空间复杂</a></li>
                
                    <li class="file"><a href="/Blog/算法/树基础/">树基础</a></li>
                
                    <li class="file"><a href="/Blog/算法/排序算法/">排序算法</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            设计模式
                        </a>
                        
            <ul class="unstyled" id="tree">
                
                    <li class="file"><a href="/Blog/设计模式/SOLID基本原则/">SOLID基本原则</a></li>
                
                    <li class="file"><a href="/Blog/设计模式/设计模式概览/">设计模式概览</a></li>
                
            </ul>
        
                    </li>
                
                    <li class="file"><a href="/Blog/index/">Welcome YingLong's Blog</a></li>
                
            </ul>
        
    </div>
    <script>
        $(document).ready(function () {
            var iconFolderOpenClass = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({duration: 100});
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({duration: 100});
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    subtrees.slideUp({duration: 100});
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({duration: 100});
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if (expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({duration: 100});
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({duration: 100});
                    icon.addClass(iconAllExpandClass);
                }
            });
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
        
        <section id="main"><article id="post-Go/Go基础" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
        <i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Go/">Go</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Go/">Go</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/Blog/Go/Go基础/">
            <time datetime="2020-07-02T16:00:00.000Z" itemprop="datePublished">2020-07-03</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            Go基础
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
            
            
                    
            
            
                <p><code>Go</code>语言是<strong>静态类型</strong>语言，<strong>所有的内存在 <code>Go</code> 中都是经过初始化的</strong>，当一个变量被声明之后，<strong>系统自动赋予它该类型的零值</strong>：<code>int</code> 为 <code>0</code>，<code>float</code> 为 <code>0.0</code>，<code>bool</code> 为 <code>false</code>，<code>string</code> 为<strong>空字符串</strong>，<strong>指针</strong>为 <code>nil</code> 等。</p>
<p>只有两个<strong>相同类型</strong>的值才可以进行比较，如果值的类型是<strong>接口</strong>（<code>interface</code>），那么它们也必须都实现了<strong>相同的接口</strong>。<code>&amp;&amp;</code>的优先级比<code>||</code>高（&amp;&amp; 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高）。</p>
<p><strong>变量</strong>、<strong>函数</strong>、<strong>常量</strong>名称如果<strong>首字母大写</strong>，则表示它<strong>可被其它的包访问</strong>；如果首字母小写，则表示它只能在本包中使用。</p>
<p><code>nil</code> 不是关键字或保留字且不能比较。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Go语言的基本类型有：</p>
<ul>
<li><code>bool</code></li>
<li><code>string</code></li>
<li><code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code></li>
<li><code>uint</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>（只有在底层编程时才需要）</li>
<li><code>byte</code> （<code>uint8</code> 的别名）</li>
<li><code>rune</code> （<code>int32</code> 的别名 代表一个 <code>Unicode</code> 码点）</li>
<li><code>float32</code>、<code>float64</code></li>
<li><code>complex64</code>、<code>complex128</code></li>
</ul>
<p>尽管在某些特定的运行环境下 <code>int</code>、<code>uint</code> 和 <code>uintptr</code> 的大小可能相等，但是它们依然是不同的类型，在需要把 <code>int</code> 类型当做 <code>int32</code> 类型使用的时候必须显示的对类型进行转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> num1, num2, num3 = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> num1, num2, num3 = <span class="number">1</span>, <span class="string">"2"</span>, <span class="number">3.5</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    num1 <span class="keyword">int</span></span><br><span class="line">    num2 <span class="keyword">string</span></span><br><span class="line">    num3 <span class="keyword">float64</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    num1 = <span class="number">1</span></span><br><span class="line">    num2 = <span class="string">"2"</span></span><br><span class="line">    num3 = <span class="number">3.5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Go是一门<strong>静态类型</strong>语言，每个变量都有一个在编译时就确定的静态类型。虽然<code>a</code>和<code>b</code>的的基本类型相同，但静态类型不同，无类型转换的情况下<strong>无法相互赋值</strong>。虽然在运行时中，接口变量存储的值也许会变，但接口变量的类型是不会变的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b MyInt</span><br></pre></td></tr></table></figure>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Go语言常用容器有<strong>数组</strong>，<strong>切片</strong>，<code>Map</code>，<code>List</code>。map和切片是不可以用<code>==</code>直接被比较的。</p>
<p>数组的长度必须是<strong>常量表达式</strong>，若数组长度的位置出现<code>...</code>省略号，则表示数组的长度是根据<strong>初始化值的个数</strong>来计算。数组的长度是数组类型的一个组成部分，若两个数组<strong>类型相同</strong>（包括数组的<strong>长度</strong>，数组中<strong>元素的类型</strong>），可直接通过较运算符<code>==</code>和<code>!=</code>来判断两个数组是否相等，<strong>不能比较两个类型不同的数组，且不能相互赋值</strong>，否则程序将无法完成编译。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numArr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,&#125;</span><br><span class="line">strArr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;</span><br><span class="line"></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">10</span>, <span class="number">3</span>:<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>切片</strong>（<code>slice</code>）是对数组的一个<strong>连续片段的引用</strong>，所以切片是一个引用类型，终止索引标识的项不包括在切片内。切片的内部结构包含<strong>地址</strong>、<strong>大小</strong>和<strong>容量</strong>，切片一般<strong>用于快速地操作一块数据集合</strong>。切片在扩容时，<strong>容量的扩展规律是按容量的 <code>2</code> 倍数进行扩充</strong>。在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次。<code>make</code>函数创建切片时若只指定长度，则切片的长度和容量相等，<strong>不允许创建长度大于容量的切片</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,&#125;</span><br><span class="line">slice := arr[:]</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">slice := arr[<span class="number">1</span>:]</span><br><span class="line">slice := arr[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;...)</span><br><span class="line">slice = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;, slice...)</span><br><span class="line"></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">slice = <span class="built_in">append</span>(slice[:<span class="number">2</span>], <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>&#125;, slice[<span class="number">2</span>:]...)...)</span><br><span class="line"></span><br><span class="line">sliceA := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sliceB := []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">copyCount := <span class="built_in">copy</span>(sliceA, sliceB)</span><br><span class="line"></span><br><span class="line">sliceB := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sliceA := []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">copyCount := <span class="built_in">copy</span>(sliceA, sliceB)</span><br><span class="line"><span class="comment">// 创建容量和长度都是100的切片</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">99</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>计算切片的<strong>长度</strong>和<strong>容量</strong>，若底层数组容量<code>k</code>的切片<code>slice[i:j]</code>，长度为<code>j-i</code>，容量为<code>k-i</code>。也可以通过第三个索引来控制新切片的容量。若底层数组容量<code>k</code>的切片<code>slice[i:j:s]</code>，长度为<code>j-i</code>，容量为<code>s-i</code>，<code>s&lt;=K</code>。</p>
<p><code>map</code> 是引用类型，<strong>可动态增长</strong>，未初始化的 <code>map</code> 的值是 <code>nil</code>，使用函数 <code>len()</code> 可以获取 <code>map</code> 中 <code>pair</code> 的数目。<code>map</code>不能使用<code>cap()</code>函数。定义map时可现实指定容量，当 map 增长到容量上限的时候，如果再增加新的 key-value，map 的大小会自动加 <code>1</code>。map可以存函数。<code>map</code>是<strong>无序</strong>的。<strong>切片</strong>、<strong>函数</strong>以及<strong>包含切片的结构类型</strong>由于<strong>具有引用语意</strong>不能作为<code>map</code>的键。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapLit = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> mapLit <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapLit = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">mapLit := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>&#125;</span><br><span class="line">mapLit[<span class="number">3</span>] = <span class="string">"c"</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> mapLit &#123;</span><br><span class="line">    fmt.Println(<span class="string">"key value:"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(mapLit, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">mapLit := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"hello"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">"world"</span>: <span class="number">200</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value, isExist := mapLit[<span class="string">"hello"</span>]；isExist：</span><br><span class="line">	fmt.Println(<span class="string">"value:"</span>, value)</span><br><span class="line"></span><br><span class="line">skill := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="string">"fire"</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"chicken fire"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">f, ok := skill[<span class="string">"fire"</span>]</span><br></pre></td></tr></table></figure>
<p>列表是一种<strong>非连续</strong>的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lit := list.New()</span><br><span class="line">lit.PushBack(<span class="string">"AA"</span>)</span><br><span class="line">lit.PushFront(<span class="string">"BB"</span>)</span><br><span class="line">element := lit.PushFront(<span class="string">"CC"</span>)</span><br><span class="line">lit.InsertBefore(<span class="string">"DD"</span>, element)</span><br><span class="line"><span class="keyword">for</span> i := lit.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">   fmt.Println(<span class="string">"lit value:"</span>, i.Value)</span><br><span class="line">&#125;</span><br><span class="line">lit.Remove(element)</span><br></pre></td></tr></table></figure>
<p>Go语言线程安全的<code>sync.Map</code>，<code>Range</code>返回为<code>false</code>时将不再往下遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> syncMap sync.Map</span><br><span class="line">syncMap.Store(<span class="number">1</span>, <span class="string">"a"</span>)</span><br><span class="line">syncMap.Store(<span class="number">2</span>, <span class="string">"b"</span>)</span><br><span class="line">value, ok := syncMap.Load(<span class="number">2</span>)</span><br><span class="line">syncMap.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"key, value"</span>, key, value)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>Go 语言常用流程控制有 <code>if</code> 和 <code>for</code>，而 <code>switch</code> 和 <code>goto</code> 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
<p><code>if-else</code>分支结构，可结合<code>goto</code>使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> index := <span class="number">12</span>; index &gt; <span class="number">10</span> &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index := <span class="number">10</span>; index == <span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">goto</span> onExit</span><br><span class="line">&#125;</span><br><span class="line">onExit:</span><br><span class="line">fmt.Println(<span class="string">"exit"</span>)</span><br></pre></td></tr></table></figure>
<p><code>go</code>中只有<code>for</code>循环结构，不支持 <code>while</code> 和 <code>do-while</code> 结构；for range 可以遍历<strong>数组</strong>、<strong>切片</strong>、<strong>字符串</strong>、<code>map</code> 及<strong>通道</strong>（<code>channel</code>）；其中用到的<code>range</code> 返回的是每个<strong>元素的副本</strong>，而不是直接返回对该元素的引用。字符串的遍历是一个个<code>rune</code> 字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">JLoop:</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> JLoop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> index &lt; <span class="number">10</span> &#123;</span><br><span class="line">    index++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str := <span class="string">"12456789"</span></span><br><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Println(<span class="string">"pos, char:"</span>, pos, char)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">    channel &lt;- <span class="number">2</span></span><br><span class="line">    channel &lt;- <span class="number">3</span></span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> value := <span class="keyword">range</span> channel &#123;</span><br><span class="line">    fmt.Println(<span class="string">"channel value:"</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code>表达式不需要为<strong>常量</strong>，甚至不需要为<strong>整数</strong>，<code>case</code> 按照从上到下的顺序进行求值，直到找到匹配的项，若<code>switch</code> 没有表达式，则对 <code>true</code> 进行匹配。<code>fallthrough</code>会紧接着执行下一个 <code>case</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"kk"</span></span><br><span class="line"><span class="keyword">switch</span> str &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"hello"</span>, <span class="string">"kk"</span>:</span><br><span class="line">    fmt.Println(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">    fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := <span class="number">11</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r &gt; <span class="number">10</span> &amp;&amp; r &lt; <span class="number">20</span>:</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>Go</code> 语言支持<strong>普通函数</strong>、<strong>匿名函数</strong>和<strong>闭包</strong>。函数间传递变量总是以<strong>值得方式传递</strong>，数组传递会完整复制并传递给函数，最好只传入指向数组的指针。函数间传递切片和<code>map</code>，<strong>只会复制切片和<code>map</code>本身，不会涉及底层数据</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   a = <span class="number">1</span></span><br><span class="line">   b = <span class="number">2</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := funcA()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := funcB()</span><br><span class="line">f := funcB</span><br><span class="line">a, b := f()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">string</span>, c <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"a1"</span>, <span class="string">"b2"</span>, <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">a, b, c := funcC()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcD</span><span class="params">(arr []<span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">      f(value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">funcD([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"this value:"</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数变量</span></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">f</span> = <span class="title">funcA</span></span></span><br><span class="line"><span class="function"><span class="title">a</span>, <span class="title">b</span> := <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 匿名函数</span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"inner func:"</span>, data)</span><br><span class="line">&#125;(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"inner func:"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<p><strong>闭包</strong>是引用了<strong>自由变量</strong>的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除。被捕获到闭包中的变量让闭包本身拥有了记忆效应。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accumulate</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      value++</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">accumulator := accumulate(<span class="number">1</span>)</span><br><span class="line">fmt.Println(accumulator()) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(accumulator()) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>可变参数和任意类型的可以变参数，用 <code>interface{}</code> 传递<strong>任意类型</strong>数据，<strong>可变参数</strong>变量是一个<strong>包含所有参数的切片</strong>，如果要将这个含有可变参数的变量传递给下一个可变参数函数，可以在传递时给可变参数变量后面添加<code>...</code>，这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notFixedParam</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notFixedParamV2</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">      <span class="keyword">switch</span> arg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">int64</span>:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notFixedParam(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">notFixedParamV2(<span class="string">"kk"</span>, <span class="number">1</span>, <span class="number">234</span>, <span class="string">"hello"</span>, <span class="number">3.14</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawPrint</span><span class="params">(rawList ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, raw := <span class="keyword">range</span> rawList &#123;</span><br><span class="line">		fmt.Println(raw)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(slist ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	rawPrint(slist...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>defer</code> 语句会将其后面跟随的语句进行<strong>延迟处理</strong>，在 <code>defer</code> 归属的函数<strong>即将返回</strong>时，将延迟处理的语句<strong>按 <code>defer</code> 的逆序进行执行</strong>。类似<code>java</code>的<code>finally</code>语句块。可与宕机<code>panic</code> 一起使用，宕机前会优先执行<code>defer</code>。提供<code>recover</code> 用于宕机恢复，且仅在延迟函数 <code>defer</code> 中有效。正常的执行过程中，调用 <code>recover</code> 会返回 <code>nil</code> 并且没有其他任何效果，调用 <code>recover</code> 可以捕获到 <code>panic</code> 的输入值，并且恢复正常的执行。<code>recover</code> 的宕机恢复机制就对应其他语言中的 <code>try/catch</code> 机制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"宕机后要做的事情"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"宕机"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p><strong>结构体</strong>的定义只是一种<strong>内存布局的描述</strong>，只有当结构体实例化时，才会真正地分配内存。使用<code>new</code>或<code>&amp;</code>构造的类型实例的类型是<strong>类型的指针</strong>。<code>Go</code>语言的<strong>类型</strong>或<strong>结构体没有构造函数</strong>的功能.</p>
<p>使用<code>.</code>来访问结构体的<strong>成员变量</strong>，访问结构体指针的成员变量时可以继续使用<code>.</code>，Go使用了语法糖（Syntactic sugar）技术，将 <code>ins.Name</code> 形式转换为 <code>(*ins).Name</code>；对结构体进行<code>&amp;</code>取地址操作时，视为对该类型进行一次 new 的实例化操作；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">	R, G, B <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color := <span class="built_in">new</span>(Color)</span><br><span class="line">(*color).R = <span class="number">12</span></span><br><span class="line">color.G = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">color := &amp;Color&#123;&#125;</span><br><span class="line">(*color).R = <span class="number">12</span></span><br><span class="line">color.G = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Command <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name    <span class="keyword">string</span></span><br><span class="line">   Var     *<span class="keyword">int</span></span><br><span class="line">   Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">version := <span class="number">1</span></span><br><span class="line"><span class="comment">// 使用键值对填充结构体</span></span><br><span class="line">cmd := &amp;Command&#123;</span><br><span class="line">    Name:    <span class="string">"version"</span>,</span><br><span class="line">    Var:     &amp;version,</span><br><span class="line">    Comment: <span class="string">"show version"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"cmd, Name, Var, Comment:"</span>, *cmd, cmd.Name, *cmd.Var, cmd.Comment)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用多个值的列表初始化结构体</span></span><br><span class="line">cmd := Command&#123;</span><br><span class="line">    <span class="string">"version"</span>,</span><br><span class="line">    &amp;version,</span><br><span class="line">    <span class="string">"show version"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"cmd, Name, Var, Comment:"</span>, cmd, cmd.Name, *cmd.Var, cmd.Comment)</span><br></pre></td></tr></table></figure>
<p><strong>匿名结构体</strong>没有类型名称，无须通过 <code>type</code> 关键字定义就可以直接使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name    <span class="keyword">string</span></span><br><span class="line">   Var     *<span class="keyword">int</span></span><br><span class="line">   Comment <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">   <span class="string">"version"</span>,</span><br><span class="line">   &amp;version,</span><br><span class="line">   <span class="string">"show version"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMsg</span> <span class="params">(msg *<span class="keyword">struct</span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">	id <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">	data <span class="keyword">string</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"msg"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">    data <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="number">1024</span>,</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">&#125;</span><br><span class="line">printMsg(msg)</span><br></pre></td></tr></table></figure>
<p>结构体可以包含一个或多个<strong>匿名</strong>（或<strong>内嵌</strong>）字段，没有显式的名字，只有字段的类型，<strong>此时类型也就是字段的名</strong>。在一个结构体中<strong>对于每一种数据类型只能有一个匿名字段</strong>。结构体可以包含内嵌结构体，内嵌结构体甚至可以来自其他包。</p>
<p>结构体实例访问<strong>任意一级</strong>的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> innerS <span class="keyword">struct</span> &#123;</span><br><span class="line">   in1 <span class="keyword">int</span></span><br><span class="line">   in2 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> outerS <span class="keyword">struct</span> &#123;</span><br><span class="line">   b <span class="keyword">int</span></span><br><span class="line">   c <span class="keyword">float32</span></span><br><span class="line">   in1 <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">int</span></span><br><span class="line">   innerS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer := <span class="built_in">new</span>(outerS)</span><br><span class="line">outer.b = <span class="number">6</span></span><br><span class="line">outer.c = <span class="number">7.5</span></span><br><span class="line">outer.<span class="keyword">int</span> = <span class="number">60</span></span><br><span class="line">outer.in1 = <span class="number">20</span></span><br><span class="line">outer.innerS.in1 = <span class="number">5</span></span><br><span class="line">outer.in2 = <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"outer1 :"</span>, *outer)</span><br><span class="line">outer2 := outerS&#123;<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">20</span>, <span class="number">60</span>, innerS&#123;<span class="number">5</span>, <span class="number">10</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="string">"outer2 :"</span>, outer2)</span><br></pre></td></tr></table></figure>
<p>结构体标签是对结构体字段的额外信息标签，由<strong>一个或多个键值对</strong>组成；键与值使用<strong>冒号</strong>分隔，值用<strong>双引号</strong>括起来；键值对之间使<strong>用一个空格分隔</strong>。标签内容是<strong>静态的</strong>，无须实例化结构体，可以通过<strong>反射</strong>从结构体中获取标签内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ins <span class="keyword">struct</span> &#123;</span><br><span class="line">   in1 <span class="keyword">int</span> <span class="string">`key1:"value1" key2:"value2"`</span></span><br><span class="line">   in2 <span class="keyword">int</span> <span class="string">`key1:"value1" key2:"value2"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeOfIns := reflect.TypeOf(Ins&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> catType, ok := typeOfIns.FieldByName(<span class="string">"in2"</span>); ok &#123;</span><br><span class="line">    fmt.Println(catType.Tag.Get(<span class="string">"key1"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法能给用户定义的类型添加新的行为，实际上也是函数，仅仅是在申明时，在关键字<code>func</code>和方法名间增加了一个参数，该参数称为<strong>接收者</strong>（<strong>值接收者</strong>、<strong>指针接收者</strong>），<strong>有接收者为方法，无接收者为函数</strong>。值接收者调用时会使用这个值的副本来执行，如下所示<code>changeEmailV2</code>方法是无效的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cusUser <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *cusUser)</span> <span class="title">changeEmailV1</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	u.email = email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u cusUser)</span> <span class="title">changeEmailV2</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	u.email = email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>若要创建一个新值，该类型的方法使用值接收者，若要修改当前值，使用指针接收者。</strong></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><code>Go</code>无类和继承的概念，<code>Go</code>语言的接口在命名时，一般会在单词后面添加 <code>er</code>；当方法名首字母大写时，且该接口类型名首字母也大写时，该方法可被接口所在的包之外的代码访问。</p>
<p>接口被实现必须满足，<strong>接口的方法与实现接口的类型方法格式一致，接口中所有方法均被现实</strong>。类型和接口之间有一对多和多对一的关系。一个类型可以同时实现多个接口，一个接口的方法，不一定需要由一个类型完全实现。</p>
<p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。只要<strong>接口的所有方法被实现</strong>，则这个接口中的所有嵌套接口的方法均可以被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">   WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">   CanWriter() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">   WriterClose() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FileWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NetWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">   FileWriter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *FileWriter)</span> <span class="title">WriteData</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"WriteData:"</span>, data)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *FileWriter)</span> <span class="title">WriterClose</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"FileWriter Close"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d *NetWriter)</span> <span class="title">CanWriter</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"CanWrite"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileWriter := <span class="built_in">new</span>(FileWriter)</span><br><span class="line">fileWriter.WriterClose()</span><br><span class="line">fileWriter.WriteData(<span class="string">"FileWriter"</span>)</span><br><span class="line"></span><br><span class="line">netWriter := <span class="built_in">new</span>(NetWriter)</span><br><span class="line">netWriter.WriterClose()</span><br><span class="line">netWriter.WriteData(<span class="string">"NetWriter"</span>)</span><br><span class="line">netWriter.CanWriter()</span><br><span class="line"></span><br><span class="line">f := <span class="built_in">new</span>(NetWriter)</span><br><span class="line"><span class="keyword">var</span> writer DataWriter</span><br><span class="line">writer = f</span><br><span class="line">writer.WriteData(<span class="string">"NetWriter2"</span>)</span><br><span class="line">writer.CanWriter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writer DataWriter = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">writer = f</span><br><span class="line">writer.WriteData(<span class="string">"NetWriter3"</span>)</span><br><span class="line">writer.CanWriter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writeCloser DataWriteCloser = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">writeCloser.WriterClose()</span><br><span class="line">writeCloser.WriteData(<span class="string">"writeCloser"</span>)</span><br><span class="line">writeCloser.CanWriter()</span><br></pre></td></tr></table></figure>
<p>将接口转换为其他接口，若不写<code>ok</code>接收是否为实现该类型，若<code>rw</code>没有完全实现接口，将触发宕机。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writeCloser DataWriteCloser = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">rw, ok := writeCloser.(Closer)</span><br><span class="line">fmt.Println(ok, <span class="string">";"</span>, rw.WriterClose())</span><br></pre></td></tr></table></figure>
<p>将接口转换为其他类型时，接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writeCloser DataWriteCloser = <span class="built_in">new</span>(NetWriter)</span><br><span class="line">rw, ok := writeCloser.(*NetWriter)</span><br><span class="line">fmt.Println(ok, <span class="string">";"</span>, rw.WriterClose(), rw.WriteData(<span class="string">"*NetWriter"</span>), rw.CanWriter())</span><br></pre></td></tr></table></figure>
<p>接口在底层的实现有<code>type</code> 和 <code>data</code>两个部分。显式地将 <code>nil</code> 赋值给接口时，接口的 <code>type</code> 和 <code>data</code> 都将为 <code>nil</code>，此时接口与 nil 值判断是相等的。将带有类型的 <code>nil</code> 赋值给接口时，只有 <code>data</code> 为 <code>nil</code>，而<code>type</code> 不为 <code>nil</code>，此时接口与 <code>nil</code> 判断将不相等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> insImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ins *insImpl)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"hi"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStringer</span><span class="params">()</span> <span class="title">fmt</span>.<span class="title">Stringer</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> ins *insImpl = <span class="literal">nil</span></span><br><span class="line">   <span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">fmt.Println(GetStringer() == <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> ins *insImpl = <span class="literal">nil</span></span><br><span class="line">fmt.Println(ins == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>Go的<strong>源码复用</strong>建立在<strong>包<code>package</code></strong>的基础上，入口 <code>main()</code> 函数所在的包（<code>package</code>）叫 <code>main</code>。包与文件夹一一对应，一般包的名称就是其源文件所在目录的名称，所有与包相关的操作，必须依赖于<strong>工作目录<code>GOPATH</code></strong>。包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是<strong>包在引用时一般使用全路径引用</strong>。</p>
<p>包的习惯用法：</p>
<ul>
<li>包名一般小写，使用简短且有意义的名称。</li>
<li>包名一般和所在目录同名，也可不同，包名中不能包含<code>-</code>等特殊符号。</li>
<li>包一般使用域名作为目录名称，能保证包名的唯一性。</li>
<li>包名为 <code>main</code> 的包为应用程序的入口包，编译不包含 <code>main</code> 包的源码文件时不会得到可执行文件。</li>
<li>一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。</li>
</ul>
<p>包的引用路径分为<strong>全路径导入</strong>和<strong>相对路径导入</strong>。可以自定义别名引用包；也可用<code>.</code>省略引用格式，相当于把 包直接合并到当前程序中，在使用 包内的方法是可以不用加前缀直接引用；若只执行包初始化的 <code>init</code> 函数，不使用包内部的数据可使用匿名引用格式；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全路径导入：源码位于GOPATH/src/lab/test目录下</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"lab/test"</span></span><br><span class="line"><span class="comment">// 相对路径导入：源码位GOPATH/src/lab/a目录下</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../a"</span></span><br><span class="line"><span class="comment">// 自定义别名引用包</span></span><br><span class="line"><span class="keyword">import</span> F <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 省略引用格式</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 匿名引用格式</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"fmt"</span></span><br></pre></td></tr></table></figure>
<p>一个包可有多个 <code>init</code> 函数，包加载时会执行全部 <code>init</code> 函数，但<strong>不能保证执行顺序</strong>；包<strong>不能出现环形引用</strong>；包<strong>允许重复引用</strong>；包初始化程序从 <code>main</code> 函数引用的包开始，<strong>逐级查找</strong>包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图；编译器会将<strong>有向无环图</strong>转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化；单个包的初始化<strong>先初始化常量，然后是全局变量，最后执行包的 <code>init</code> 函数</strong>。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p><code>Go</code> 的并发通过 <code>goroutine</code>特性完成。<code>goroutine</code> 类似于<strong>线程</strong>，但是可根据需要创建多个 <code>goroutine</code> 并发工作。<code>goroutine</code> 是由 <strong><code>Go</code> 运行时调度完成</strong>，而<strong>线程是由操作系统调度完成</strong>。</p>
<p><code>Go</code> 提供 <code>channel</code>在多个 <code>goroutine</code> 间进行通信，<code>channel</code>是<strong>类型相关</strong>的<strong>语言级别</strong>得<code>goroutine</code>间的<strong>进程内</strong>的通信方式。必须使用 <code>make</code> 创建 <code>channel</code>；可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="number">1</span> &#125;()</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="string">"hi"</span> &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Equip <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> *Equip)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- &amp;Equip&#123;a: <span class="number">1</span>, b: <span class="number">2</span>&#125; &#125;()</span><br></pre></td></tr></table></figure>
<p>通道使用<code>&lt;-</code>操作符<strong>发送</strong>和<strong>接收</strong>数据；把数据往通道中发送时，若接收方一直<strong>未接收</strong>，发送操作将<strong>持续阻塞</strong>；通道的收发操作在<strong>不同的两个 <code>goroutine</code> 间进行</strong>；接收将<strong>持续阻塞</strong>直到发送方发送数据；每次接收<strong>一个</strong>元素；<strong>被关闭的通道</strong>不会被置为 <code>nil</code>。对已经关闭的通道进行发送，将会触发宕机。从<strong>已关闭</strong>的通道<strong>接收数据</strong>或者正在接收数据时，将会接收到通道<strong>类型的零值</strong>，然后<strong>停止阻塞并返回</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞接收数据</span></span><br><span class="line">data := &lt;-ch</span><br><span class="line"><span class="comment">// 非阻塞接收数据，可能造成高CPU占用，很少使用，若ok未false表示通道ch已关闭</span></span><br><span class="line">data, ok := &lt;-ch</span><br><span class="line"><span class="comment">// 接收任意数据，忽略接收数据</span></span><br><span class="line">&lt;- ch</span><br><span class="line"><span class="comment">// 声明一个只能发送的通道类型</span></span><br><span class="line"><span class="keyword">var</span> chSendOnly = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 声明一个只能接收的通道类型</span></span><br><span class="line"><span class="keyword">var</span> chRecvOnly = <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 关闭通道</span></span><br><span class="line"><span class="built_in">close</span>(chSendOnly)</span><br><span class="line"><span class="comment">// 带缓冲的通道，缓冲通道被填满时，发送数据时发生阻塞，带缓冲通道为空时，接收数据时发生阻塞</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>协程有<strong>独立的栈空间</strong>，<strong>共享堆空间</strong>，调度由用户自己控制，本质上类似于用户级线程，这些用户级线程的调度也是自己实现的。<strong>一个线程上可以跑多个协程，协程是轻量级的线程</strong>。</p>
<p>使用 <code>go</code> 关键字创建 <code>goroutine</code> 时，被调用函数的<strong>返回值会被忽略</strong>。若要在 <code>goroutine</code> 中返回数据，通过通道把数据从 <code>goroutine</code> 中作为返回值传出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(param1, param2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"param3, param4:"</span>, param1, param2)</span><br><span class="line">&#125;(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><code>Go</code>未为<code>channel</code>专门设置超时处理机制，但可通过<code>select</code>来设置超时。select用法与switch很类似，但select中只要其中一个<code>case</code>已经完成，程序就会继续往下执行，而不会考虑其他<code>case</code>情况，且每个<code>case</code>语句里必须是一个<code>IO</code>操作，<code>select</code>是按顺序<strong>从头至尾</strong>评估。若无语句可执行，则执行<code>default</code>语句，否则被阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num := &lt;-ch:</span><br><span class="line">    fmt.Println(<span class="string">"num:"</span>, num)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">    quit &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Go</code>的<code>sync</code>包中提供互斥锁<code>sync.Mutex</code>和读写互斥锁<code>sync.RWMutex</code>。同时提供了等待组<code>sync.WaitGroup</code>进行多个任务的<strong>同步</strong>，每个 <code>sync.WaitGroup</code> 值在内部维护着一个计数，保证在并发环境中完成指定数量的任务，若<code>WaitGroup</code>的值大于0，<code>Wait</code>方法就会被阻塞。同时提供原子访问<code>atomic</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw sync.Mutex</span><br><span class="line">rw.Lock()</span><br><span class="line"><span class="keyword">defer</span> rw.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rw sync.RWMutex</span><br><span class="line">rw.RLock()</span><br><span class="line"><span class="keyword">defer</span> rw.RUnlock()</span><br><span class="line">rw.Lock()</span><br><span class="line"><span class="keyword">defer</span> rw.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done() </span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">atomic.AddInt32(&amp;counter, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 安全的写整型值</span></span><br><span class="line">atomic.StoreInt64(&amp;counter, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 安全的读整型值</span></span><br><span class="line">atomic.LoadInt64(&amp;counter)</span><br></pre></td></tr></table></figure>
<p>死锁发生条件：</p>
<ul>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待</li>
</ul>
<p>解决办法：</p>
<ul>
<li>并发范文多个表，约定访问顺序</li>
<li>同一事物中，尽可能一次锁定获取所需资源</li>
<li>容易死锁业务场景，尝试升级锁颗粒度</li>
<li>采用分布式事务锁或乐观锁</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><code>reflect</code> 包定义了两个重要的类型 <code>Type</code> 和 <code>Value</code> <strong>任意接口值</strong>在反射中都可以理解为由 <code>reflect.Type</code> 和 <code>reflect.Value</code> 两部分组成；提供了<code>reflect.TypeOf</code> 和<code>reflect.ValueOf</code> 两个函数来获取任意对象的 <code>Value</code> 和 <code>Type</code>。</p>
<p>反射中分<strong>类型<code>Type</code></strong>和<strong>种类<code>Kind</code></strong>，当需要区分一个<strong>大品种</strong>的类型时用<code>Kind</code>，<code>Kind</code>方法描述的是<strong>基础类型</strong>；如需统一判断类型中的指针时。而Type是指<strong>系统原生数据类型</strong>，以及<strong>使用<code>type</code>关键字定义的类型</strong>。通过 <code>reflect.Elem()</code> 方法<strong>获取该指针指向的元素类型</strong>。<code>Elem</code>方法能够<strong>对指针进行解引用</strong>，然后将结果存储到<strong>反射 Value 类型对象</strong>  中。</p>
<p>反射可以将<strong>接口类型变量</strong>转换为<strong>反射类型对象</strong>，反射可以将<strong>反射类型对象</strong>转换为<strong>接口类型变量</strong>，若要修改<strong>反射类型对象</strong>其<strong>值必须是可写的</strong>。可通过 <code>CanSet</code> 方法检查<code>reflect.Value</code>类型变量的<strong>可写性</strong>。对于<strong>不具有可写性</strong>的 <code>Value</code> 类型变量，调用 <code>Set</code> 方法会<strong>报错</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">    B <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := &amp;T&#123;&#125;</span><br><span class="line">typeOfT := reflect.TypeOf(t)</span><br><span class="line"><span class="comment">// Name: ,Kind:ptr</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, typeOfT.Name(), <span class="string">"kind:"</span>, typeOfT.Kind())</span><br><span class="line"><span class="comment">// 通过 reflect.Elem() 方法获取这个指针指向的元素类型</span></span><br><span class="line">typeOfT = typeOfT.Elem()</span><br><span class="line"><span class="comment">// Name: T,Kind: struct</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, typeOfT.Name(), <span class="string">"kind:"</span>, typeOfT.Kind())</span><br><span class="line">typeOfT.Field(<span class="number">0</span>).SetInt(<span class="number">99</span>)</span><br><span class="line">typeOfT.Field(<span class="number">1</span>).SetString(<span class="string">"Sunset Strip"</span>)</span><br><span class="line"></span><br><span class="line">t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</span><br><span class="line">typeOfA := reflect.TypeOf(t)</span><br><span class="line"><span class="comment">// Name: T,Kind: struct</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, typeOfA.Name(), <span class="string">"kind:"</span>, typeOfA.Kind())</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">7</span></span><br><span class="line">tof := reflect.TypeOf(x)</span><br><span class="line"><span class="comment">// Name: MyInt,Kind: int</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, tof.Name(), <span class="string">"kind:"</span>, tof.Kind())</span><br><span class="line">vof := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 不能是int</span></span><br><span class="line">ref := vof.Interface().(MyInt)</span><br><span class="line">fmt.Println(<span class="string">"can set:"</span>, vof.CanSet()) <span class="comment">// false</span></span><br><span class="line">vof2 := reflect.ValueOf(&amp;x)</span><br><span class="line">fmt.Println(<span class="string">"can set:"</span>, vof2.CanSet()) <span class="comment">// false</span></span><br><span class="line">vof3 := vof2.Elem()</span><br><span class="line">fmt.Println(<span class="string">"can set:"</span>, vof3.CanSet()) <span class="comment">// true</span></span><br><span class="line">vof3.SetInt(<span class="number">25</span>)</span><br><span class="line">fmt.Println(<span class="string">"ref:"</span>, vof3)  <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p><code>Map</code>、<code>Slice</code>、<code>Chan</code> 属于<strong>引用类型</strong>，使用起来<strong>类似于指针</strong>，但是在种类常量定义中仍然属于<strong>独立的种类Kind</strong>，不属于 <code>Ptr</code>。所有通过<code>reflect.ValueOf(x)</code> 返回的<code>reflect.Value</code>都<strong>不可以取地址</strong>，通过<strong>指针</strong>间接地获取的<code>reflect.Value</code>都可以取地址，即使开始的是一个不可取地址的<code>Value</code>。当<strong><code>reflect.Value</code>不可寻址</strong>时，使用 <code>Addr()</code> 方法也<strong>无法取到值的地址</strong>。</p>
<p>已知<code>reflect.Type</code>时，可动态地创建这个类型的实例，实例的类型为<strong>指针</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">typeOfA := reflect.TypeOf(a)</span><br><span class="line">aIns := reflect.New(typeOfA)</span><br><span class="line"><span class="comment">// name: *int, kind: ptr</span></span><br><span class="line">fmt.Println(<span class="string">"name:"</span>, aIns.Type(), <span class="string">"kind:"</span>, aIns.Kind())</span><br></pre></td></tr></table></figure>
<p>使用反射调用函数时，需将参数使<strong>用反射值对象的切片<code>[]reflect.Value</code>构造后传入<code>Call()</code>方法中</strong>，调用完成时，函数的<strong>返回值</strong>通过<code>[]reflect.Value</code>返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">funcVal := reflect.ValueOf(<span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b</span><br><span class="line">&#125;)</span><br><span class="line">paramList := []reflect.Value&#123;reflect.ValueOf(<span class="number">10</span>), reflect.ValueOf(<span class="number">24</span>)&#125;</span><br><span class="line">retList := funcVal.Call(paramList)</span><br><span class="line">fmt.Println(<span class="string">"result:"</span>, retList[<span class="number">0</span>].Int())</span><br></pre></td></tr></table></figure>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><ul>
<li>测试用例文件<strong>不会参与正常源码的编译</strong>，<strong>不会被包含到可执行文件中</strong>；</li>
<li>测试用例的文件名必须以<code>_test.go</code>结尾；</li>
<li>需要使用 <code>import</code> 导入 <code>testing</code> 包；</li>
<li>测试函数的名称要以<code>Test</code>或<code>Benchmark</code>开头，后面可以跟任意字母组成的字符串，但第一个字母必须大写，例如 TestAbc()，一个测试用例文件中可以包含多个测试函数；</li>
<li>单元测试则以<code>(t *testing.T)</code>作为参数，性能测试以<code>(t *testing.B)</code>做为参数；</li>
<li>测试用例文件使用<code>go test</code>命令来执行，源码中不需要 main() 函数作为入口，所有以<code>_test.go</code>结尾的源码文件内以<code>Test</code>开头的函数都会自动执行。</li>
</ul>
<h3 id="SetFinalizer"><a href="#SetFinalizer" class="headerlink" title="SetFinalizer"></a>SetFinalizer</h3><p><code>Go</code>语言自带垃圾回收机制，<code>GC</code> 是自动进行的，可以使用 <code>runtime.GC()</code> 函数手动 <code>GC</code>。</p>
<p><code>finalizer</code>（<strong>终止器</strong>）是通过 <strong>runtime.SetFinalizer</strong> 来设置与对象关联的一个函数，若某对象定义了 <code>finalizer</code>，当它被 <code>GC</code> 时候，该<code>finalizer</code> 将被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFinalizer</span><span class="params">(x, f <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>参数<code>x</code> 必须是一个指向通过 <code>new</code> 申请的对象的<strong>指针</strong>，或者通过对复合字面值取址得到的<strong>指针</strong>，参数 <code>f</code> 必须是一个<strong>函数</strong>。<code>SetFinalizer</code> 函数将 <code>x</code> 的终止器设置为 <code>f</code>，当垃圾收集器发现 <code>x</code> 不能再直接或间接访问时，则清理 <code>x</code> 并调用 <code>f(x)</code>，终止器会在 <code>x</code> 不能直接或间接访问后的<strong>任意时间</strong>被调用执行，<strong>不保证终止器会在程序退出前执行</strong>，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。<code>*x</code> 的大小为 <code>0</code> 字节，也不保证终止器会执行。也可以使用<code>SetFinalizer(x, nil)</code>来清理绑定到 <code>x</code> 上的终止器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Road <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRoad</span><span class="params">(r *Road)</span></span> &#123;</span><br><span class="line">   log.Println(<span class="string">"road:"</span>, *r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entry</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> rd = Road(<span class="number">999</span>)</span><br><span class="line">   r := &amp;rd</span><br><span class="line">   runtime.SetFinalizer(r, findRoad)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    runtime.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>
        
    <footer class="article-footer">
    </footer>
    </div>
</article>


    
    <nav id="article-nav">
        
            <a href="/Blog/框架/常见问题/Maven编译后文件损坏/" id="article-nav-newer" class="article-nav-link-wrap">
                <strong class="article-nav-caption">Newer</strong>
                <div class="article-nav-title">
                    
                        Maven编译后文件损坏
                    
                </div>
            </a>
        
        
    </nav>





    
    




    <!-- baidu url auto push script -->
    <script type="text/javascript">
        !function () {
            var e = /([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi, r = window.location.href,
                o = document.referrer;
            if (!e.test(r)) {
                var n = "//api.share.baidu.com/s.gif";
                o ? (n += "?r=" + encodeURIComponent(document.referrer), r && (n += "&l=" + r)) : r && (n += "?l=" + r);
                var t = new Image;
                t.src = n
            }
        }(window);
    </script>
</section>
    </div>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            YaoYingLong &copy; 2020
            <!-- <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a> -->
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">wikitten</a>
        </div>
    </div>
</footer>
    

    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });


</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

</div>
</body>
